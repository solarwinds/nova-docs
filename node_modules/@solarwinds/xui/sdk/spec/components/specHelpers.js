"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const protractor = require("@solarwinds/uzi/protractor");
const protractor_1 = require("@solarwinds/uzi/protractor");
class SpecHelpers {
    /**
     * Checks if element is not present first. If it is present, returns true if the element is not displayed.
     * Internally getElement is used. If that call fails, the error is caught and onErrorResolveAs will be returned.
     * By default this value is false under the assumption that failure to locate the elemen means it is not present.
     * Useful in combination with browser.wait:
     * browser.wait(()=>SpecHelpers.isNotPresentOrNotDisplayed(myAtom));
     */
    static isNotPresentOrNotDisplayed(atom, onErrorResolveAs = true) {
        return SpecHelpers.wrapPromise((() => __awaiter(this, void 0, void 0, function* () {
            let displayed = onErrorResolveAs;
            try {
                if (yield atom.getElement().isPresent()) {
                    displayed = yield atom.getElement().isDisplayed();
                    return !displayed;
                }
                else {
                    return true;
                }
            }
            catch (e) {
                // Catch error since we dont' want failures of getElement or isPresent to
                // stop tests. Instead we return onErrorResolveAs
            }
            return displayed;
        }))());
    }
    /**
     * Checks if element is present first before calling element.isDisplayed to avoid error when element is
     * not even present
     */
    static isPresentAndDisplayed(atom) {
        return SpecHelpers.wrapPromise((() => __awaiter(this, void 0, void 0, function* () {
            let displayed = false;
            try {
                if (yield atom.getElement().isPresent()) {
                    displayed = yield atom.getElement().isDisplayed();
                    return displayed;
                }
                else {
                    return displayed;
                }
            }
            catch (e) {
                console.log("SpecHelpers.isPresentAndDisplayed", e.message);
            }
            return false;
        }))());
    }
    static mouseOver(atom, offset) {
        return protractor_1.browser.actions().mouseMove(atom.getElement().getWebElement(), offset).perform();
    }
    static mouseDown(atom, offset) {
        return SpecHelpers.wrapPromise((() => __awaiter(this, void 0, void 0, function* () {
            try {
                yield SpecHelpers.mouseOver(atom, offset);
                return yield protractor_1.browser.actions().mouseDown().perform();
            }
            catch (e) {
                console.log("SpecHelpers.mouseDown", e.message);
            }
            return;
        }))());
    }
    static mouseUp(atom, offset) {
        return SpecHelpers.wrapPromise((() => __awaiter(this, void 0, void 0, function* () {
            try {
                yield SpecHelpers.mouseOver(atom, offset);
                return yield protractor_1.browser.actions().mouseUp().perform();
            }
            catch (e) {
                console.log("SpecHelpers.mouseUp", e.message);
            }
            return;
        }))());
    }
    /**
     * Wraps an ES6 Promise as a WebDriver promise for scenarions where promises are needed by Protractor methods.
     */
    static wrapPromise(promise) {
        let deferred = protractor.promise.defer();
        promise.then((value) => deferred.fulfill(value))
            .catch((reason) => deferred.reject(reason));
        return deferred.promise;
    }
}
exports.default = SpecHelpers;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHMvc3BlY0hlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLHlEQUF5RDtBQUN6RCwyREFBNEQ7QUFPNUQ7SUFFSTs7Ozs7O09BTUc7SUFDSSxNQUFNLENBQUMsMEJBQTBCLENBQUMsSUFBVSxFQUFFLG1CQUE0QixJQUFJO1FBRWpGLE1BQU0sQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFVLENBQUMsR0FBUyxFQUFFO1lBQ2hELElBQUksU0FBUyxHQUFZLGdCQUFnQixDQUFDO1lBQzFDLElBQUksQ0FBQztnQkFDRCxFQUFFLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBQ3RDLFNBQVMsR0FBRyxNQUFNLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztvQkFDbEQsTUFBTSxDQUFDLENBQUMsU0FBUyxDQUFDO2dCQUN0QixDQUFDO2dCQUFDLElBQUksQ0FBQyxDQUFDO29CQUNKLE1BQU0sQ0FBQyxJQUFJLENBQUM7Z0JBQ2hCLENBQUM7WUFDTCxDQUFDO1lBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDVCx5RUFBeUU7Z0JBQ3pFLGlEQUFpRDtZQUNyRCxDQUFDO1lBQ0QsTUFBTSxDQUFDLFNBQVMsQ0FBQztRQUNyQixDQUFDLENBQUEsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNWLENBQUM7SUFFRDs7O09BR0c7SUFDSSxNQUFNLENBQUMscUJBQXFCLENBQUMsSUFBVTtRQUMxQyxNQUFNLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBVSxDQUFDLEdBQVMsRUFBRTtZQUNoRCxJQUFJLFNBQVMsR0FBWSxLQUFLLENBQUM7WUFDL0IsSUFBSSxDQUFDO2dCQUNELEVBQUUsQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDdEMsU0FBUyxHQUFHLE1BQU0sSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLFdBQVcsRUFBRSxDQUFDO29CQUNsRCxNQUFNLENBQUMsU0FBUyxDQUFDO2dCQUNyQixDQUFDO2dCQUFDLElBQUksQ0FBQyxDQUFDO29CQUVKLE1BQU0sQ0FBQyxTQUFTLENBQUM7Z0JBQ3JCLENBQUM7WUFDTCxDQUFDO1lBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDVCxPQUFPLENBQUMsR0FBRyxDQUFDLG1DQUFtQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNoRSxDQUFDO1lBQ0QsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUNqQixDQUFDLENBQUEsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNWLENBQUM7SUFFTSxNQUFNLENBQUMsU0FBUyxDQUFDLElBQVUsRUFBRSxNQUE0QjtRQUM1RCxNQUFNLENBQUMsb0JBQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLGFBQWEsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQzVGLENBQUM7SUFFTSxNQUFNLENBQUMsU0FBUyxDQUFDLElBQVUsRUFBRSxNQUE0QjtRQUM1RCxNQUFNLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBTyxDQUFDLEdBQVMsRUFBRTtZQUM3QyxJQUFJLENBQUM7Z0JBQ0QsTUFBTSxXQUFXLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztnQkFDMUMsTUFBTSxDQUFDLE1BQU0sb0JBQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUN6RCxDQUFDO1lBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDVCxPQUFPLENBQUMsR0FBRyxDQUFDLHVCQUF1QixFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNwRCxDQUFDO1lBQ0QsTUFBTSxDQUFDO1FBQ1gsQ0FBQyxDQUFBLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDVixDQUFDO0lBRU0sTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFVLEVBQUUsTUFBNEI7UUFFMUQsTUFBTSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQU8sQ0FBQyxHQUFTLEVBQUU7WUFDN0MsSUFBSSxDQUFDO2dCQUNELE1BQU0sV0FBVyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7Z0JBQzFDLE1BQU0sQ0FBQyxNQUFNLG9CQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDdkQsQ0FBQztZQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ1QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDbEQsQ0FBQztZQUNELE1BQU0sQ0FBQztRQUNYLENBQUMsQ0FBQSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ1YsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLFdBQVcsQ0FBSSxPQUFtQjtRQUM1QyxJQUFJLFFBQVEsR0FBRyxVQUFVLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBSyxDQUFDO1FBQzdDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDM0MsS0FBSyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDaEQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUM7SUFDNUIsQ0FBQztDQUNKO0FBeEZELDhCQXdGQyIsImZpbGUiOiJjb21wb25lbnRzL3NwZWNIZWxwZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcHJvdHJhY3RvciBmcm9tIFwiQHNvbGFyd2luZHMvdXppL3Byb3RyYWN0b3JcIjtcbmltcG9ydCB7YnJvd3NlciwgcHJvbWlzZX0gZnJvbSBcIkBzb2xhcndpbmRzL3V6aS9wcm90cmFjdG9yXCI7XG5pbXBvcnQgKiBhcyB3ZWJkcml2ZXIgZnJvbSBcIkBzb2xhcndpbmRzL3V6aS93ZWJkcml2ZXJcIjtcbmltcG9ydCB7QXRvbX0gZnJvbSBcIkBzb2xhcndpbmRzL3V6aVwiO1xuXG4vLyBOb2RlIHR5cGluZ3MgaGF2ZSBjb25mbGljdHMgd2l0aCB3ZWJwYWNrLWVudlxuZGVjbGFyZSB2YXIgcHJvY2VzczogYW55O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGVjSGVscGVycyB7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgZWxlbWVudCBpcyBub3QgcHJlc2VudCBmaXJzdC4gSWYgaXQgaXMgcHJlc2VudCwgcmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IGlzIG5vdCBkaXNwbGF5ZWQuXG4gICAgICogSW50ZXJuYWxseSBnZXRFbGVtZW50IGlzIHVzZWQuIElmIHRoYXQgY2FsbCBmYWlscywgdGhlIGVycm9yIGlzIGNhdWdodCBhbmQgb25FcnJvclJlc29sdmVBcyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEJ5IGRlZmF1bHQgdGhpcyB2YWx1ZSBpcyBmYWxzZSB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IGZhaWx1cmUgdG8gbG9jYXRlIHRoZSBlbGVtZW4gbWVhbnMgaXQgaXMgbm90IHByZXNlbnQuXG4gICAgICogVXNlZnVsIGluIGNvbWJpbmF0aW9uIHdpdGggYnJvd3Nlci53YWl0OlxuICAgICAqIGJyb3dzZXIud2FpdCgoKT0+U3BlY0hlbHBlcnMuaXNOb3RQcmVzZW50T3JOb3REaXNwbGF5ZWQobXlBdG9tKSk7XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBpc05vdFByZXNlbnRPck5vdERpc3BsYXllZChhdG9tOiBBdG9tLCBvbkVycm9yUmVzb2x2ZUFzOiBib29sZWFuID0gdHJ1ZSk6XG4gICAgICAgIHByb21pc2UuUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIHJldHVybiBTcGVjSGVscGVycy53cmFwUHJvbWlzZTxib29sZWFuPigoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRpc3BsYXllZDogYm9vbGVhbiA9IG9uRXJyb3JSZXNvbHZlQXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhd2FpdCBhdG9tLmdldEVsZW1lbnQoKS5pc1ByZXNlbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5ZWQgPSBhd2FpdCBhdG9tLmdldEVsZW1lbnQoKS5pc0Rpc3BsYXllZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWRpc3BsYXllZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2F0Y2ggZXJyb3Igc2luY2Ugd2UgZG9udCcgd2FudCBmYWlsdXJlcyBvZiBnZXRFbGVtZW50IG9yIGlzUHJlc2VudCB0b1xuICAgICAgICAgICAgICAgIC8vIHN0b3AgdGVzdHMuIEluc3RlYWQgd2UgcmV0dXJuIG9uRXJyb3JSZXNvbHZlQXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaXNwbGF5ZWQ7XG4gICAgICAgIH0pKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBlbGVtZW50IGlzIHByZXNlbnQgZmlyc3QgYmVmb3JlIGNhbGxpbmcgZWxlbWVudC5pc0Rpc3BsYXllZCB0byBhdm9pZCBlcnJvciB3aGVuIGVsZW1lbnQgaXNcbiAgICAgKiBub3QgZXZlbiBwcmVzZW50XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBpc1ByZXNlbnRBbmREaXNwbGF5ZWQoYXRvbTogQXRvbSk6IHByb21pc2UuUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIHJldHVybiBTcGVjSGVscGVycy53cmFwUHJvbWlzZTxib29sZWFuPigoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRpc3BsYXllZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoYXdhaXQgYXRvbS5nZXRFbGVtZW50KCkuaXNQcmVzZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheWVkID0gYXdhaXQgYXRvbS5nZXRFbGVtZW50KCkuaXNEaXNwbGF5ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXllZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXNwbGF5ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3BlY0hlbHBlcnMuaXNQcmVzZW50QW5kRGlzcGxheWVkXCIsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pKCkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgbW91c2VPdmVyKGF0b206IEF0b20sIG9mZnNldD86IHdlYmRyaXZlci5JTG9jYXRpb24pOiBwcm9taXNlLlByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gYnJvd3Nlci5hY3Rpb25zKCkubW91c2VNb3ZlKGF0b20uZ2V0RWxlbWVudCgpLmdldFdlYkVsZW1lbnQoKSwgb2Zmc2V0KS5wZXJmb3JtKCk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBtb3VzZURvd24oYXRvbTogQXRvbSwgb2Zmc2V0Pzogd2ViZHJpdmVyLklMb2NhdGlvbik6IHByb21pc2UuUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiBTcGVjSGVscGVycy53cmFwUHJvbWlzZTx2b2lkPigoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBTcGVjSGVscGVycy5tb3VzZU92ZXIoYXRvbSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgYnJvd3Nlci5hY3Rpb25zKCkubW91c2VEb3duKCkucGVyZm9ybSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3BlY0hlbHBlcnMubW91c2VEb3duXCIsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pKCkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgbW91c2VVcChhdG9tOiBBdG9tLCBvZmZzZXQ/OiB3ZWJkcml2ZXIuSUxvY2F0aW9uKTpcbiAgICAgICAgcHJvbWlzZS5Qcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIFNwZWNIZWxwZXJzLndyYXBQcm9taXNlPHZvaWQ+KChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFNwZWNIZWxwZXJzLm1vdXNlT3ZlcihhdG9tLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBicm93c2VyLmFjdGlvbnMoKS5tb3VzZVVwKCkucGVyZm9ybSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3BlY0hlbHBlcnMubW91c2VVcFwiLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyBhbiBFUzYgUHJvbWlzZSBhcyBhIFdlYkRyaXZlciBwcm9taXNlIGZvciBzY2VuYXJpb25zIHdoZXJlIHByb21pc2VzIGFyZSBuZWVkZWQgYnkgUHJvdHJhY3RvciBtZXRob2RzLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgd3JhcFByb21pc2U8VD4ocHJvbWlzZTogUHJvbWlzZTxUPik6IHByb21pc2UuUHJvbWlzZTxUPiB7XG4gICAgICAgIGxldCBkZWZlcnJlZCA9IHByb3RyYWN0b3IucHJvbWlzZS5kZWZlcjxUPigpO1xuICAgICAgICBwcm9taXNlLnRoZW4oKHZhbHVlKSA9PiBkZWZlcnJlZC5mdWxmaWxsKHZhbHVlKSlcbiAgICAgICAgICAgIC5jYXRjaCgocmVhc29uKSA9PiBkZWZlcnJlZC5yZWplY3QocmVhc29uKSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
