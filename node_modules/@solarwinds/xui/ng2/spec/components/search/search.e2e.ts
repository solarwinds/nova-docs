import * as protractor from "@solarwinds/uzi/protractor";
import { browser, promise } from "@solarwinds/uzi/protractor";

import { Atom } from "@solarwinds/uzi";
import { SearchAtom, ButtonAtom, IconAtom, SpinnerAtom } from "../index.atom";
import Helpers from "../helpers";

describe("USERCONTROL search", () => {
    let expectedFocusedDelay: number = 2000;
    let atom: SearchAtom;
    let searchBtnAtom: ButtonAtom;
    let cancelBtnAtom: ButtonAtom;
    let toggleDisableBtnAtom: ButtonAtom;
    let toggleBusyBtnAtom: ButtonAtom;
    let toggleActiveBtnAtom: ButtonAtom;
    let setFocusBtnAtom: ButtonAtom;
    let busySpinnerAtom: SpinnerAtom;

    beforeEach(() => {
        Helpers.prepareBrowser("search");
        atom = Atom.find(SearchAtom, "xui-demo-search");
        searchBtnAtom = atom.getSearchButton();
        cancelBtnAtom = atom.getCancelButton();
        busySpinnerAtom = atom.getSpinner();
        toggleDisableBtnAtom = Atom.find(ButtonAtom, "xui-demo-search-toggle-disable-btn");
        toggleBusyBtnAtom = Atom.find(ButtonAtom, "xui-demo-search-toggle-busy-btn");
        toggleActiveBtnAtom = Atom.find(ButtonAtom, "xui-demo-search-toggle-active-btn");
        setFocusBtnAtom = Atom.find(ButtonAtom, "xui-demo-search-set-focus-btn");
    });

    beforeAll(() => {
        browser.ignoreSynchronization = true;
    });

    afterAll(() => {
        browser.ignoreSynchronization = false;
    });

    it("should have search button shown", async () => {
        expect(searchBtnAtom.isIconShown()).toBe(true);
        let iconAtom: IconAtom = await searchBtnAtom.getIcon();
        expect(iconAtom.getName()).toBe("search");
    });

    it("should not have cancel button displayed if input field is empty", () => {
        expect(cancelBtnAtom.isIconShown()).toBe(false);
    });

    it("should have cancel button displayed if input field is not empty", async () => {
        await atom.acceptInput("foo");
        expect(cancelBtnAtom.isIconShown()).toBe(true);
        let iconAtom: IconAtom = await cancelBtnAtom.getIcon();
        expect(iconAtom.getName()).toBe("close");
    });

    it("should display busy status depending on 'busy' prop", async () => {
        await expect(atom.isBusy()).toBe(false);
        await toggleBusyBtnAtom.click();
        await expect(atom.isBusy()).toBe(true);
        await toggleBusyBtnAtom.click();
        await expect(atom.isBusy()).toBe(false);
    });

    it("should reset busy status when 'cancel' is clicked while busy", async () => {
        await expect(atom.isBusy()).toBe(false);
        await atom.acceptInput("foo");
        await searchBtnAtom.click();
        await expect(atom.isBusy()).toBe(true);
        await cancelBtnAtom.click();
        await expect(atom.isBusy()).toBe(false);
    });

    it("buttons should be disabled when 'disabled' prop is true", async () => {
        await expect(searchBtnAtom.isDisabled()).toBe(false);
        let input = "foo";
        await atom.acceptInput(input);
        await expect(cancelBtnAtom.isDisabled()).toBe(false);
        await toggleDisableBtnAtom.click();
        await expect(searchBtnAtom.isDisabled()).toBe(true);
        await expect(cancelBtnAtom.isDisabled()).toBe(true);
    });

    it("input should be disabled when 'disabled' prop is true", async () => {
        await expect(atom.isDisabled()).toBe(false);
        await toggleDisableBtnAtom.click();
        await expect(atom.isDisabled()).toBe(true);
    });

    it("input should be active when 'active' prop is true", async () => {
        await expect(atom.isActive()).toBe(false);
        await toggleActiveBtnAtom.click();
        await expect(atom.isActive()).toBe(true);
    });

    it("should search on enter key", async () => {
        await expect(atom.isBusy()).toBe(false);
        await atom.acceptInput("foo");
        await atom.acceptInput(protractor.Key.ENTER);
        await expect(atom.isBusy()).toBe(true);
    });

    it("should get focus on initialization when 'captureFocus' prop is 'true'", async () => {
        await expect(atom.isFocused()).toEqual(true);
        await browser.driver.switchTo().defaultContent();
    });

    it("should have focus depending on 'captureFocus' prop", async () => {
        await setFocusBtnAtom.click();
        await expect(atom.isFocused()).toEqual(true);
        await browser.driver.switchTo().defaultContent();
        await browser.sleep(expectedFocusedDelay);
        await expect(atom.isFocused()).toEqual(false);
        await browser.driver.switchTo().defaultContent();
    });

    it("should get focus on cancel when not busy", async () => {
        let input = "foo";
        await atom.acceptInput(input);
        await cancelBtnAtom.click();
        await expect(atom.isFocused()).toEqual(true);
        await browser.driver.switchTo().defaultContent();
    });

    it("should get focus on cancel when busy", async () => {
        let input = "foo";
        await atom.acceptInput(input);
        await searchBtnAtom.click();
        await expect(atom.isBusy()).toBe(true);
        await cancelBtnAtom.click();
        await expect(atom.isFocused()).toEqual(true);
        await browser.driver.switchTo().defaultContent();
    });

    it("should lose focus on search", async () => {
        let input = "foo";
        await atom.acceptInput(input);
        await searchBtnAtom.click();
        await expect(atom.isBusy()).toBe(true);
        await expect(atom.isFocused()).toEqual(false);
        await browser.driver.switchTo().defaultContent();
    });
});
