import {browser, by, promise} from "@solarwinds/uzi/protractor";
import {Atom} from "@solarwinds/uzi";
import {MessageAtom} from "../index.atom";
import Helpers from "../helpers";

describe("USERCONTROL Message", () => {

    let messageDismissAllowed: MessageAtom;
    let messageDismissNotAllowed: MessageAtom;
    let messageDismissPrevented: MessageAtom;

    beforeEach(() => {
        Helpers.prepareBrowser("message");
        messageDismissAllowed = Atom.find(MessageAtom, "message--dismiss-allowed");
        messageDismissNotAllowed = Atom.find(MessageAtom, "message--dismiss-not-allowed");
        messageDismissPrevented = Atom.find(MessageAtom, "message--dismiss-prevented");
    });

    it("should have type class based on 'type' attribute", () => {
        expect(messageDismissAllowed.hasClass("xui-message-info")).toBe(true);
    });

    it("should show dismiss button when allowed", () => {
        expect(messageDismissAllowed.isDismissable()).toBe(true);
    });

    it("shouldn't show dismiss button when not allowed", async () => {
        let present = await messageDismissNotAllowed.getDismissButton().isPresent();

        expect(present).toBe(false);
    });

    it("should be dismissed", async () => {
        browser.ignoreSynchronization = true;
        let visible = await messageDismissAllowed.isVisible();
        expect(visible).toBe(true);

        messageDismissAllowed.dismissMessage();

        // browser.element(by.css("selector")) is used to avoid stale element reference error,
        // which might appear due to ignoreSynchronization
        await browser.wait(() => browser.element(by.css("#message--dismiss-allowed")).isPresent().then(v => {
            visible = v;
            return !v;
        }), 1000);

        expect(visible).toBe(false);
        browser.ignoreSynchronization = false;
    });

    it("should not be dismissed after 'click' due to prevented event", async () => {
        await messageDismissPrevented.getDismissButton().click();
        expect(await messageDismissPrevented.isVisible()).toBe(true);
    });

});
