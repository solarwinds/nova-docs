import { Atom } from "@solarwinds/uzi";
import { browser, by, element } from "@solarwinds/uzi/protractor";
import { TextboxAtom, RadioGroupAtom, SpinnerAtom, CheckboxAtom, CheckboxGroupAtom } from "../index.atom";
import Helpers from "../helpers";

describe("USERCONTROL textbox", () => {

    let textBox: TextboxAtom;
    let multiTextBox: TextboxAtom;
    let stateRadioGroup: RadioGroupAtom;
    let widthRadioGroup: RadioGroupAtom;
    let typeRadioGroup: RadioGroupAtom;
    let asyncSpinner: SpinnerAtom;
    let asyncCheckbox: CheckboxAtom;
    let checkboxGroup: CheckboxGroupAtom;
    let isSpinnerDisplayed: () => Promise<boolean>;
    let isValidationDisplayed: () => Promise<boolean>;
    let getValidationText: () => Promise<string>;

    beforeEach(() => {
        Helpers.prepareBrowser("textbox");
        browser.ignoreSynchronization = true;

        asyncCheckbox = Atom.find(CheckboxAtom, "xui-demo-async-checkbox");
        textBox = Atom.find(TextboxAtom, "test-textbox");
        multiTextBox = Atom.find(TextboxAtom, "test-multi-textbox");
        stateRadioGroup = Atom.find(RadioGroupAtom, "test-state-group");
        widthRadioGroup = Atom.find(RadioGroupAtom, "test-width-group");
        typeRadioGroup = Atom.find(RadioGroupAtom, "xui-demo-type-group");
        asyncSpinner = Atom.findIn(SpinnerAtom, element(by.id("test-textbox")));
        checkboxGroup = Atom.findIn(CheckboxGroupAtom, element(by.className("demo-options-section")));

        isSpinnerDisplayed = async () => {
            let isDisplayed = browser.wait( async () => {
                return await asyncSpinner.isDisplayed();
            }, 2000);
            try {
                return await isDisplayed;
            } catch (e) {
                return false;
            }
        };

        isValidationDisplayed = async () => {
            return await browser.isElementPresent(by.className("xui-textbox__messages"));
        };

        getValidationText = async () => {
            let isDisplayed = browser.wait( async () => {
                return await browser.findElement(by
                                    .xpath("//*[@class=\"xui-textbox__messages xui-validation\"]/div/div"))
                                    .getText();
            }, 2000);
            return await isDisplayed;
        };        
    });

    /**
     * Tests start here
     */
    
    it("should have native input element with \"required\" attribute", async () => {
        (await stateRadioGroup.getRadioByValue("required")).click();

        expect(await textBox.required()).toBe(true);
        expect(await multiTextBox.required()).toBe(true);
    });

    it("should have native input element with \"disabled\" attribute", async () => {
        (await stateRadioGroup.getRadioByValue("disabled")).click();

        expect(await textBox.disabled()).toBe(true);
        expect(await multiTextBox.disabled()).toBe(true);
    });

    it("should have native input element with \"readonly\" attribute", async () => {
        (await stateRadioGroup.getRadioByValue("readonly")).click();

        expect(await textBox.isReadonly()).toBe(true);
        expect(await multiTextBox.isReadonly()).toBe(true);
    });

    it("allows to change width", async () => {
        const baseWidth = (await textBox.input.getSize()).width;

        (await widthRadioGroup.getRadioByValue("100px")).click();

        const newWidth = (await textBox.input.getSize()).width;
        expect(newWidth).toEqual(100);
    });

    it("allows to change rows (multiline option) value", async () => {
        const rowsBox = Atom.find(TextboxAtom, "test-rows-box");
        const baseHeight = (await multiTextBox.getElement().getSize()).height;

        await rowsBox.input.sendKeys("7");
        browser.wait(async () => {
            return (await multiTextBox.getElement().getSize()).height !== baseHeight;
        }, 1000);

        const newHeight = (await multiTextBox.getElement().getSize()).height;
        expect(newHeight > baseHeight).toBe(true);
    });

    describe("testing sync and async validation", () => {
        beforeEach(async () => {
            if (await asyncCheckbox.isChecked() === false) {
                await asyncCheckbox.click();
            }
            // Validation is not triggered by default
            expect(await isValidationDisplayed()).toBeFalsy();
        });

        it("should spinner be visible during the async validate of the textbox", async () => {
            await textBox.clearText();
            await textBox.acceptText("abcde");
            expect(await isSpinnerDisplayed()).toBeTruthy();
        });
    
        it("should prevent async validation if sync is triggered first", async () => {
            await textBox.clearText();
            await textBox.acceptText("Ted");
            expect(await isValidationDisplayed()).toBeTruthy();
            expect(await getValidationText()).not.toBe("Ted's error");
        });

        it("should trigger sync validation on invalid value", async () => {
            await textBox.clearText();
            await textBox.acceptText("1");
            expect(await isSpinnerDisplayed()).toBeFalsy();
            expect(await isValidationDisplayed()).toBeTruthy();
        });

        it("should not trigger sync validation if user clears optional field", async () => {
            await textBox.clearText();
            await textBox.acceptText("1");
            await textBox.deleteTextManually();
            expect(await isSpinnerDisplayed()).toBeTruthy();
            expect(await isValidationDisplayed()).toBeFalsy();
        });

        it("should show error message if async validation fails as user types letters in", async () => {
            //Checking the min length checkbox off for the test to get rid off sync validation
            (await checkboxGroup.getFirst()).click();
            await textBox.clearText();
            const ted = "Ted";
            // Simulating user's behavior by entering each letter one by one and checking the validation state
            ted.split("").forEach( async (letter, idx, arr) => {
                await textBox.acceptText(letter);
                expect(await isSpinnerDisplayed()).toBeTruthy();
                if (!(idx === arr.length -1)) {                    
                    expect(await isValidationDisplayed()).toBeFalsy();    
                } else {
                    browser.sleep(1000);
                    expect(await isValidationDisplayed()).toBeTruthy();
                    expect(await getValidationText()).toBe("Ted's error");
                }
            });
        });
    });

    describe("when type is number", () => {
        beforeEach(async () => {
            (await typeRadioGroup.getRadioByValue("number")).click();
        });

        it("should increase the value when numeric up button is pressed", () => {
            textBox.acceptText("0");

            const upButton = textBox.getNumericUpButton();
            upButton.click();
            expect(textBox.value).toBe("1");
            upButton.click();
            expect(textBox.value).toBe("2");
        });

        it("should increase the value when numeric up button is pressed", () => {
            textBox.acceptText("0");

            const upButton = textBox.getNumericDownButton();
            upButton.click();
            expect(textBox.value).toBe("-1");
            upButton.click();
            expect(textBox.value).toBe("-2");
        });
    });
});
