import { browser, by, element, ElementFinder, promise } from "@solarwinds/uzi/protractor";
import { Atom } from "@solarwinds/uzi";

export class ToastAtom extends Atom {
    public static CSS_CLASS = "xui-toast";
    public toastTimeout: number = 5000;

    public static get(index: number = 0): ToastAtom {
        return new ToastAtom(element.all(by.css(`.${ToastAtom.CSS_CLASS}`)).get(index));
    }

    public static close(waitForNotDisplayed: boolean = false): Promise<boolean> {
        return (async () => {
            try {
                const toastAtom: ToastAtom = ToastAtom.get();
                if (await toastAtom.getElement().isDisplayed()) {
                    const closed = await toastAtom.close(waitForNotDisplayed);
                    return closed;
                }
            } catch (e) {
                console.log("static ToastAtom.close", e);
            }
            return false;
        })();
    }

    public getTitle(): promise.Promise<string> {
        return this.getElement().element(by.css(".toast-title")).getText();
    }

    public getBody(): promise.Promise<string> {
        return this.getBodyElement().getText();
    }

    private getBodyElement(): ElementFinder {
        return this.getElement().element(by.css(".toast-body"));
    }

    private isToastType(type: string): Promise<boolean> {
        return Atom.hasClass(this.getElement(), `xui-toast--${type}`);
    }

    public close(waitForNotDisplayed: boolean = false): Promise<boolean> {
        return (async () => {
            try {
                await this.getElement().element(by.className("toast-close-icon")).click();
                if (!waitForNotDisplayed) {
                    return true;
                }
                const closed = await this.waitUntilNotDisplayed();
                return closed;

            } catch (e) {
                console.log("ToastAtom.close", e);
            }
            return false;
        })();
    }

    public isSuccessType(): Promise<boolean> {
        return this.isToastType("success");
    }

    public isWarningType(): Promise<boolean> {
        return this.isToastType("warning");
    }

    public isInfoType(): Promise<boolean> {
        return this.isToastType("info");
    }

    public isErrorType(): Promise<boolean> {
        return this.isToastType("error");
    }

    public waitUntilDisplayed(): Promise<boolean> {
        return (async () => {
            try {
                return await browser.wait( () =>
                        this.getElement().isDisplayed(),
                    this.toastTimeout);
            } catch (e) {
                console.log("Toast.waitUntilDisplayed", e);
            }
            return false;
        })();
    }

    public waitUntilNotDisplayed(): Promise<boolean> {
        return (async () => {
            try {
                return await browser.wait( async () => {
                    let element = await this.getElement();
                    let displayed = await element.isPresent();
                    return element && displayed ? !displayed : true;
                },
                this.toastTimeout);
            } catch (e) {
                console.log("Toast.waitUntilNotDisplayed", e);
            }
            return false;
        })();
    }
}
