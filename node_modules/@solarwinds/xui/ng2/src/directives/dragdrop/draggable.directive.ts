import {
    Directive,
    ElementRef,
    EventEmitter,
    HostBinding,
    HostListener,
    Input,
    NgZone,
    OnInit,
    Output
} from "@angular/core";
import { SwUtilService } from "../../services/sw-util.service";
import { ScrollConstants } from "../../constants/dragdrop.constants";

/**
 * Directive that provides draggable behavior for an element
 *
 *  __Usage:__
 *
 * Bind this directive to an element to add a draggable behavior to it.
 *
 *        `<div xuiDraggable>Some content</div>`
 *
 * Make sure that this zone has some content, because draggable directive doesn't set any height
 * to the element. This won't work:
 *
 *        `<div xuiDraggable></div>`
 *
 * Don't forget to assign some payload (data for transmission from draggable to droppable).
 * It can be an `Object`, string or whatever can be converted to a string:
 *
 *        `<div xuiDraggable [payload]="myData"></div>`
 *
 * To subscribe to an event `onDragStart, onDragEnd` just transmit an attribute
 *
 *         `<div xuiDroppable (onDragStart)="dragStart($event)"></div>`
 *
 * And `dragStart` method will look like that:
 *
 *         `public dragStart(dropEvent: DragEvent) {
 *              //dropEvent - HTML 5 drag event (native)
 *          };`
 *
 * In addition you can transmit a CSS class that will
 */
/**
 * <example-url>./../../../demo/index.html#/dragdrop</example-url>
 */

@Directive({
    selector: "[xuiDraggable]"
})
export class DraggableDirective implements OnInit {
    @Output() onDragStart = new EventEmitter();
    @Output() onDragEnd = new EventEmitter();
    @Input() adornerDragClass: string;
    @Input() payload: any;

    private static draggableClass = "xui-drag__draggable";
    private static draggingClass = "xui-drag--dragging";
    private static dragSourceClass = "xui-drag__drag-source";
    private static adornerClass = "xui-drag__drag-container";
    private static adornerHaloClass = "xui-drag__drag-halo";
    private static dragsourceOverlayClass = "xui-drag__drag-source--overlay";

    private adorner: HTMLElement;
    private dragsourceOverlay: HTMLElement;

    @HostBinding(`class.${DraggableDirective.draggableClass}`)
    @HostBinding("attr.draggable") draggable: boolean;
    @HostListener("dragstart", ["$event"])
    dragStart(event: DragEvent) {
        this.onDragStart.emit(event);
        window.getSelection().removeAllRanges();
        let stringifiedPayload: string;
        stringifiedPayload = _.isObject(this.payload) ? JSON.stringify(this.payload) : <string>this.payload;
        this.dragsourceOverlay = this.createDragVisuals(event);
        this.setImageAndData(event, stringifiedPayload);
        /*
            runOutsideAngular is used when some action has to be performed outside
            angular zone. Therefore, this action won't trigger change detection.
        */
        this.zone.runOutsideAngular(() => {
            document.addEventListener("dragover", this.mouseHook);
        });
        event.stopPropagation();
    }

    @HostListener("dragend", ["$event"])
    dragEnd (event: DragEvent) {
        this.onDragEnd.emit(event);
        this.elRef.nativeElement.classList.remove(DraggableDirective.dragSourceClass);
        this.adorner.remove();
        this.adorner = null;

        this.dragsourceOverlay.remove();
        this.dragsourceOverlay = null;
        event.stopPropagation();

        this.zone.runOutsideAngular(() => {
            document.removeEventListener("dragover", this.mouseHook);
        });
    }

    constructor(private elRef: ElementRef,
                private zone: NgZone,
                private swUtilService: SwUtilService) {}

    ngOnInit() {
        this.draggable = true;
    }

    private mouseHook = (event: DragEvent) => {
        const clientX = event.clientX;
        const clientY = event.clientY;
        this.moveDragAdorner({x: clientX, y: clientY});
    };

    private moveDragAdorner = _.throttle((coordinates: {x: number, y: number}) => {
        requestAnimationFrame(() => {
            if (this.adorner) {
                this.adorner.style.left = coordinates.x + "px";
                this.adorner.style.top = coordinates.y + "px";
            }
            this.autoScroll(coordinates.x, coordinates.y);
        });
    }, ScrollConstants.adornerUpdateThrottleInMs);

    private createDragVisuals = (event: DragEvent) => {
        //copy the node being dragged, and add effects
        this.adorner = document.createElement("div");
        this.adorner.style.left = event.clientX + "px";
        this.adorner.style.top = event.clientY + "px";
        this.adorner.classList.add(DraggableDirective.adornerClass);
        if (this.adornerDragClass) {
            this.adorner.classList.add(this.adornerDragClass);
        }
        const adornerHalo = document.createElement("div");
        adornerHalo.classList.add(DraggableDirective.adornerHaloClass);
        this.adorner.appendChild(adornerHalo);

        // Safari shows the dragImage natively, so we don't have to fake it
        if (!this.swUtilService.isSafari()) {
            const copiedNode = (<any>event.currentTarget).cloneNode(true);
            copiedNode.style.width = this.elRef.nativeElement.offsetWidth + "px";
            copiedNode.style.height = this.elRef.nativeElement.offsetHeight + "px";
            copiedNode.classList.add(DraggableDirective.draggingClass);
            copiedNode.removeAttribute("draggable");
            this.adorner.appendChild(copiedNode);
        }

        //if there is a place to attach to, do it.  Otherwise, place it after the copied node

        this.elRef.nativeElement.parentNode.appendChild(this.adorner);

        //this should be the overlay that fades out the existing node
        const dragSourceOverlay = document.createElement("div");
        dragSourceOverlay.classList.add(DraggableDirective.dragsourceOverlayClass);

        //Fix for Google Chrome, appending of overlay in regular way cause unreasonable dispatch of "dragend" event
        window.setTimeout(() => {
            this.elRef.nativeElement.appendChild(dragSourceOverlay);
        }, 0);

        this.elRef.nativeElement.classList.add(DraggableDirective.dragSourceClass);

        return dragSourceOverlay;
    };

    private setImageAndData(event: DragEvent, payload: string) {
        if ((typeof DragEvent !== "undefined" && event instanceof DragEvent) || event.dataTransfer) {
            try {
                if (event.dataTransfer.setDragImage) {
                    if (this.swUtilService.isSafari()) {
                        // Safari supports dragImage in a usable way
                        event.dataTransfer.setDragImage(this.elRef.nativeElement, 0, -10);
                    } else {
                        // but other browsers don't so we have to disable it
                        const emptyItem = document.createElement("div");
                        event.dataTransfer.setDragImage(emptyItem, 0, 0);
                    }
                } else {
                    //IE hack, to ensure there is no drag ghost (it does not support setDragImage)
                    const target = this.elRef.nativeElement;
                    const cloneNode = target.cloneNode(true);
                    this.elRef.nativeElement.classList.add("hide");
                    target.parentNode.insertBefore(cloneNode, target);
                    window.setTimeout(() => {
                        //To make sure that cloned node will be removed on time
                        target.parentNode.removeChild(cloneNode);
                        this.elRef.nativeElement.classList.remove("hide");
                    }, 0);
                }
                event.dataTransfer.dropEffect = "copy";

                //IE only allows text and url in setData, NOTHING ELSE
                event.dataTransfer.setData("Text", payload);
                event.dataTransfer.setData("text/plain", payload);
            } catch (e) {
                //silently fail in IE
            }
        }
    }

    private autoScroll (clientX: number, clientY: number) {
        if (!clientX || !clientY) {
            return;
        }
        const verticalDistPercentage = (clientY / window.innerHeight) * 100;
        const horizontalDistPercentage = (clientX / window.innerWidth) * 100;
        const topScrollBoundary = ScrollConstants.verticalScrollPercentage;
        const bottomScrollBoundary = 100 - ScrollConstants.verticalScrollPercentage;
        const leftScrollBoundary = ScrollConstants.horizontalScrollPercentage;
        const rightScrollBoundary = 100 - ScrollConstants.horizontalScrollPercentage;

        let newX = window.pageXOffset;
        let newY = window.pageYOffset;

        let scrollNeeded = false;
        if (verticalDistPercentage < topScrollBoundary) {
            let throttle =
                (topScrollBoundary - verticalDistPercentage) * ScrollConstants.accelerationFactor;
            newY = newY - throttle;
            scrollNeeded = true;
        }
        if (verticalDistPercentage > bottomScrollBoundary) {
            let throttle =
                (verticalDistPercentage - bottomScrollBoundary) * ScrollConstants.accelerationFactor;
            newY = newY + throttle;
            scrollNeeded = true;
        }
        if (horizontalDistPercentage < leftScrollBoundary) {
            let throttle =
                (leftScrollBoundary - horizontalDistPercentage) * ScrollConstants.accelerationFactor;
            newX = newX - throttle;
            scrollNeeded = true;
        }
        if (horizontalDistPercentage > rightScrollBoundary) {
            let throttle =
                (horizontalDistPercentage - rightScrollBoundary) * ScrollConstants.accelerationFactor;
            newX = newX + throttle;
            scrollNeeded = true;
        }
        if (scrollNeeded) {
            window.scrollTo(newX, newY);
        }
    };
}
