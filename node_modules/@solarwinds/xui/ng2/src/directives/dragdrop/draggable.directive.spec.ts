import { async, ComponentFixture, TestBed } from "@angular/core/testing";
import { Component, CUSTOM_ELEMENTS_SCHEMA, DebugElement } from "@angular/core";
import { BrowserDynamicTestingModule, platformBrowserDynamicTesting } from "@angular/platform-browser-dynamic/testing";
import { DraggableDirective } from "./draggable.directive";
import { SwUtilService } from "../../services/sw-util.service";
import { By } from "@angular/platform-browser";

describe("directives >", () => {
    describe("draggable >", () => {
        type DragEventType = "drag" | "dragstart" | "dragend" | "dragover";
        const successStatus = "success";
        const highlightOnClass = "highlight-on";
        const highlightFadeOutClass = "highlight-fadeout";
        let subject: DraggableDirective;
        let fixture: ComponentFixture<DraggableTestingComponent>;
        let component: DraggableTestingComponent;
        let draggableElement: DebugElement;
        let draggableDirective: DraggableDirective;

        const emitEvent = (eventType: DragEventType, element: HTMLElement | Document) => {
            const event = new DragEvent(eventType);
            element.dispatchEvent(event);
        };

        beforeAll(() => {
            TestBed.initTestEnvironment(
                BrowserDynamicTestingModule,
                platformBrowserDynamicTesting()
            );
        });

        beforeEach(() => {
            TestBed.configureTestingModule({
                    declarations: [DraggableDirective, DraggableTestingComponent],
                    providers: [SwUtilService],
                    schemas: [CUSTOM_ELEMENTS_SCHEMA]
                });
            fixture = TestBed.createComponent(DraggableTestingComponent);
            fixture.autoDetectChanges(true);
            component = fixture.componentInstance;
            draggableElement = fixture.debugElement.query(By.directive(DraggableDirective));
            draggableDirective = draggableElement.injector.get(DraggableDirective) as DraggableDirective;
        });

        afterEach(() => {
            fixture = TestBed.createComponent(DraggableTestingComponent);
        });

        it("should set draggable attribute to a draggable element", () => {
            expect(draggableElement.nativeElement.hasAttribute("draggable")).toBeTruthy();
        });

        it("should set draggable decoration class", () => {
            expect(draggableElement.nativeElement.classList.contains("xui-drag__draggable") !== -1).toBeTruthy();
        });

        it("should trigger emission of dragstart event", () => {
            spyOn(component, "onDragStart");
            draggableElement.triggerEventHandler("dragstart", null);
            expect(component.onDragStart).toHaveBeenCalled();
        });

        it("should trigger emission of dragend event", () => {
            spyOn(component, "onDragEnd");
            draggableElement.triggerEventHandler("dragend", null);
            expect(component.onDragEnd).toHaveBeenCalled();
        });

        it("should create overlay of draggable element", async(() => {
            emitEvent("dragstart", draggableElement.nativeElement);
            expect(draggableDirective["dragsourceOverlay"].classList.contains("xui-drag__drag-source--overlay"))
                .toBeTruthy();
            fixture.whenStable().then(() => {
                const firstChild = draggableElement.nativeElement.firstChild;
                expect(firstChild.classList.contains("xui-drag__drag-source--overlay")).toBeTruthy();
            });
        }));

        it("should create adorner element", () => {
            emitEvent("dragstart", draggableElement.nativeElement);
            expect(draggableDirective["adorner"]).not.toBeUndefined();
        });

        it("should add halo to adorner element", () => {
            emitEvent("dragstart", draggableElement.nativeElement);
            const haloChild = draggableDirective["adorner"].firstElementChild;
            expect(haloChild).not.toBeUndefined();
            expect(haloChild.classList.contains("xui-drag__drag-halo")).toBeTruthy();
        });

        it("should add draggable element to adorner", () => {
            emitEvent("dragstart", draggableElement.nativeElement);
            const draggable = draggableDirective["adorner"].lastElementChild;
            expect(draggable).not.toBeUndefined();
            expect(draggable.id).toEqual("test-draggable");
        });

        it("should remove overlay on dragend", () => {
            emitEvent("dragstart", draggableElement.nativeElement);
            expect(draggableDirective["dragsourceOverlay"].classList.contains("xui-drag__drag-source--overlay"))
                .toBeTruthy();
            emitEvent("dragend", draggableElement.nativeElement);
            expect(draggableDirective["dragsourceOverlay"]).toBeNull();
        });

        it("should autoscroll on drag over", async(() => {
            spyOn(draggableDirective, "moveDragAdorner");
            emitEvent("dragstart", draggableElement.nativeElement);
            emitEvent("dragover", document);
            fixture.whenStable().then(() => {
                expect(draggableDirective["moveDragAdorner"]).toHaveBeenCalled();
            });
        }));
    });
});

@Component({
    template: `<div xuiDraggable
                    id="test-draggable"
                    [payload]="draggableString"
                    [adornerDragClass]="'demoDragClass'"
                    (onDragStart)="onDragStart($event)"
                    (onDragEnd)="onDragEnd()"></div>`
})
class DraggableTestingComponent {
    public draggableString = "this is a string";
    public onDragStart (event: DragEvent) {
        _.noop();
    }

    public onDragEnd (event: DragEvent) {
        _.noop();
    }
}
