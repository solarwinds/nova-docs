/**
 * Internal service for tooltip's position calculating
 */
class TooltipPositionService {

    public positionElements(hostElement: HTMLElement, targetElement: HTMLElement,
                            position: string, appendToBody?: boolean): { top: number, left: number } {
        let targetElementPosition: { top: number, left: number };
        const positionVertical = position;
        const positionHorizontal = "center";
        const hostElementPosition = appendToBody ? this.offset(hostElement) : this.position(hostElement);
        const targetElementWidth = targetElement.offsetWidth;
        const targetElementHeight = targetElement.offsetHeight;
        const shiftWidth: { [key: string]: () => number } = {
            center: function (): number {
                return hostElementPosition.left + hostElementPosition.width / 2 - targetElementWidth / 2;
            },
            left: function (): number {
                return hostElementPosition.left;
            },
            right: function (): number {
                return hostElementPosition.left + hostElementPosition.width;
            }
        };
        const shiftHeight: { [key: string]: () => number } = {
            center: function (): number {
                return hostElementPosition.top + hostElementPosition.height / 2 - targetElementHeight / 2;
            },
            top: function (): number {
                return hostElementPosition.top;
            },
            bottom: function (): number {
                return hostElementPosition.top + hostElementPosition.height;
            }
        };

        switch (positionVertical) {
            case "right":
                targetElementPosition = {
                    top: shiftHeight[positionHorizontal](),
                    left: shiftWidth[positionVertical]()
                };
                break;

            case "left":
                targetElementPosition = {
                    top: shiftHeight[positionHorizontal](),
                    left: hostElementPosition.left - targetElementWidth
                };
                break;

            case "bottom":
                targetElementPosition = {
                    top: shiftHeight[positionVertical](),
                    left: shiftWidth[positionHorizontal]()
                };
                break;

            default:
                targetElementPosition = {
                    top: hostElementPosition.top - targetElementHeight,
                    left: shiftWidth[positionHorizontal]()
                };
                break;
        }

        return targetElementPosition;
    }

    private position(nativeElement: HTMLElement): { width: number, height: number, top: number, left: number } {
        let offsetParentBoundingClientRect = { top: 0, left: 0 };
        const elementBoundingClientRect = this.offset(nativeElement);
        const offsetParentElement = this.parentOffsetEl(nativeElement);

        if (offsetParentElement !== window.document) {
            offsetParentBoundingClientRect = this.offset(offsetParentElement);
            offsetParentBoundingClientRect.top += offsetParentElement.clientTop - offsetParentElement.scrollTop;
            offsetParentBoundingClientRect.left += offsetParentElement.clientLeft - offsetParentElement.scrollLeft;
        }

        const boundingClientRect = nativeElement.getBoundingClientRect();

        return {
            width: boundingClientRect.width || nativeElement.offsetWidth,
            height: boundingClientRect.height || nativeElement.offsetHeight,
            top: elementBoundingClientRect.top - offsetParentBoundingClientRect.top,
            left: elementBoundingClientRect.left - offsetParentBoundingClientRect.left
        };
    }

    private offset(nativeElement: any): { width: number, height: number, top: number, left: number } {
        const boundingClientRect = nativeElement.getBoundingClientRect();

        return {
            width: boundingClientRect.width || nativeElement.offsetWidth,
            height: boundingClientRect.height || nativeElement.offsetHeight,
            top: boundingClientRect.top + (window.pageYOffset || window.document.documentElement.scrollTop),
            left: boundingClientRect.left + (window.pageXOffset || window.document.documentElement.scrollLeft)
        };
    }

    private getStyle(nativeElement: HTMLElement, cssProp: string): string {
        if ((nativeElement as any).currentStyle) { // IE
            return (nativeElement as any).currentStyle[cssProp];
        }

        if (window.getComputedStyle) {
            return (window.getComputedStyle(nativeElement) as CSSStyleDeclaration & { [key: string]: any })[cssProp];
        }

        // finally try and get inline style
        return (nativeElement.style as CSSStyleDeclaration & { [key: string]: any })[cssProp];
    }

    private isStaticPositioned(nativeElement: HTMLElement): boolean {
        return (this.getStyle(nativeElement, "position") || "static" ) === "static";
    }

    private parentOffsetEl(nativeElement: HTMLElement): any {
        let offsetParent: any = nativeElement.offsetParent || window.document;

        while (offsetParent && offsetParent !== window.document && this.isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || window.document;
    }
}

export const tooltipPositionService = new TooltipPositionService();
