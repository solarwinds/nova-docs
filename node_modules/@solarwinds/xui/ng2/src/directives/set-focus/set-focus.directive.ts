import {
    Directive,
    Inject,
    Input,
    Output, EventEmitter,
    OnChanges, SimpleChanges,
    ElementRef,
    AfterViewInit
} from "@angular/core";
import { DOCUMENT } from "@angular/common";

/**
 * <example-url>./../../../demo/index.html#/set-focus</example-url>
 * 
 * Allows focus to be databound. Note: a "tabindex" property may be required.
 * 
 * Under the hood directive calls element.focus() and element.blur() on data bound changes.
 * If host element is not a focusable HTML element (neither \<input\> nor \<textarea\>, e.g. \<xui-textbox\>), 
 * directive tries to find an appropriate focusable one among children.
 */
@Directive({ selector: "[xuiSetFocus]" })
export class SetFocusDirective implements AfterViewInit {
    private static readonly focusablesToCapture: string[] = ["input", "textarea"];
    /**
    * This property controls whether element is focused (true) or not (false).
    */
    @Input() public xuiSetFocus: boolean;
    /**
    * Event fired on extarnal focus changes (initiated from UI by user). 
    * Passed value indicates whether element gets focus (true) of lose it (false).
    * Use it when you need to synchronize inner state of directive's 'xuiSetFocus' property and bound input property.
    */
    @Output() public focusChange = new EventEmitter<boolean>();

    private focusableElement: HTMLElement;

    constructor(private el: ElementRef,
                @Inject(DOCUMENT) private document: Document) {}

    public ngOnChanges(changes: SimpleChanges): void {
        if (!this.focusableElement || !changes["xuiSetFocus"]) {
            return;
        };
        if (changes["xuiSetFocus"].currentValue) {
            this.focusableElement.focus();
        } else {
            this.focusableElement.blur();
        }
    }

    public ngAfterViewInit() {
        this.focusableElement = this.getFirstFocusable(this.el.nativeElement);
        this.focusableElement.addEventListener("focus", this.onFocus);
        this.focusableElement.addEventListener("blur", this.onBlur);
        if (this.xuiSetFocus) {
            this.focusableElement.focus();
        }
    }

    private onBlur = () => {
        if (this.document.activeElement !== this.focusableElement) {
            if (this.xuiSetFocus) {
                this.xuiSetFocus = false;
                this.focusChange.emit(false);
            }
        }
    };

    private onFocus = () => {
        if (this.document.activeElement === this.focusableElement) {
            if (!this.xuiSetFocus) {
                this.xuiSetFocus = true;
                this.focusChange.emit(true);
            }
        }
    };

    private getFirstFocusable(element: HTMLElement): HTMLElement {
        const tagName = element["tagName"].toLowerCase();
        let result: HTMLElement;
        if (SetFocusDirective.focusablesToCapture.indexOf(tagName) !== -1) {
            result = element;
        } else {
            let children = element.querySelectorAll(SetFocusDirective.focusablesToCapture.join());
            result = children.length ? <HTMLElement>children[0] : element;
        }
        return result;
    }
}
