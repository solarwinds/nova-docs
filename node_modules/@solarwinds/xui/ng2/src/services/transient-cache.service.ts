import { Injectable } from "@angular/core";
import { Observable } from "rxjs/Rx";
import { SwUtilService } from "./sw-util.service";

export interface ITransientCache {
    put:(key:string, value:any, lifetime:number) => Promise<void>;
    get:(key:string) => any;
    remove:(key:string) => void;
    removeAll:() => void;
    destroy:() => void;
    entryCount:() => number;
    size:() => number;
}

 interface ICache {
    [key: string]: any;
}

/**
 * __Name : __
 * TransientCache service
 *
 */
@Injectable()
export class TransientCacheService implements ITransientCache {
    private cache:ICache = {};
    
    constructor(private swUtilService: SwUtilService) {}

    public put = (key:string, value:any, lifetime:number): Promise<void> => {
        if (typeof key === "undefined" || key === null) {
            return Promise.reject("no key");
        }
        if (typeof value === "undefined" || value === null) {
            return Promise.reject("no value");
        }
        this.cache[key] = value;
        const timer = Observable.timer(lifetime);
        return timer.map(() => {
            this.remove(key);
        }).toPromise();
    };

    public remove = (key:string):void => {
        delete this.cache[key];
    };

    public get = (key:string):any => {
        return this.cache[key];
    };

    public removeAll = ():void => {
        for (let key in this.cache) {
            if (this.cache.hasOwnProperty(key)) {
                this.remove(key);
            }
        }
    };

    public destroy = ():void => {
        this.removeAll();
    };

    public entryCount = ():number => {
        return Object.keys(this.cache).length;
    };

    public size = ():number => {
        let byteCount = 0;

        for (let key in this.cache) {
            if (this.cache.hasOwnProperty(key)) {
                byteCount += this.swUtilService.sizeof(key)
                          +  this.swUtilService.sizeof(this.get(key));
            }
        }

        return byteCount;
    };
}
