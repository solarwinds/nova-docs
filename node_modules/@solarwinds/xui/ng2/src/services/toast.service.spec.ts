import {BrowserDynamicTestingModule, platformBrowserDynamicTesting} from "@angular/platform-browser-dynamic/testing";
import {TestBed, fakeAsync} from "@angular/core/testing";
import NotificationService from "./notification-service";
import {ToastContainerService} from "./toast-container.service";
import {ToastComponent} from "../components/toast/toast.component";
import {ToastService} from "./toast.service";
import {IconComponent} from "../components/icon/icon.component";

describe("services >", () => {
    describe("toast >", () => {
        let toastService: any;
        let toastContainerService: any;
        beforeAll(() => {
            TestBed.overrideModule(BrowserDynamicTestingModule, {
                set: {
                    entryComponents: [ ToastComponent ],
                },
            });
            TestBed
                .initTestEnvironment(
                    BrowserDynamicTestingModule,
                    platformBrowserDynamicTesting()
                )
                .configureTestingModule({
                    declarations: [ToastComponent, IconComponent],
                    providers: [NotificationService, ToastContainerService, ToastService],
                });
            toastService = TestBed.get(ToastService);
        });

        beforeEach(() => {
            toastService.clear();
        });
        it("setConfig should override global toast config", () => {
            expect(toastService.toastConfig.timeOut).toEqual(5000);
            toastService.setConfig({
                timeOut: 10000
            });
            expect(toastService.toastConfig.timeOut).toEqual(10000);
        });
        it("should activate success toast", () => {
            const activeToast = toastService.success("Test message");
            expect(toastService.toasts.length).toBeGreaterThan(0);
            expect(activeToast.body).toEqual("Test message");
        });
        it("should activate warning toast", () => {
            const activeToast = toastService.warning("Test message");
            expect(toastService.toasts.length).toBeGreaterThan(0);
            expect(activeToast.body).toEqual("Test message");
        });
        it("should activate error toast", () => {
            const activeToast = toastService.error("Test message");
            expect(toastService.toasts.length).toBeGreaterThan(0);
            expect(activeToast.body).toEqual("Test message");
        });
        it("should activate info toast", () => {
            const activeToast = toastService.info("Test message");
            expect(toastService.toasts.length).toBeGreaterThan(0);
            expect(activeToast.body).toEqual("Test message");
        });
        it("should make error message unclosable", () => {
            const activeToast = toastService.error("Test message", "", {stickyError: true});
            expect(activeToast.toastRef.componentInstance.instance.options.timeOut).toEqual(0);
            expect(activeToast.toastRef.componentInstance.instance.options.extendedTimeOut).toEqual(0);
            expect(activeToast.toastRef.componentInstance.instance.options.closeButton).toBeFalsy();
        });
        it("clear should remove toasts", () => {
            fakeAsync(() => {
                toastService.success("Success");
                toastService.error("Error");
                expect(toastService.toasts.length).toBeGreaterThan(0);
                toastService.clear();
                expect(toastService.toasts.length).toEqual(0);
            });
        });
        it("remove should activate next inactive toast", () => {
            fakeAsync(() => {
                toastService.setConfig({
                    maxOpened: 1
                });
                const activeToast = toastService.success("Success");
                const deferredToast = toastService.info("Info");
                expect(toastService.currentlyActive).toEqual(0);
                toastService.remove(activeToast.id);
                expect(toastService.currentlyActive).toEqual(1);
                expect(deferredToast.toastRef.activate).toHaveBeenCalled();
            });
        });
    });
});
