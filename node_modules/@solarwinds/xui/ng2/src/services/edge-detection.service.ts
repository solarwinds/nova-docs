import { Injectable, Inject } from "@angular/core";
import { Logger } from "angular2-logger/app/core/logger";
import { DOCUMENT } from "@angular/common";

export interface IEdgeDetectionResult {
    placed: {
        top: boolean;
        right: boolean;
        bottom: boolean;
        left: boolean;
    };
    aligned: {
        top: boolean;
        right: boolean;
        bottom: boolean;
        left: boolean;
    };
}

export interface IEdgeDetectionCoordinates {
    left: number;
    top: number;
}

export interface IEdgeDetectionService {
    canBe(basePointElement: Element, placedElement: Element): IEdgeDetectionResult;
}

export interface IEdgeDefinerMeasurements {
    position: IEdgeDetectionCoordinates;
    width: number;
    height: number;
    scrollY: number;
    scrollX: number;
}

/**
 * <example-url>./../../../demo/index.html#/edge-detection-service</example-url>
 */

/**
 *  Service that helps to calculate free space for dynamic elements (popover, dropdown, etc.) and define the best
 *  direction to show them. There are two ways how detection can be made:
 *  1) default one - detection is made within viewport area.
 *  2) custom container can be used for detection. Identify such container using 'xui-edge-detection' CSS-class.
 *
 * __Name :__
 * Edge Detection Service
 */

@Injectable()
export class EdgeDetectionService {
    public edgeDefinerSelector = ".xui-edge-definer";
    public initialEdgeDetectionResult: IEdgeDetectionResult;

    constructor(@Inject(DOCUMENT) private document: Document,
                private logger: Logger) {
        this.initialEdgeDetectionResult = {
            placed: {
                top: false,
                right: false,
                bottom: false,
                left: false
            },
            aligned: {
                top: false,
                right: false,
                bottom: false,
                left: false
            }
        };
    };

    public canBe = (basePoint: HTMLElement,
                    placed: HTMLElement,
                    edgeDefinerElement?: Element): IEdgeDetectionResult => {
        if (!basePoint || !placed) {
            this.logger.error("basePoint: Element and placed: Element arguments are required!");
            return;
        }

        const result = this.initialEdgeDetectionResult;
        const edgeDefiner = edgeDefinerElement || this.document.querySelector(this.edgeDefinerSelector);
        const basePosition = this.offset(basePoint);
        const baseWidth = this.outer(basePoint, "width");
        const baseHeight = this.outer(basePoint, "height");
        const depositWidth = this.outer(placed, "width");
        const depositHeight = this.outer(placed, "height");
        const container = this.getEdgeDefinerMeasurements(edgeDefiner);

        result.placed.top = basePosition.top - container.position.top - depositHeight > scrollY;
        result.placed.right = basePosition.left - container.position.left + baseWidth + depositWidth
            < container.width + scrollX;
        result.placed.bottom = basePosition.top - container.position.top + baseHeight + depositHeight
            < container.height + scrollY;
        result.placed.left = basePosition.left - container.position.left - depositWidth > scrollX;

        result.aligned.top = basePosition.top - container.position.top + depositHeight < scrollY + container.height;
        result.aligned.right = basePosition.left - container.position.left + baseWidth - depositWidth > scrollX;
        result.aligned.bottom = basePosition.top - container.position.top + baseHeight - depositHeight > scrollY;
        result.aligned.left = basePosition.left - container.position.left + depositWidth < scrollX + container.width;

        return result;
    };

    private outer(element: HTMLElement, dimension: "width" | "height"): number {
        const clientValue = _.get<HTMLElement, number>(element, `client${_.capitalize(dimension)}`);

        if (clientValue) {
            return clientValue;
        }

        return _.parseInt(_.get<CSSStyleDeclaration, string>(getComputedStyle(element), dimension));
    }

    private offset(element: HTMLElement): IEdgeDetectionCoordinates {
        const rect = element.getBoundingClientRect();
        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

        return { top: rect.top + scrollTop, left: rect.left + scrollLeft };
    }

    private getEdgeDefinerMeasurements(edgeDefiner: Element): IEdgeDefinerMeasurements {
        if (edgeDefiner) {
            return {
                position: this.offset(edgeDefiner as HTMLElement),
                width: edgeDefiner.clientWidth,
                height: edgeDefiner.clientHeight,
                scrollY: edgeDefiner.scrollTop,
                scrollX: edgeDefiner.scrollLeft
            };
        }

        return {
            position: {top: 0, left: 0},
            width: window.innerWidth,
            height: window.innerHeight,
            scrollY: window.scrollY || window.pageYOffset,
            scrollX: window.scrollX || window.pageXOffset
        };
    }
}
