import { SwUtilService } from "./sw-util.service";

describe("services >", () => {
    describe("SwUtilService >", () => {
        let swUtilService: SwUtilService;

        beforeEach(() => {
            swUtilService = new SwUtilService();
        });

        describe("when sizeof() is called", () => {
            it("should handle string properly", () => {
                const string = "abc";
                const stringLength = string.length * 2;

                expect(swUtilService.sizeof(string)).toEqual(stringLength);
            });

            it("should handle boolean properly", () => {
                const boolean = true;
                const booleanLength = 4;

                expect(swUtilService.sizeof(boolean)).toEqual(booleanLength);
            });

            it("should handle number properly", () => {
                const number = 42;
                const numberLength = 8;

                expect(swUtilService.sizeof(number)).toEqual(numberLength);
            });

            it("should handle object properly", () => {
                const inner = {
                    key: "value"
                };
                const object = {
                    key: inner
                };
                const objectLength = 2 * 2 * "key".length + 2 * "value".length;

                expect(swUtilService.sizeof(object)).toEqual(objectLength);
            });
        });

        describe("when nextUid() is called", () => {
            it("should return uid", () => {
                const uid = swUtilService.nextUid();
                expect(uid.length).toEqual(3);
            });

            it("each call should return new uid", () => {
                const first = swUtilService.nextUid();
                const second = swUtilService.nextUid();
                expect(first).not.toEqual(second);
            });
        });

        describe("when formatString() is called", () => {
            it("formats a string with one string argument", () => {
                expect(swUtilService.formatString("Formatted {0}", "string")).toEqual("Formatted string");
            });

            it("formats a string with two string arguments in reverse order", () => {
                expect(swUtilService.formatString("Double-{1} formatted {0}", "string", "argument"))
                    .toEqual("Double-argument formatted string");
            });

            it("formats a string with three string arguments", () => {
                expect(swUtilService.formatString("{0}-{1} formatted {2}", "Triple", "argument", "string"))
                    .toEqual("Triple-argument formatted string");
            });

            it("formats a string with three string arguments in reverse order", () => {
                expect(swUtilService.formatString("{2}-{1} formatted {0}", "string", "argument", "Triple"))
                    .toEqual("Triple-argument formatted string");
            });

            it("formats a string with one single-digit decimal argument", () => {
                expect(swUtilService.formatString("Formatted decimal: {0}", 0)).toEqual("Formatted decimal: 0");
            });

            it("formats a string with one multiple-digit decimal argument", () => {
                expect(swUtilService.formatString("Formatted triple-digit decimal: {0}", 123))
                    .toEqual("Formatted triple-digit decimal: 123");
            });

            it("formats a string with multiple decimal arguments", () => {
                expect(swUtilService.formatString("First decimal: {0}, Second decimal: {1}", 123, 456))
                    .toEqual("First decimal: 123, Second decimal: 456");
            });

            it("formats a string with a single floating point argument", () => {
                expect(swUtilService.formatString("Floating point: {0}", 1.23))
                    .toEqual("Floating point: 1.23");
            });

            it("formats a string with a multiple floating point arguments", () => {
                expect(swUtilService.formatString("First floating point: {0}, Second floating point: {1}", 1.23, 4.56))
                    .toEqual("First floating point: 1.23, Second floating point: 4.56");
            });

            it("formats a string with one false boolean argument", () => {
                expect(swUtilService.formatString("Formatted boolean: {0}", false)).toEqual("Formatted boolean: false");
            });

            it("formats a string with one true boolean argument", () => {
                expect(swUtilService.formatString("Formatted boolean: {0}", true)).toEqual("Formatted boolean: true");
            });

            it("formats a string with all possible argument types", () => {
                expect(swUtilService.formatString(`Formatted boolean: {0},
                                                   Formatted decimal: {1},
                                                   Formatted string: {2},
                                                   Formatted floating point: {3}`, true, 123, "test", 1.23))
                    .toEqual(`Formatted boolean: true,
                                                   Formatted decimal: 123,
                                                   Formatted string: test,
                                                   Formatted floating point: 1.23`);
            });

            it("allows for undefined arguments", () => {
                expect(swUtilService.formatString("Undefined value: {0}", undefined))
                    .toEqual("Undefined value: ");
            });

            it("allows for null arguments", () => {
                expect(swUtilService.formatString("Null value: {0}", null))
                    .toEqual("Null value: ");
            });

            it("allows for escaping open and close braces", () => {
                expect(swUtilService.formatString("{0} and {1} braces: {{ property: value }}", "Open", "close"))
                    .toEqual("Open and close braces: { property: value }");
            });

            it("allows for escaping open and close braces with an embedded insertion point", () => {
                expect(swUtilService.formatString("{0} and {1} braces: {{property: {2}}}", "Open", "close", "value"))
                    .toEqual("Open and close braces: {property: value}");
            });
        });

        describe("when dateEquals() is called", () => {
            it("returns true for both undefined", () => {
                expect(swUtilService.dateEquals(undefined, undefined)).toBe(true);
            });

            it("returns true for both null", () => {
                expect(swUtilService.dateEquals(null, null)).toBe(true);
            });

            it("returns false for undefined and null", () => {
                expect(swUtilService.dateEquals(undefined, null)).toBe(false);
            });

            it("returns false for null and undefined", () => {
                expect(swUtilService.dateEquals(null, undefined)).toBe(false);
            });

            it("returns true for same instance", () => {
                const d = new Date();
                expect(swUtilService.dateEquals(d, d)).toBe(true);
            });

            it("returns false for different values", () => {
                const d1 = new Date();
                const d2 = new Date();
                d2.setHours(0, 0, 0, 0);
                expect(swUtilService.dateEquals(d1, d2)).toBe(false);
            });
        });
    });
});
