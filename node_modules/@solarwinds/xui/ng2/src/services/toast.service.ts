import * as _ from "lodash";
import {
    Injectable,
    ComponentRef,
    SecurityContext,
    Sanitizer,
    Injector
} from "@angular/core";
import { SwitchState } from "./notification-args";
import { NotificationService } from "./notification-service";
import { Observable } from "rxjs/Observable";
import { SafeHtml } from "@angular/platform-browser";
import { ToastContainerService } from "./toast-container.service";
import { ToastComponent } from "../components/toast/toast.component";
import { ToastInjector } from "../components/toast/toast-injector";
import { IToastConfig } from "../components/toast/toast-config";
import { ToastRef } from "../components/toast/toast-ref";
import { ToastPackage } from "../components/toast/toast-package";

export interface IToastService {
    setConfig(config: IToastConfig, itemIdentificator?: string): void;
    error(message: string, title?: string, options?: IToastConfig, itemsToHighlight?: any[]): IActiveToast;
    info(message: string, title?: string, options?: IToastConfig, itemsToHighlight?: any[]): IActiveToast;
    success(message: string, title?: string, options?: IToastConfig, itemsToHighlight?: any[]): IActiveToast;
    warning(message: string, title?: string, options?: IToastConfig, itemsToHighlight?: any[]): IActiveToast;
    clear(toastId?: number): void;
}

export interface IActiveToast {
    toastId?: number;
    body?: string;
    toastContainer?: ComponentRef<any>;
    toastRef: ToastRef<any>;
    onShown?: Observable<any>;
    onHidden?: Observable<any>;
    onClick?: Observable<any>;
}

/**
 * __Name : __
 * Toast Service
 *
 * __Usage :__
 * Used to show toast messages and to trigger highlight of items
 */
@Injectable()
export class ToastService implements IToastService {
    private index = 0;
    private currentlyActive = 0;
    private toasts: IActiveToast[] = [];
    private defaultToastConfig: IToastConfig = {
        maxOpened: 0,
        autoDismiss: false,
        newestOnTop: true,
        preventDuplicates: false,
        positionClass: "toast-top-right",
        titleClass: "toast-title",
        bodyClass: "toast-body",
        progressAnimation: "decreasing",
        timeOut: 5000,
        progressBar: true,
        toastClass: "xui-toast",
        extendedTimeOut: 2000,
        closeButton: true,
        iconClasses: {
            error: "xui-toast--error xui-icon-name-severity_error",
            info: "xui-toast--info xui-icon-name-severity_info",
            success: "xui-toast--success xui-icon-name-severity_ok",
            warning: "xui-toast--warning xui-icon-name-severity_warning"
        },
        clickToDismiss: false,
        enableHtml: true,
        stickyError: false
    };
    private toastConfig: IToastConfig;
    private itemIdentificator: string;

    constructor(private notificationService: NotificationService,
                private toastContainerService: ToastContainerService,
                private _injector: Injector,
                private sanitizer: Sanitizer
    ) {
        this.toastConfig = _.assign({}, this.defaultToastConfig);
    }

    /**
     *
     * __Description:__ set global config for all kind of toasts and itemIdentificator that is
     * used for identification of item in xuiToast directive
     * @param config
     * @param itemIdentificator
     * @return void
     */
    public setConfig(config: IToastConfig, itemIdentificator?: string): void {
        _.assign(this.toastConfig, config);
        this.itemIdentificator = itemIdentificator;
    }

    /**
     *
     * __Description:__ show success toast trigger highlight of items and trigger fade out of highlighting when
     * toast is gone
     *
     * @param body
     * @param title
     * @param options
     * @param itemsToHighlight
     * @return void
     */
    public success(body: string = "", title: string = "", options?: IToastConfig,
                   itemsToHighlight?: any[]): IActiveToast {
        const type = this.toastConfig.iconClasses.success || "";
        const toastInstance = this.buildNotification(type, body, title, this.applyConfig(options));
        this.notifyHighlights(itemsToHighlight, "success");
        this.toastRemoveHighlight(toastInstance, itemsToHighlight);
        return toastInstance;
    }

    public warning(body: string = "", title: string = "", options?: IToastConfig,
                   itemsToHighlight?: any[]): IActiveToast {
        const type = this.toastConfig.iconClasses.warning || "";
        const toastInstance = this.buildNotification(type, body, title, this.applyConfig(options));
        this.notifyHighlights(itemsToHighlight, "warning");
        this.toastRemoveHighlight(toastInstance, itemsToHighlight);
        return toastInstance;
    }

    public error(body: string = "", title: string = "", options?: IToastConfig,
                 itemsToHighlight?: any[]): IActiveToast {
        const type = this.toastConfig.iconClasses.error || "";
        const config = _.cloneDeep(options);
        if (options && options.stickyError) {
            config.timeOut = 0;
            config.extendedTimeOut = 0;
            config.progressBar = false;
            config.closeButton = false;
        }

        const toastInstance = this.buildNotification(type, body, title, this.applyConfig(config));
        this.notifyHighlights(itemsToHighlight, "error");
        this.toastRemoveHighlight(toastInstance, itemsToHighlight);
        return toastInstance;
    }

    public info(body: string = "", title: string = "", options?: IToastConfig,
                itemsToHighlight?: any[]): IActiveToast {
        const type = this.toastConfig.iconClasses.info || "";
        const toastInstance = this.buildNotification(type, body, title, this.applyConfig(options));
        this.notifyHighlights(itemsToHighlight, "info");
        this.toastRemoveHighlight(toastInstance, itemsToHighlight);
        return toastInstance;
    }

    /**
     *
     * __Description:__ calls toasts' close methods to close them
     *
     * @param toastId
     * @return void
     */
    public clear(toastId?: number) {
        for (const toast of this.toasts) {
            if (toastId !== undefined) {
                if (toast.toastId === toastId) {
                    toast.toastRef.manualClose();
                    return;
                }
            } else {
                toast.toastRef.manualClose();
            }
        }
    }

    /**
     *
     * __Description:__ removes toast by id and activates next toast in queue (when maxOpened !== 0)
     *
     * @param toastId
     * @return boolean
     */
    public remove(toastId: number): boolean {
        const toastInstance = this.findToast(toastId);
        if (!toastInstance) {
            return false;
        }
        toastInstance.activeToast.toastRef.close();
        this.toasts.splice(toastInstance.index, 1);
        this.currentlyActive = this.currentlyActive - 1;
        if (!this.toastConfig.maxOpened || !this.toasts.length) {
            return false;
        }
        if (this.currentlyActive <= +this.toastConfig.maxOpened && this.toasts[this.currentlyActive]) {
            const activeToastRef = this.toasts[this.currentlyActive].toastRef;
            if (!activeToastRef.isInactive()) {
                this.currentlyActive = this.currentlyActive + 1;
                activeToastRef.activate();
            }
        }
        return true;
    }

    private toastRemoveHighlight(toastInstance: IActiveToast, itemsToRemoveHighlight?: any[]): void {
        if (toastInstance) {
            toastInstance
                .onHidden
                .take(1)
                .subscribe(() => {
                    if (_.isArray(itemsToRemoveHighlight) && itemsToRemoveHighlight.length > 0) {
                        this.notificationService.post("Highlight", {
                            highlightState: SwitchState.off,
                            items: itemsToRemoveHighlight
                        });
                    }
                });
        }
    }

    private applyConfig(override: IToastConfig = {}): IToastConfig {
        const resultConfig = _.assign({}, this.toastConfig, override);
        resultConfig.timeOut = _.toInteger(resultConfig.timeOut);
        resultConfig.extendedTimeOut = _.toInteger(resultConfig.extendedTimeOut);
        return resultConfig;
    }

    private buildNotification(
        toastType: string,
        body: string,
        title: string | undefined,
        config: IToastConfig,
    ): IActiveToast {
        // max opened and auto dismiss = true
        if (body && config.preventDuplicates && this.isDuplicate(body)) {
            return null;
        }
        let keepInactive = false;
        if (this.toastConfig.maxOpened && this.currentlyActive >= this.toastConfig.maxOpened) {
            keepInactive = true;
            if (this.toastConfig.autoDismiss) {
                this.clear(this.toasts[this.toasts.length - 1].toastId);
            }
        }
        const toastContainer = this.toastContainerService.getContainerElement(config.positionClass);
        this.index = this.index + 1;
        let sanitizedBody: string = body;
        if (body && config.enableHtml) {
            sanitizedBody = this.sanitizer.sanitize(SecurityContext.HTML, body);
        }
        const toastRef: ToastRef<ToastComponent> = new ToastRef(this.toastContainerService);
        const toastPackage: ToastPackage = new ToastPackage(
            this.index,
            config,
            sanitizedBody,
            title,
            toastType,
            toastRef,
        );
        const toastInjector = new ToastInjector(toastPackage, this._injector);
        toastRef.componentInstance = this.toastContainerService.attachToast(ToastComponent, toastInjector,
            config.newestOnTop);
        const toastInstance: IActiveToast = {
            toastId: this.index,
            body,
            toastRef,
            onShown: toastRef.afterActivate(),
            onHidden: toastRef.afterClosed(),
            onClick: toastPackage.onClick(),
        };
        if (!keepInactive) {
            setTimeout(() => {
                toastInstance.toastRef.activate();
                this.currentlyActive = this.currentlyActive + 1;
            });
        }
        this.toasts.push(toastInstance);
        return toastInstance;
    }

    /**
     * Determines if toast message is already shown
     */
    private isDuplicate(body: string) {
        for (let i = 0; i < this.toasts.length; i++) {
            if (this.toasts[i].body === body) {
                return true;
            }
        }
        return false;
    }

    private findToast(toastId: number): { index: number, activeToast: IActiveToast } | null {
        for (let i = 0; i < this.toasts.length; i++) {
            if (this.toasts[i].toastId === toastId) {
                return { index: i, activeToast: this.toasts[i] };
            }
        }
        return null;
    }

    private notifyHighlights = (itemsToHighlight: any[], status: string): void => {
        if (itemsToHighlight) {
            this.notificationService.post("Highlight", {
                highlightState: SwitchState.on,
                status: status,
                items: itemsToHighlight,
                itemIdentificator: this.itemIdentificator
            });
        }
    };
}
