import { Injectable } from "@angular/core";

/**
 * Service providing common utilities
 */
@Injectable()
export class SwUtilService {
    private nextUniqueId = ["0", "0", "0"];

    /**
     * Formats the target string in the same way as .NET's String.format
     * @param {string} target the target string
     * @param {Array<any>} params one or more numbers, booleans, or strings to insert
     *     into the target string at the specified location(s)
     * @returns {string} the formatted string
     */
    public formatString(target: string, ...params: Array<any>): string {
        let toString = function (obj: any, format: any) {
            let ctor = function (o) {
                if (typeof o === "number") {
                    return Number;
                } else if (typeof o === "boolean") {
                    return Boolean;
                } else if (typeof o === "string") {
                    return String;
                } else {
                    return o.constructor;
                }
            }(obj);
            let proto = ctor.prototype;
            let formatter = typeof obj !== "string" ?
                (proto ? proto.format || proto.toString : obj.format || obj.toString) :
                obj.toString;
            if (formatter) {
                if (typeof format === "undefined" || format === "") {
                    return formatter.call(obj);
                } else {
                    return formatter.call(obj, format);
                }
            } else {
                return "";
            }
        };

        target = target.replace(/\{\{|\}\}|\{([^}: ]+?)(?::([^}]*?))?\}/g, function (match, num, format) {
            if (match === "{{") {
                return "{";
            }
            if (match === "}}") {
                return "}";
            }
            if (typeof params[num] !== "undefined" && params[num] !== null) {
                return toString(params[num], format);
            } else {
                return "";
            }
        });

        return target;
    }

    /**
     * Determines if the browser is Safari
     * @returns {boolean}
     */
    public isSafari(): boolean {
        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    }

    /**
     * nextUid, from angular.js.
     * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric
     * characters such as "012ABC". The reason why we are not using simply a number counter is that
     * the number string gets longer over time, and it can also overflow, where as the nextId
     * will grow much slower, it is a string, and it will never overflow.
     *
     * @returns {string} an unique alpha-numeric string
     */
    public nextUid(): string {
        let index = this.nextUniqueId.length;
        let digit: number;

        while (index) {
            index--;
            digit = this.nextUniqueId[index].charCodeAt(0);

            if (digit === 57 /*"9"*/) {
                this.nextUniqueId[index] = "A";
                return this.nextUniqueId.join("");
            }
            if (digit === 90 /*"Z"*/) {
                this.nextUniqueId[index] = "0";
            } else {
                this.nextUniqueId[index] = String.fromCharCode(digit + 1);
                return this.nextUniqueId.join("");
            }
        }

        this.nextUniqueId.unshift("0");
        return this.nextUniqueId.join("");
    }

    /**
     * Returns the approximate memory footprint (byte count) of the object specified
     * @param {any} object
     * @returns {number} byte count
     */
    public sizeof = (object: any): number => {
        const visitedObjects: any[] = [];
        return this.calculateSizeof(object, visitedObjects);
    };

    private calculateSizeof = (object: any, visitedObjects: any[]): number => {
        if (_.isString(object)) {
            return object.length * ByteCount.String;
        } else if (_.isBoolean(object)) {
            return ByteCount.Boolean;
        } else if (_.isNumber(object)) {
            return ByteCount.Number;
        } else if (_.isObject(object)) {
            if (_.isBuffer(object)) {
                return object.length;
            } else {
                visitedObjects.push(object);
                let bytes = 0;

                _.forOwn(object, (value: any, key: any) => {
                    bytes += this.calculateSizeof(key, visitedObjects);
                    // short-circuit circular refs
                    if (!_.includes(visitedObjects, value)) {
                        bytes += this.calculateSizeof(value, visitedObjects);
                    }
                });

                return bytes;
            }
        } else {
            return 0;
        }
    };

    public dateEquals(date1?: Date, date2?: Date): boolean {
        if (_.isUndefined(date1) && _.isUndefined(date2)) {
            return true;
        }

        if (_.isNull(date1) && _.isNull(date2)) {
            return true;
        }

        const isDate1 = _.isDate(date1);
        const isDate2 = _.isDate(date2);

        if (isDate1 && !isDate2) {
            return false;
        }

        if (!isDate1 && isDate2) {
            return false;
        }

        if (!isDate1 && !isDate2) {
            return false;
        }

        return date1.valueOf() === date2.valueOf();
    };
};

enum ByteCount {
    String = 2,
    Boolean = 4,
    Number = 8
};
