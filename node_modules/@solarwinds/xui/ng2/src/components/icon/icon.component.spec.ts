import {IconComponent} from "./icon.component";
import {IconData, IconService} from "../../services/icon.service";

describe("components >", () => {
    describe("icon >", () => {
        let subject: IconComponent;

        const PRINTER = "printer";
        const BRUSH_TYPE = "stroked";
        const CSS_AMENDMENTS = "xui-spinner";
        const ICON_COLOR = "green";
        const ICON_HOVER_COLOR = "orange";
        const CSS_CLASS = "custom-class";
        const COUNTER = "5";
        const ICON_CODE = "<svg></svg>";

        let ICONS: IconData[] = [{
            "svgFile": "printer.svg",
            "name": PRINTER,
            "cat_namespace": null,
            "category": "object",
            "brushType": BRUSH_TYPE,
            "cssAmendments": CSS_AMENDMENTS,
            "code": ICON_CODE
        }];

        IconService.ICONS = ICONS;

        beforeEach(() => {
            subject = new IconComponent(new IconService(), null);
        });

        it("should find icon data", () => {
            let icon = "printer";
            subject.icon = icon;

            expect(subject.icon).toBe(icon);

            let iconClass = subject.iconClass;
            expect(iconClass).toContain("xui-icon");
            expect(iconClass).toContain(BRUSH_TYPE);
            expect(iconClass).toContain(CSS_AMENDMENTS);
            expect(iconClass).not.toContain("xui-icon-not-found");
        });

        it("should not find icon data", () => {
            let icon = "unknown";
            subject.icon = icon;

            expect(subject.icon).toBe(icon);

            let iconClass = subject.iconClass;
            expect(iconClass).toContain("xui-icon");
            expect(iconClass).not.toContain(BRUSH_TYPE);
            expect(iconClass).not.toContain(CSS_AMENDMENTS);
            expect(iconClass).toContain("xui-icon-not-found");

            expect(subject.iconCode).toBeUndefined();
        });

        it("should have iconColor, iconHoverColor, cssClass, fillContainer classes", () => {
            subject.iconColor = ICON_COLOR;
            subject.iconHoverColor = ICON_HOVER_COLOR;
            subject.cssClass = CSS_CLASS;

            expect(subject.iconClass).toContain(`${ICON_COLOR}-icon`);
            expect(subject.iconClass).toContain(`${ICON_HOVER_COLOR}-hover-icon`);
            expect(subject.iconClass).toContain(CSS_CLASS);
        });

        it("should not have iconColor, iconHoverColor, cssClass, fillContainer classes", () => {
            expect(subject.iconClass).not.toContain(`${ICON_COLOR}-icon`);
            expect(subject.iconClass).not.toContain(`${ICON_HOVER_COLOR}-hover-icon`);
            expect(subject.iconClass).not.toContain(CSS_CLASS);
        });

        it("should have valid iconSize class", () => {
            for (let key in IconComponent.SIZE_MAP) {
                if (IconComponent.SIZE_MAP.hasOwnProperty(key)) {
                    subject.iconSize = key;
                    expect(subject.iconClass).toContain(IconComponent.SIZE_MAP[key]);
                }
            }
        });

        it("should not have iconSize class", () => {
            subject.iconSize = "unknown";
            expect(subject.iconClass).not.toContain("xui-icon-size");
        });

        it("should have valid counter", () => {
            subject.counter = COUNTER;
            expect(subject.counter).toBe(COUNTER);
        });

        it("should have undefined counter", () => {
            subject.counter = "a";
            expect(subject.counter).toBeUndefined();

            subject.counter = undefined;
            expect(subject.counter).toBeUndefined();
        });
    });
});
