import {
    Component,
    ElementRef,
    EventEmitter,
    Input,
    OnDestroy,
    OnInit,
    Output,
    Renderer2,
    ViewChild,
    ViewContainerRef
} from "@angular/core";
import {
    style,
    animate,
    AnimationBuilder,
    AnimationFactory,
    AnimationPlayer
} from "@angular/animations";

/**
 * <example-url>./../../../demo/index.html#/panel</example-url>
 */
@Component({
    selector: "xui-panel",
    template: require<string>("./panel.component.html")
})
export class PanelComponent implements OnInit, OnDestroy {
    public static DEFAULT_PANE_WIDTH = 250;
    public static ANIMATION_TIME = 300;
    public static MIN_WIDTH = 60;

    private _paneWidth: number = PanelComponent.DEFAULT_PANE_WIDTH;
    @Input() panelLayout: string;
    @Input() isCollapsible: boolean = false;
    @Input() heading: string;
    @Input() headerIcon: string;
    @Input() headerIconCounter: number;
    @Input() isCollapsed: boolean = false;
    @Output() collapseChanged: EventEmitter<boolean> = new EventEmitter<boolean>();

    @ViewChild("leftPaneContainer", {read: ViewContainerRef}) private leftPaneContainer: ViewContainerRef;

    private _expandAnimationFactory: AnimationFactory;
    private _collapseAnimationFactory: AnimationFactory;
    private lastAnimationPlayer: AnimationPlayer;

    constructor(private renderer: Renderer2,
                private builder: AnimationBuilder) {}

    ngOnInit(): void {
        this.updateLeftPaneContainerWidthWithoutAnimation();
    }

    private updateLeftPaneContainerWidthWithoutAnimation(): void {
        // Manually update width of left pane container only if it is expanded.
        if (!this.isCollapsible || !this.isCollapsed) {
            this.destroyLastAnimationPlayer();
            this.renderer.setStyle(this.getLeftPaneContainerElement(), "width", `${this._paneWidth}px`);
        }
    }

    private getLeftPaneContainerElement(): ElementRef {
        return this.leftPaneContainer.element.nativeElement;
    }

    toggleCollapsed(): void {
        if (!this.isCollapsible) {
            return;
        }
        let animationFactory = this.isCollapsed ? this.expandAnimationFactory : this.collapseAnimationFactory;
        let animationPlayer = animationFactory.create(this.getLeftPaneContainerElement());
        animationPlayer.onDone(() => {
            this.collapseChanged.emit(this.isCollapsed);
        });
        animationPlayer.play();
        this.destroyLastAnimationPlayer();
        this.lastAnimationPlayer = animationPlayer;
        this.isCollapsed = !this.isCollapsed;
    }

    private get expandAnimationFactory(): AnimationFactory {
        if (!this._expandAnimationFactory) {
            this._expandAnimationFactory = this.buildWidthAnimationFactory(PanelComponent.MIN_WIDTH, this._paneWidth);
        }
        return this._expandAnimationFactory;
    }

    private get collapseAnimationFactory(): AnimationFactory {
        if (!this._collapseAnimationFactory) {
            this._collapseAnimationFactory = this.buildWidthAnimationFactory(this._paneWidth, PanelComponent.MIN_WIDTH);
        }
        return this._collapseAnimationFactory;
    }

    private buildWidthAnimationFactory(startWidth: number, endWidth: number): AnimationFactory {
        return this.builder.build([
            style({
                width: startWidth
            }),
            animate(`${PanelComponent.ANIMATION_TIME}ms ease-in-out`, style({
                width: endWidth
            }))
        ]);
    }

    private destroyLastAnimationPlayer(): void {
        if (this.lastAnimationPlayer) {
            this.lastAnimationPlayer.destroy();
            delete this.lastAnimationPlayer;
        }
    }

    @Input()
    get paneWidth(): number {
        return this._paneWidth;
    }

    set paneWidth(value: number) {
        if (isNaN(value)) {
            this._paneWidth = PanelComponent.DEFAULT_PANE_WIDTH;
        } else {
            this._paneWidth = value;
        }
        this.destroyAnimationFactories();
        this.updateLeftPaneContainerWidthWithoutAnimation();
    }

    private destroyAnimationFactories(): void {
        delete this._expandAnimationFactory;
        delete this._collapseAnimationFactory;
    }

    ngOnDestroy(): void {
        this.destroyLastAnimationPlayer();
        this.destroyAnimationFactories();
    }
}
