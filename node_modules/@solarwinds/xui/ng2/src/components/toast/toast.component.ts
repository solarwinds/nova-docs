import {
    Component,
    OnDestroy,
    HostBinding,
    HostListener,
    ApplicationRef
} from "@angular/core";
import { SafeHtml } from "@angular/platform-browser";
import { Subscription } from "rxjs/Subscription";
import { ToastService } from "../../services/toast.service";
import { IToastConfig } from "./toast-config";
import { ToastPackage } from "./toast-package";

/**
 * /**
 * __Name : __
 * Toast Component
 *
 * __Usage :__
 * Used to show toast, handle animation and events. Handles progress bar animation.
 * This component is created dynamically in ToastContainerService
*/
@Component({
    selector: "[toast-component]",
    template: require<string>("./toast.component.html")
})
export class ToastComponent implements OnDestroy {
    public body?: string | SafeHtml | null;
    public title?: string;
    public options: IToastConfig;
    /** width of progress bar */
    public width = -1;
    /** a combination of toast type and options.toastClass */
    @HostBinding("class") toastClasses = "";
    @HostBinding("class.toast-fade-out") fadeOut: boolean = true;
    @HostBinding("style.display") display: string = "none";
    /** controls animation */
    private state = "inactive";
    private timeout: any;
    private intervalId: any;
    private hideTime: number;
    private subscriptions: Array<Subscription> = [];
    private animationFadeOutLength: number = 300;

    constructor(private toastService: ToastService,
                private toastPackage: ToastPackage,
    ) {
        this.body = toastPackage.body;
        this.title = toastPackage.title;
        this.options = toastPackage.config;
        this.toastClasses = `${toastPackage.toastType} ${toastPackage.config.toastClass} toast-animation`;

        const activateSubscription = this.toastPackage.toastRef.afterActivate()
            .subscribe(() => {
                this.display = "block";
                setTimeout(() => this.activateToast(), 100); //Needs to have display: none & opacity animation working
            });
        const closeSubscription = this.toastPackage.toastRef.manualClosed().subscribe(() => {
            this.remove();
        });
        this.subscriptions.push(activateSubscription, closeSubscription);
    }

    /**
     * triggers fade in animation and sets timeout till the toast will be dismissed
     */
    public activateToast() {
        this.state = "active";
        this.fadeOut = false;
        if (this.options.timeOut) {
            this.timeout = setTimeout(() => {
                this.remove();
            }, this.options.timeOut);
            this.hideTime = new Date().getTime() + this.options.timeOut;
            if (this.options.progressBar) {
                this.intervalId = this.repeatProgressBarChange();
            }
        }
    }

    /**
     * tells toastrService to remove this toast after animation time
     */
    public remove() {
        if (this.state === "removed") {
            return;
        }
        clearTimeout(this.timeout);
        this.state = "removed";
        this.fadeOut = true;
        this.timeout = setTimeout(() => this.toastService
            .remove(this.toastPackage.toastId), this.animationFadeOutLength);
    }

    /**
     * handles click on toast itself
     */
    @HostListener("click")
    public clickToast() {
        if (this.state === "removed") {
            return;
        }
        this.toastPackage.triggerClick();
        if (this.options.clickToDismiss) {
            this.remove();
        }
    }

    /**
     * disables progressBar and prevents toast from closing
     */
    @HostListener("mouseenter")
    public stickAround() {
        if (this.state === "removed") {
            return;
        }
        clearTimeout(this.timeout);
        this.options.timeOut = 0;
        this.hideTime = 0;

        // disable progressBar
        cancelAnimationFrame(this.intervalId);
        this.width = 0;
    }

    /**
     *  using extendedTimeOut value to delay toast's closure
     */
    @HostListener("mouseleave")
    public delayedHideToast() {
        cancelAnimationFrame(this.intervalId);
        if (this.options.extendedTimeOut === 0 || this.state === "removed") {
            return;
        }
        this.timeout = setTimeout(() => this.remove(), this.options.extendedTimeOut);
        this.options.timeOut = this.options.extendedTimeOut;
        this.hideTime = new Date().getTime() + (this.options.timeOut || 0);
        this.width = 100;
        if (this.options.progressBar) {
            this.intervalId = this.repeatProgressBarChange();
        }
    }

    private repeatProgressBarChange (): number {
        return requestAnimationFrame(this.updateProgress.bind(this));
    }

    /**
     * updates progress bar width
     */
    private updateProgress() {
        if (this.width === 0 || !this.options.timeOut) {
            return;
        }
        const now = new Date().getTime();
        const remaining = this.hideTime - now;
        this.width = (remaining / this.options.timeOut) * 100;
        if (this.options.progressAnimation === "increasing") {
            this.width = 100 - this.width;
        }
        if (this.width <= 0) {
            this.width = 0;
        }
        if (this.width >= 100) {
            this.width = 100;
        }
        requestAnimationFrame(this.updateProgress.bind(this));
    }

    ngOnDestroy() {
        this.subscriptions.forEach(subscription => subscription.unsubscribe());
        cancelAnimationFrame(this.intervalId);
        clearTimeout(this.timeout);
    }
}
