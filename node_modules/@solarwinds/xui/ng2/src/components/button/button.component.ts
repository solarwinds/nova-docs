import {
    ChangeDetectionStrategy,
    Component,
    ElementRef,
    HostBinding,
    Input,
    OnDestroy,
    OnInit,
    Renderer2,
    ViewChild,
    ViewContainerRef
} from "@angular/core";
import { Observable } from "rxjs/Rx";
import { Subject } from "rxjs/Subject";
import "rxjs/observable/timer";
import { validateConfig } from "@angular/router/src/config";

import { ButtonConstants } from "../../constants/button.constants";
/**
 * <example-url>./../../../demo/index.html#/button</example-url>
 */
@Component({
    selector: "[xui-button]",
    template: require<string>("./button.component.html"),
    host: {"class": "xui-button btn"},
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class ButtonComponent implements OnInit, OnDestroy {
    
    @Input() public displayStyle: string;
    @Input() public icon: string;
    @Input() public get iconColor(): string {
        return (!this._iconColor && this.displayStyle === "primary") ? "white" : this._iconColor;
    }
    public set iconColor (value) {
        this._iconColor = value;
    }
    @Input() public iconRight: boolean;
    @Input() public isBusy: boolean;
    @Input() public isEmpty: boolean;
    @Input() public isRepeat: boolean;
    @Input() public size: string;

    @HostBinding("class.btn-lg") public get sizeClassLarge() { return this.size === "large"; }
    @HostBinding("class.btn-sm") public get sizeClassSmall() { return this.size === "small"; }
    @HostBinding("class.btn-xs") public get sizeClassXsmall() { return this.size === "xsmall"; }

    @HostBinding("class.icon-right") public get iconRightClass() { return this.iconRight; }
    @HostBinding("class.icon-left") public get iconleftClass() { return !this.iconRight; }

    @HostBinding("class.is-busy") public get isBusyClass() { return this.isBusy; }
    @HostBinding("class.is-empty") public get isEmptyClass() { return this.isEmpty; }

    @HostBinding("class.btn-primary") public get dispStylePrimClass() { return this.displayStyle === "primary"; }
    @HostBinding("class.btn-secondary") public get dispStyleSecClass() { return this.displayStyle === "secondary"; }
    @HostBinding("class.xui-btn-tertiary") public get dispStyleTertClass() { return this.displayStyle === "tertiary"; }
    @HostBinding("class.xui-btn-link") public get displayStyleLinkClass() { return this.displayStyle === "link"; }
    @HostBinding("class.btn-default") public get displayStyleDefaultClass() { 
        return !(this.dispStylePrimClass || this.dispStyleSecClass || 
                 this.dispStyleTertClass || this.displayStyleLinkClass);
    }

    @ViewChild("contentContainer", { read: ViewContainerRef }) private contentContainer: ViewContainerRef;
    
    private ngUnsubscribe: Subject<void> = new Subject<void>();
    private _iconColor: string;

    constructor(private el: ElementRef,
                private renderer: Renderer2) { }

    public ngOnInit(): void {
        this.initializeIsEmpty();
        this.setupRepeatEvent();
    }

    public ngOnDestroy(): void {
        this.ngUnsubscribe.next();
        this.ngUnsubscribe.complete();
    }

    public get iconSize(): string {
        return this.size ? ButtonConstants.iconSizeMap[this.size.toLowerCase()] : "";
    }

    public get rippleContainerStyle() {
        let host = this.getHostElement();
        const d = Math.max(host.offsetWidth, host.offsetHeight);
        const x = (host.offsetWidth - d) / 2;
        const y = (host.offsetHeight - d) / 2;

        return {
            left: `${x}px`,
            top: `${y}px`,
            width: `${d}px`,
            height: `${d}px`
        };
    }

    private initializeIsEmpty() {
        let innerHTML = this.contentContainer.element.nativeElement.innerHTML;
        this.isEmpty = !innerHTML || !innerHTML.trim();
    }

    private setupRepeatEvent() {
        let mouseUp$ = Observable.fromEvent(this.getHostElement(), "mouseup").takeUntil(this.ngUnsubscribe);
        let mouseLeave$ = Observable.fromEvent(this.getHostElement(), "mouseleave").takeUntil(this.ngUnsubscribe);
        Observable.fromEvent(this.getHostElement(), "mousedown")
            .takeUntil(this.ngUnsubscribe)
            .filter(() => this.isRepeat)
            .subscribe(() => {
                Observable.timer(ButtonConstants.repeatDelay, ButtonConstants.repeatInterval)
                    .takeUntil(Observable.merge(mouseUp$, mouseLeave$, this.ngUnsubscribe))
                    .subscribe(() => {
                        this.getHostElement().click();
                    });
            });
    }

    private getHostElement() {
        return this.el.nativeElement;
    }
}
