import {
    Component,
    EventEmitter,
    Input,
    OnChanges,
    Output
} from "@angular/core";

import {
    NgModel
} from "@angular/forms";

import {
    IAugmentedObjValidator,
    IAugmentedObjValidatorAsync,
    IAugmentedValidationErrors
} from "../../directives";

interface IValidationState {
    invalid: boolean;
    dirty: boolean;
    touched: boolean;
    errors: IAugmentedValidationErrors[];
    pending: boolean;
}

/**
 * <example-url>./../../../demo/index.html#/textbox</example-url>
 */

/**
 * <br/>
 * __Name :__
 * XUI Textbox component.
 *
 */
@Component({
    selector: "xui-textbox",
    template: require<string>("./textbox.component.html")
})
export class TextboxComponent implements OnChanges {
    /**
     * Value used as a label for the text box.
     */
    @Input() public caption: string;
    /**
     * Use to set a custom width for the input field.
     */
    @Input() public customBoxWidth: string;
    /**
     * Event fired when input text is changed.
     */
    @Output() public textChange = new EventEmitter<string | number>();
    /**
     * The option to disable the text box.
     */
    @Input() public disabled = false;
    /**
     * Help content provided below the text box.
     */
    @Input() public hint = "";
    /**
     * Name of the element.
     */
    @Input() public name: string;
    /**
     * Value used as a placeholder for the text box.
     */
    @Input() public placeholder = "";
    /**
     * The option to make the text box read only.
     */
    @Input() public readonly = false;
    /**
     * The option to set/change conditional "required" validation.
     * This is quick way to set a filed as required instead of passing config object into validator.
     * Use it to highlight error if field is set to empty and you are not interested in specific message.
     */
    @Input() public required = false;
    /**
     * Makes textbox multiline (textarea), specifies rows count
     */
    @Input() public rows = 1;
    /**
     * Use to set suffix (in conjunction with custom width).
     */
    @Input() public suffix = "";

    /**
     * Use to set type of input (number, password etc.).
     */
    @Input() public type = "text";

    public validationState = {} as IValidationState;

    /**
     * An object that contains validator function
     * (native or custom with the same AsyncValidatorFn interface),
     * specific name of error if validation fails and message that will be displayed on error.
     */
    @Input() public validatorAsync: IAugmentedObjValidatorAsync;

    /**
     * An object or an array of objects. Each object contains validator function
     * (native or custom with the same interface, see Validators),
     * specific name of error if validation fails and message that will be displayed on error.
     */
    @Input() public validator: IAugmentedObjValidator | IAugmentedObjValidator[];
    public validatorSet = [] as IAugmentedObjValidator[];

    /**
     * Input initial value
     */
    @Input() public value: string | number;

    private firstIteration = true;

    // i18n xui_textbox_optional
    private optionalText = "Optional";

    public addNumber = (num: number): void => {
        let newValue = (parseInt(this.value as string, 10) || 0) + num;
        this.value = newValue;
        this.validationState.touched = true;
        this.validationState.dirty = true;
    };

    public getAllValidatorNames(): string[] {
        const validatorNames =  this.validatorSet
            .map((item) => {
                return item.name;
            });

        if (this.validatorAsync) {
            validatorNames.push(this.validatorAsync.name);
        }

        return validatorNames;
    }

    public handleChangedValue(unused: any, model: NgModel) {
        // Status is set to certain - 'valid'/'invalid' - later in case of async validation.
        // When event is fired it is set to uncertain - 'Pending'
        // We need to subscribe here to trigger it. Subscribe should happen once - on first call
        if (this.firstIteration) {
            this.firstIteration = false;

            this.updateValidationState(model);

            model.statusChanges.subscribe((unusedStatus: string) => {
                this.updateValidationState(model);
            });
        }
        
        if (!model.invalid) {
            this.textChange.emit(this.value);
        }
    }

    public hasSuffix(): boolean {
        return !!this.suffix;
    }

    public isInErrorState(): boolean {
        const isDirty = ({dirty, touched}: IValidationState): boolean => {
            return dirty || touched;
        };

        return this.isAvailableToChange() &&
            this.validationState.invalid &&
            isDirty(this.validationState);
    }

    public isUnavailableToChange(): boolean {
        return !this.isAvailableToChange();
    }

    public ngOnChanges() {
        this.updateValidatorSet();
    }

    public showFeedback(): boolean {
        if (this.isUnavailableToChange()) {
            return false;
        }

        return this.isInErrorState();
    }

    public stateText(): string {
        if (this.readonly || this.disabled) {
            return "";
        }

        if (!this.value || this.value === "") {
            if (this.required) {
                return "";
            }
            return this.optionalText;
        }
        return "";
    }

    private isAvailableToChange(): boolean {
        return !this.readonly && !this.disabled;
    }

    private updateValidationState(model: NgModel) {
        this.validationState.invalid = model.invalid;
        this.validationState.pending = model.pending;
        this.validationState.dirty = model.dirty;
        this.validationState.touched = model.touched;
        this.validationState.errors = model.errors as IAugmentedValidationErrors[];
    }

    private updateValidatorSet() {
        if (Array.isArray(this.validator)) {
            this.validatorSet = this.validator;
        } else if (this.validator) {
            this.validatorSet = [this.validator];
        }
    }
}
