import { TextboxComponent } from "./textbox.component";
import { IAugmentedObjValidator, IAugmentedObjValidatorAsync } from "../../directives";

describe("components >", () => {

    describe("textbox >", () => {

        let subject: TextboxComponent;

        beforeEach(() => {
            subject = new TextboxComponent();
        });

        describe("stateText >", () => {
            it("should equal \"Optional\"", () => {
                subject.value = null;
                subject.required = false;

                expect(subject.stateText()).toEqual("Optional");
            });

            it("should equal empty string if \"readonly\" equals \"true\"", () => {
                subject.readonly = true;

                expect(subject.stateText()).toEqual("");
            });

            it("should equal empty string if \"disabled\" equals \"true\"", () => {
                subject.disabled = true;

                expect(subject.stateText()).toEqual("");
            });

            it("should equal empty string if \"required\" equals \"true\"", () => {
                subject.required = true;

                expect(subject.stateText()).toEqual("");
            });

            it("should equal empty string if \"value\" is not empty", () => {
                subject.value = "foo";

                expect(subject.stateText()).toEqual("");
            });
        });

        describe("isInErrorState >", () => {
            beforeEach(() => {
                subject.validationState = {
                    invalid: false,
                    dirty: false,
                    touched: false,
                    errors: null,
                    pending: false
                };
            });

            it("should confirm if invalid value was set by user and is available for changes", () => {
                subject.validationState.invalid = true;
                subject.validationState.dirty = true;

                expect(subject.isInErrorState()).toEqual(true);
            });

            it("should confirm if invalid value was set by user on touch device and is available for changes", () => {
                subject.validationState.invalid = true;
                subject.validationState.touched = true;

                expect(subject.isInErrorState()).toEqual(true);
            });

            it("should reject if value is valid", () => {
                subject.validationState.invalid = false;

                expect(subject.isInErrorState()).toEqual(false);
            });

            describe("on invalid value was set by user",  () => {
                beforeEach(() => {
                    subject.validationState.invalid = true;
                    subject.validationState.dirty = true;
                });

                it("should reject if textbox is disabled", () => {
                    subject.disabled = true;

                    expect(subject.isInErrorState()).toEqual(false);
                });

                it("should reject if textbox is readonly", () => {
                    subject.readonly = true;

                    expect(subject.isInErrorState()).toEqual(false);
                });
            });
        });

        describe("addNumber >", () => {
            beforeEach(() => {
                subject.value = 101;
                subject.validationState.touched = false;
                subject.validationState.dirty = false;
            });

            it("should increase value by given number", () => {
                subject.addNumber(12);

                expect(subject.value).toBe(113);
            });

            it("should convert number-in-string value to number and increase by given number", () => {
                subject.value = "101";
                subject.addNumber(-12);

                expect(subject.value).toBe(89);
            });

            it("should mark state of item as 'visited' (touched)", () => {
                subject.addNumber(0);

                expect(subject.validationState.touched).toEqual(true);
            });

            it("should mark state of item as 'visited' (dirty)", () => {
                subject.addNumber(0);

                expect(subject.validationState.dirty).toEqual(true);
            });
        });

        describe("showFeedback >", () => {
            it("should confirm if item is available to change and is in error state", () => {
                spyOn(subject, "isAvailableToChange").and.returnValue(true);
                spyOn(subject, "isInErrorState").and.returnValue(true);

                expect(subject.showFeedback()).toEqual(true);
            });

            it("should reject if item is available to change and is NOT in error state", () => {
                spyOn(subject, "isAvailableToChange").and.returnValue(true);
                spyOn(subject, "isInErrorState").and.returnValue(false);

                expect(subject.showFeedback()).toEqual(false);
            });

            it("should reject if it item is unavailable to change", () => {
                spyOn(subject, "isAvailableToChange").and.returnValue(false);

                expect(subject.showFeedback()).toEqual(false);
            });
        });

        describe("getAllValidatorNames >", () => {
            beforeEach(() => {
                subject.validatorSet = [
                    {name: "validatorName1"},
                    {name: "validatorName2"},
                    {name: "validatorName3"}
                ] as IAugmentedObjValidator[];

                subject.validatorAsync = {
                    name: "validatorAsyncName"
                } as IAugmentedObjValidatorAsync;
            });

            it("should contain names of all passed validators", () => {
                const validatorNames = subject.getAllValidatorNames();

                expect(validatorNames.length).toBe(4);
            });

            it("should add sync validators names into collection", () => {
                const validatorNames = subject.getAllValidatorNames();

                expect(validatorNames).toContain("validatorName1");
                expect(validatorNames).toContain("validatorName2");
                expect(validatorNames).toContain("validatorName3");
            });

            it("should add async validator name into collection", () => {
                const validatorNames = subject.getAllValidatorNames();

                expect(validatorNames).toContain("validatorAsyncName");
            });
        });
    });
});
