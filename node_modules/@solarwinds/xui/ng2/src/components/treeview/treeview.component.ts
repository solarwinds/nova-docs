import * as _ from "lodash";
import {
    Component,
    Input,
    OnInit,
    ElementRef
} from "@angular/core";
import { TreeviewItemComponent } from "./treeview-item.component";
import { KEY_CODE } from "../../constants";
import {
    ITreeviewOptions,
    IVirtualNode,
    TreeviewService,
    ITreeviewContext,
    ITreeviewState
} from "./treeview.service";
import { Subscription } from "rxjs/Subscription";

/**
 * <example-url>./../../../demo/index.html#/treeview</example-url>
 */
@Component({
    selector: "xui-treeview",
    template: require<string>("./treeview.component.html"),
    providers: [TreeviewService]
})
export class TreeviewComponent implements OnInit {
    //TODO: Handle watching over input data in component (creating nodes from changed model)
    @Input() public itemWithChildrenTemplate: ElementRef;
    @Input() public itemWithoutChildrenTemplate: ElementRef;
    @Input() public model: any;
    @Input() public options: ITreeviewOptions;
    @Input() public initialState: ITreeviewState[];
    public context: ITreeviewContext;
    public nodeIdentifier: string = "id";
    public rootNode: IVirtualNode;

    private treeviewComponentSubscriptions: Array<Subscription> = [];

    constructor(private treeviewService: TreeviewService) {}

    public ngOnInit(): void {
        let defaultOptions = this.treeviewService.getDefaultOptions();
        this.options = _.merge({}, defaultOptions, this.options);
        this.rootNode = this.treeviewService.createRootNode(this.model, this.options);
        this.initializeContext();
    }

    public onKeydown($event: KeyboardEvent): void {
        this.onKeyDownCommon($event);
        if (_.isNil(this.context.focusedNode)) {
            if (!_.isNil(this.options.selectionMode) && _.includes([
                KEY_CODE.UP_ARROW,
                KEY_CODE.DOWN_ARROW,
                KEY_CODE.LEFT_ARROW,
                KEY_CODE.RIGHT_ARROW,
            ], $event.keyCode)) {
                this.focusNode(this.context.rootNode.$children[0]);
            }
        } else {
            this.onKeyDown4FocusedNode($event);
        }
    }

    public onMouseClickBubbled($event: TreeviewItemMouseClickEvent) {
        if (!_.isNil(this.context.focusedNode)) {
            this.context.focusedNode.focused = false;
        }
        this.context.focusedNode = $event.sourceNode;
        this.context.focusedNode.focused = true;
    }

    private onKeyDownCommon($event: KeyboardEvent): void {
        switch ($event.keyCode) {
            case KEY_CODE.ASTERISK:
            case KEY_CODE.PLUS:
                if (($event.keyCode === KEY_CODE.ASTERISK && _.isNil(this.context.focusedNode)) ||
                    ($event.keyCode === KEY_CODE.PLUS && $event.shiftKey)) {
                    this.expandAll(this.context.focusedNode);
                }
                break;
            case KEY_CODE.MINUS:
                if ($event.shiftKey) {
                    this.collapseAll(this.context.focusedNode);
                }
                break;
        }
    }

    private onKeyDown4FocusedNode($event: KeyboardEvent): void {
        const focusedNode = this.context.focusedNode;
        switch ($event.keyCode) {
            case KEY_CODE.LEFT_ARROW: {
                if (focusedNode.$hasChildren && !focusedNode.collapsed) {
                    this.collapse(focusedNode);
                } else if (focusedNode.$parent !== this.context.rootNode) {
                    this.focusNode(focusedNode.$parent);
                }
                break;
            };
            case KEY_CODE.RIGHT_ARROW: {
                if (focusedNode.$hasChildren) {
                    if (focusedNode.collapsed) {
                        this.expand(focusedNode);
                    } else {
                        this.focusNode(focusedNode.$children[0]);
                    }
                }
                break;
            };
            case KEY_CODE.PLUS: {
                if (focusedNode.$hasChildren && focusedNode.collapsed) {
                    this.expand(focusedNode);
                }
                break;
            };
            case KEY_CODE.UP_ARROW: {
                this.focusNode(this.treeviewService.previousVisibleNode(focusedNode));
                $event.preventDefault();
                break;
            };
            case KEY_CODE.DOWN_ARROW: {
                this.focusNode(this.treeviewService.nextVisibleNode(focusedNode));
                $event.preventDefault();
                break;
            };
            case KEY_CODE.SPACE: {
                // focusedNode.checked = !focusedNode.checked;
                //TODO: implement
                //ctrl.applySelection($event, context.focusedNode);
                $event.preventDefault();
                break;
            };
            case KEY_CODE.ASTERISK: {
                this.expandAll(this.context.focusedNode);
                break;
            };
            case KEY_CODE.MINUS: {
                this.collapseAll(this.context.focusedNode);
                break;
            };
        }
    }

    private collapseAll(vnode: IVirtualNode): void {
        this.traverse(vnode || this.context.rootNode, (n: IVirtualNode) => {
            if (!n.collapsed) {
                this.collapse(n);
            }
        });
    }

    private collapse(vnode:IVirtualNode): void {
        if (!vnode.collapsed) {
            vnode.collapsed = true;
            //TODO: implement
            //this.options.onCollapse($event, vnode, this.context);
        }
    }

    private expand(vnode: IVirtualNode): void {
        if (vnode.$hasChildren && vnode.collapsed) {
            this.treeviewComponentSubscriptions.push(
                this.treeviewService.getChildrenNodes(vnode, this.options)
                    .subscribe(childrenNodes => {
                        vnode.$children = childrenNodes;
                    },
                    error => console.error(error),
                    () => vnode.loading = false));
            vnode.collapsed = false;
            //TODO: implement
            //this.options.onExpand($event, vnode, this.context);
        }
    }

    private expandAll(vnode: IVirtualNode): void {
        this.traverse(vnode || this.context.rootNode, (n: IVirtualNode) => {
            if (n.collapsed) {
                this.expand(n);
            }
        });
    };

    private focusNode (node: IVirtualNode): void {
        if (!_.isNil(this.context.focusedNode)) {
            this.context.focusedNode.focused = false;
            node.focused = true;
            this.context.focusedNode = node;
        }
    }

    //TODO: implement
    // public expandAll($event:JQueryEventObject, vnode:IVirtualNode) {
    // public collapseAll($event:JQueryEventObject) {

    private initializeContext() {
        this.context = <ITreeviewContext>{};
        this.context.selectedNodes = [];
        this.traverse(this.rootNode, (node: IVirtualNode) => {
            node.collapsed = true;
            node.checked = "unchecked";
        });
        this.initialState.forEach((item) => {
            let node: IVirtualNode = this.treeviewService.findNodeByState(this.nodeIdentifier, item, this.context);
            if (!_.isNil(node)) {
                if (item.focused) {
                    this.context.focusedNode = node;
                    node.focused = true;
                }
                if (!_.isUndefined(item.expanded)) {
                    node.collapsed = !item.expanded;
                }
                if (!_.isUndefined(item.checked)) {
                    node.checked = item.checked;
                }
            }
        });
    }

    private traverse(vnode: IVirtualNode, callback: (vn: IVirtualNode) => void) {
        if (vnode !== this.context.rootNode) {
            callback(vnode);
        }

        if (vnode.$hasChildren) {
            _.forEach(vnode.$children, (e: IVirtualNode) => {
                this.traverse(e, callback);
            });
        }
    }

    ngOnDestroy() {
        this.treeviewComponentSubscriptions.forEach(subscription => subscription.unsubscribe());
    }
}

export class TreeviewItemMouseClickEvent {
    event: MouseEvent;
    sourceNode: IVirtualNode;
}

//TODO:
//move all interfaces to service
//move keyhandlers to service
