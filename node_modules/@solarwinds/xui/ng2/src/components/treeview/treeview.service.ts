import {Injectable} from "@angular/core";
import * as _ from "lodash";
import {Observable} from "rxjs/Observable";
import "rxjs/add/operator/map";

export type VirtualNodeChecked = "checked" | "unchecked" | "indeterminate";

export interface IVirtualNode {
    $model:any;
    $parent:IVirtualNode;
    $children:IVirtualNode[];
    $level:number;
    $hasChildren:boolean;
    $hasGrandChildren:boolean;
    focused?:boolean;
    collapsed:boolean;
    checked: VirtualNodeChecked;
    loading:boolean;
    /**
     * Limit on VirtualNode is a multiple of limit on ITreeviewOptions
     */
    limitMultiplier:number;
}

export interface ITreeviewOptions {
    childrenKey?: string;
    hasChildrenKey?: string;
    selectionMode?: "single" | "multi";
    limit?: number;
    onExpand?($event: any, node: IVirtualNode, context: any): void;
    onCollapse?($event: any, node: IVirtualNode, context: any): void;
    onSelect?($event: any, node: IVirtualNode, context: any): void;
    onDblClick?($event: any, node: IVirtualNode, context: any): void;
    load?(parent: IVirtualNode): Observable<any[]>;
    trackBy?: string;
    isAlwaysSelected?: boolean;
}

export interface ITreeviewContext {
    focusedNode: IVirtualNode;
    selectedNode: IVirtualNode;
    selectedNodes: IVirtualNode[];
    rootNode: IVirtualNode;
}

export interface ITreeviewState {
    id: string;
    path: string[];
    expanded?: boolean;
    checked?: VirtualNodeChecked;
    focused?: boolean;
}

export class VirtualNode implements IVirtualNode {
    $children: Array<VirtualNode>;
    $level: number;
    $hasChildren: boolean;
    $hasGrandChildren: boolean;
    collapsed: boolean = true;
    checked: VirtualNodeChecked = "unchecked";
    loading: boolean = false;
    limitMultiplier: number;
    constructor(public $model: any, public $parent: IVirtualNode) { }
}

/**
 * Service handling functionality related to XUI.Treeview component
 */
@Injectable()
export class TreeviewService {
    /**
     * Get children of node's model if there are any, otherwise throws an error
     *
     * @param node
     * @param options
     * @returns {Array<VirtualNode>}
     */
    public children(node: IVirtualNode, options: ITreeviewOptions): Array<any> {
        const children = node.$model[options.childrenKey];
        if (_.isFunction(children)) {
            return children();
        } else if (_.isArray(children)) {
            return children;
        } else {
            throw new Error("Children is neither an array nor a function.");
        }
    }

    /**
     * Turns a model into a virtual node containing all necessary meta information
     *
     * @param node
     * @param parent
     * @param options
     * @returns {VirtualNode}
     */
    public nodify(node: any, parent: IVirtualNode, options: ITreeviewOptions): IVirtualNode {
        const vnode = new VirtualNode(node, parent);
        vnode.$hasChildren = this.hasChildren(node, options);
        vnode.$level = this.nodeLevel(vnode);
        vnode.limitMultiplier = 1; // limit on vnode is a multiple
        if (vnode.$hasChildren) {
            const children = this.children(vnode, options);
            vnode.$children = this.nodifyArray(children, vnode, options);
            vnode.$hasGrandChildren = _.some(vnode.$children, { $hasChildren: true });
        }

        if (!_.isNil(parent) && options.selectionMode === "multi" && parent.checked === "checked") {
            vnode.checked = parent.checked;
        }

        return vnode;
    }

    /**
     * Turns an array-like model into virtual nodes
     *
     * @param nodes
     * @param parent
     * @param options
     * @returns {Array}
     */
    public nodifyArray(nodes: any[], parent: IVirtualNode, options: ITreeviewOptions): Array<IVirtualNode> {
        return _.map(nodes, (node) => this.nodify(node, parent, options));
    }

    /**
     * Returns next visible node for given node respecting treeview collapsed/expanded nodes
     *
     * @param current
     * @returns {any}
     */
    public nextVisibleNode(current: IVirtualNode): IVirtualNode {
        // return first child if expanded
        if (!current.collapsed && current.$children.length) {
            return current.$children[0];
        }

        let nextNode = current;
        // return next sibling if current is not the last one
        while (!_.isNil(nextNode.$parent)) {
            const siblings = nextNode.$parent.$children;
            const idx: number = siblings.indexOf(nextNode);
            const nextIdx: number = idx + 1;
            if (nextIdx < siblings.length) {
                return siblings[nextIdx];
            }
            nextNode = nextNode.$parent;
        }

        // otherwise return current node
        return current;
    }

    /**
     * Returns previous visible node for given node respecting treeview collapsed/expanded nodes
     *
     * @param current
     * @returns {IVirtualNode}
     */
    public previousVisibleNode(current: IVirtualNode): IVirtualNode {
        const siblings = current.$parent.$children; //get siblings
        const idx: number = siblings.indexOf(current); //get index of current
        if (idx === 0) { //if node is the first among siblings
            //$level === 1 - it's a level of root node
            // for the first node in first level just return the node
            return (current.$level <= 2) ? current : current.$parent;
        } else {
            // start with the previous sibling
            let previousSibling: IVirtualNode = siblings[idx - 1];
            while (!previousSibling.collapsed && previousSibling.$hasChildren) {
                // continue until a collapsed node (or without children) is found
                previousSibling = previousSibling.$children[previousSibling.$children.length - 1];
            }
            return previousSibling;
        }
    }

    /**
     * Returns default options object
     *
     * @returns {ITreeviewOptions}
     */
    public getDefaultOptions = () => <ITreeviewOptions>{
        childrenKey: "children",
        hasChildrenKey: "has_children",
        onExpand: _.noop,
        onCollapse: _.noop,
        onSelect: _.noop,
        onDblClick: _.noop,
        limit: 5, // TBD with JR
        selectionMode: "single",
        isAlwaysSelected: false
    };

    /**
     * Returns observable with node's children converted to virtual nodes. Can fetch children either from load method
     * passed within options object or from node's model
     *
     * @param {IVirtualNode} vnode
     * @param {ITreeviewOptions} options
     * @returns {Observable<Array<IVirtualNode>>}
     */
    public getChildrenNodes(vnode: IVirtualNode, options: ITreeviewOptions): Observable<Array<IVirtualNode>> {
        if (_.isFunction(options.load)) {
            vnode.loading = true;
            return options.load(vnode).map(children => this.nodifyArray(children, vnode, options));
        } else if (vnode.$hasChildren) {
            return Observable.of(this.nodifyArray(vnode.$model[options.childrenKey], vnode, options));
        }
    }

    /**
     * Creates root node of treeview from model
     *
     * @param {Array<any>} children
     * @param {ITreeviewOptions} options
     * @returns {IVirtualNode}
     */
    public createRootNode(children: Array<any>, options: ITreeviewOptions): IVirtualNode {
        const node: IVirtualNode = new VirtualNode(null, null);
        (<any>node)[options.childrenKey] = children;
        const root = this.nodify(node, null, options);

        this.getChildrenNodes(root, options)
            .subscribe(childrenNodes => root.$children = childrenNodes);
        root.collapsed = false;
        return root;
    }

    /**
     * Returns a node path to which is specified in a state
     *
     * @param {string} nodeIdentifier
     * @param {ITreeviewState} state
     * @param {ITreeviewContext} context
     * @returns {IVirtualNode}
     */
    public findNodeByState(nodeIdentifier: string, state: ITreeviewState, context: ITreeviewContext): IVirtualNode {
        let node: IVirtualNode = context.rootNode;
        let path = _.clone(state.path);

        while (!_.isEmpty(path) && !_.isNil(node)) {
            let nodeId = path.shift();
            node = _.find(node.$children, (vnode: IVirtualNode) => vnode.$model[nodeIdentifier] === nodeId);
        }

        if (!_.isNil(node) && _.isEmpty(path)) {
            return _.find(node.$children, (vnode: IVirtualNode) => vnode.$model[nodeIdentifier] === state.id);
        }

        return null;
    }

    /**
     * Get check/indeterminate status for node's checkbox
     *
     * @param {IVirtualNode} vnode
     * @returns {boolean}
     */
    public calculateGroupCheck(vnode: IVirtualNode): VirtualNodeChecked {
        if (!vnode.$hasChildren) {
            return "unchecked";
        }
        let checked: VirtualNodeChecked = "unchecked";
        vnode.$children.forEach(child => {
            if (child.checked === "indeterminate" || child.checked === "checked") {
                checked = "indeterminate";
            }
        });
        const uncheckedChild = _.some(vnode.$children, childItem => childItem.checked === "unchecked");
        if (!uncheckedChild) {
            checked = "checked";
        }
        return checked;
    }

    /**
     * Returns array of children with checked property is set to checked or unchecked
     *
     * @param {IVirtualNode} vnode
     * @param {"checked" | "unchecked"} checked
     * @returns {Array<IVirtualNode>}
     */
    public checkAllChildren(vnode: IVirtualNode, checked: "checked" | "unchecked"): Array<IVirtualNode> {
        if (vnode.$hasChildren && _.isArray(vnode.$children)) {
            return vnode.$children.map(child => {
                child.checked = checked;
                return child;
            });
        }
    }

    /**
     * Get whether node has children or not
     *
     * @param {any} node
     * @param {ITreeviewOptions} options
     * @returns {boolean}
     */
    private hasChildren(node: any, options: ITreeviewOptions): boolean {
        return _.isArray(node[options.childrenKey]) || node[options.hasChildrenKey] || false;
    }

    /**
     * Returns level of node in a treeview structure
     *
     * @param {IVirtualNode} vnode
     * @returns {number}
     */
    private nodeLevel(vnode: IVirtualNode): number {
        let level = 0;
        while (!_.isNil(vnode)) {
            vnode = vnode.$parent;
            level++;
        }
        return level;
    }
}
