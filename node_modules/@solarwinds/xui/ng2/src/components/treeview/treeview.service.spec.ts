import {
    TreeviewService, IVirtualNode, ITreeviewOptions, VirtualNode, ITreeviewContext,
    ITreeviewState
} from "./treeview.service";
import TreeviewSpecHelper from "./treeviewSpecHelper";
import { Observable } from "rxjs/Observable";
import "rxjs/add/observable/of";

describe("services >", () => {
    describe("treeview >", () => {
        let subject: TreeviewService;
        let options: ITreeviewOptions;
        let rootNode: IVirtualNode;

        beforeEach(() => {
            subject = new TreeviewService();
            options = subject.getDefaultOptions();
            rootNode = subject
                .createRootNode(TreeviewSpecHelper.generateTree(3, 3), options);
        });

        describe("when children() is called", () => {
            it("should return an array when children is a function", () => {
                const rootNodeChildren = rootNode.$children;
                rootNode.$model.children = (): any[] => {
                    return rootNode.$children;
                };
                expect(_.isArray(subject.children(rootNode, options)))
                    .toBeTruthy();
            });

            it("should return an array when children is an array", () => {
                expect(_.isArray(subject.children(rootNode, options)))
                    .toBeTruthy();
            });

            it("should throw an error when children is neither a function nor an array", () => {
                rootNode.$model.children = "Invalid value";
                expect(() => subject.children(rootNode, options))
                    .toThrowError("Children is neither an array nor a function.");
            });
        });

        describe("when nodify() is called", () => {
            it("should return an VirtualNode instance", () => {
                expect(subject.nodify(["Node1"], rootNode, options) instanceof VirtualNode)
                    .toBeTruthy();
            });

            it("should set limitMultiplyer to 1 if limit is passed into options", () => {
                options.limit = 2;
                const virtualNode = subject.nodify(["Node1"], rootNode, options);
                expect(virtualNode.limitMultiplier).toEqual(1);
            });

            it("should set $children property if node has children", () => {
                const virtualNode = subject
                    .nodify({children: TreeviewSpecHelper.generateTree(2, 2)}, rootNode, options);
                expect(virtualNode.$children).not.toBeNull();
            });
        });

        describe("when nodifyArray() is called", () => {
            it("should return IVirtualNode[] instance", () => {
                const virtualNodesArray = subject.nodifyArray(TreeviewSpecHelper.generateTree(2,2), rootNode, options);

                expect(_.isArray(virtualNodesArray)).toBeTruthy();
            });
        });

        describe("when fillOptionDefaults() is called", () => {
            it("should provide default options", () => {
                expect(subject.getDefaultOptions()).toBeDefined();
            });

            it("should set client options instead of default ones", () => {
                const clientOptions: ITreeviewOptions = {
                    childrenKey: "dataSets",
                    hasChildrenKey: "has_children",
                    onExpand: () => _.noop(),
                    onCollapse: () => _.noop(),
                    onSelect: () => _.noop(),
                    onDblClick: () =>  _.noop(),
                    load: null,
                    limit: 1,
                    selectionMode: "multi",
                    trackBy: "id",
                    isAlwaysSelected: true
                };

                expect(_.merge({}, subject.getDefaultOptions(), clientOptions))
                    .toEqual(clientOptions);
            });
        });

        describe("when getChildrenNodes() is called", () => {
            it("should return observable with result of option.load method execution", () => {
                const nodes = TreeviewSpecHelper.generateTree(2, 2);
                options.load = () => {
                    return Observable.of(nodes);
                };

                subject.getChildrenNodes(rootNode, options)
                    .subscribe(result => {
                        expect(result).toEqual(subject.nodifyArray(nodes, rootNode, options));
                    })
                    .unsubscribe();
            });

            it("should return observable with children of node",() => {
                subject.getChildrenNodes(rootNode, options)
                    .subscribe(result => {
                        expect(result).toEqual(rootNode.$children);
                    })
                    .unsubscribe();
            });
        });

        describe("when previousVisibleNode() is called", () => {
            it("return node if it is the first among siblings and level is lesser than 2", () => {
                expect(rootNode.$children[0].$level).toEqual(2);
                expect(subject.previousVisibleNode(rootNode.$children[0])).toEqual(rootNode.$children[0]);
            });

            it("return parent if it is first among siblings and level is greater than 2", () => {
                expect(rootNode.$children[0].$children[0].$level).toBeGreaterThan(2);
                expect(subject.previousVisibleNode(rootNode.$children[0].$children[0])).toEqual(rootNode.$children[0]);
            });

            it("return last child of a previous expanded sibling node", () => {
                rootNode.$children[0].collapsed = false;
                expect(subject.previousVisibleNode(rootNode.$children[1]))
                    .toEqual(_.last(rootNode.$children[0].$children));
            });
        });

        describe("when nextVisibleNode() is called", () => {
            it("return first child when focused node is expanded", () => {
                rootNode.$children[0].collapsed = false;
                expect(subject.nextVisibleNode(rootNode.$children[0])).toEqual(rootNode.$children[0].$children[0]);
            });

            it("return next sibling node if there are any", () => {
                expect(subject.nextVisibleNode(rootNode.$children[1])).toEqual(rootNode.$children[2]);
            });

            it("return current node if there are no siblings left", () => {
                expect(subject.nextVisibleNode(rootNode.$children[2])).toEqual(rootNode.$children[2]);
            });
        });

        describe("when createRootNode() is called", () => {
            it("should return a VirtualNode instance", () => {
                const node = subject.createRootNode(TreeviewSpecHelper.generateTree(2, 2), options);
                expect(node instanceof VirtualNode).toBeTruthy();
            });

            it("should bind children to created virtual node", () => {
                const model = TreeviewSpecHelper.generateTree(2, 2);
                expect(subject.createRootNode(model, options).$model.children).toEqual(model);
            });
        });

        describe("when findNodeByState() is called", () => {
                let state: ITreeviewState;
            let context: ITreeviewContext;
            beforeEach(() => {
                context = {
                    rootNode,
                    selectedNode: null,
                    selectedNodes: null,
                    focusedNode: null
                };

                state = {
                    id: "Node2",
                    path: ["Node1"],
                    expanded: false,
                    checked: "unchecked"
                };
            });

            it("should return node if path to a parent node is specified", () => {
                expect(state.path.length).toBeGreaterThan(0);
                expect(subject.findNodeByState("label", state, context))
                    .toEqual(rootNode.$children[0].$children[1]);
            });

            it("should return child of passed node if path is not specified", () => {
                state.path = [];
                expect(subject.findNodeByState("label", state, context))
                    .toEqual(rootNode.$children[1]);
            });
        });

        describe("when calculateGroupCheck is called", () => {
            it("should return false if node doesn't have any children", () => {
                rootNode.$hasChildren = false;
                expect(subject.calculateGroupCheck(rootNode)).toEqual("unchecked");
            });

            it("should return true if all children are checked", () => {
                rootNode.$children[0].$children.forEach(child => {
                    child.checked = "checked";
                });
                expect(subject.calculateGroupCheck(rootNode.$children[0])).toEqual("checked");
            });

            it("checked should be indeterminate", () => {
                rootNode.$children[0].$children[0].checked = "checked";
                expect(subject.calculateGroupCheck(rootNode.$children[0])).toEqual("indeterminate");
            });
        });

        describe("when checkAllChildren is called", () => {
            it("should set checked prop to true", () => {
                rootNode.$children = subject.checkAllChildren(rootNode, "checked");
                expect(rootNode.$children[0].checked).toEqual("checked");
            });
        });
    });
});
