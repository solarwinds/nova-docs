import {browser, by, element, ElementFinder, promise} from "@solarwinds/uzi/protractor";
import {Atom} from "@solarwinds/uzi";
import SpecHelpers from "../specHelpers";

export class ToastAtom extends Atom {
    public static CSS_CLASS = "xui-toast";
    private static toastTimeout: number = 7000;

    public static get(index: number = 0): ToastAtom {
        return new ToastAtom(element.all(by.css(`.${ToastAtom.CSS_CLASS}`)).get(index));
    }

    public static close(waitForNotDisplayed: boolean = false): promise.Promise<boolean> {
        return SpecHelpers.wrapPromise<boolean>((async () => {
            try {
                const toastAtom: ToastAtom = ToastAtom.get();
                if (await toastAtom.getElement().isDisplayed()) {
                    const closed = await toastAtom.close(waitForNotDisplayed);
                    return closed;
                }
            } catch (e) {
                console.log("static ToastAtom.close", e);
            }
            return false;
        })());
    }

    public getTitle(): promise.Promise<string> {
        return this.getElement().element(by.css(".toast-title")).getText();
    }

    public getMessage(): promise.Promise<string> {
        return this.getMessageElement().getText();
    }

    private getMessageElement(): ElementFinder {
        return this.getElement().element(by.css(".toast-message"));
    }

    private isToastType(type: string): promise.Promise<boolean> {
        return this.getElement().getAttribute("class")
            .then((className) => className.indexOf(`xui-toast--${type}`) > -1);
    }

    public close(waitForNotDisplayed: boolean = false): promise.Promise<boolean> {
        return SpecHelpers.wrapPromise<boolean>((async () => {
            try {
                await this.getElement().element(by.className("toast-close-button")).click();
                if (!waitForNotDisplayed) {
                    return true;
                }
                const closed = await this.waitUntilNotDisplayed();
                return closed;

            } catch (e) {
                console.log("ToastAtom.close", e);
            }
            return false;
        })());
    }

    public isSuccessType(): promise.Promise<boolean> {
        return this.isToastType("success");
    }

    public isWarningType(): promise.Promise<boolean> {
        return this.isToastType("warning");
    }

    public isInfoType(): promise.Promise<boolean> {
        return this.isToastType("info");
    }

    public isErrorType(): promise.Promise<boolean> {
        return this.isToastType("error");
    }

    public waitUntilDisplayed(): promise.Promise<boolean> {
        return SpecHelpers.wrapPromise<boolean>((async () => {
            try {
                return await browser.wait( () =>
                     this.getMessageElement().isDisplayed(),
                    ToastAtom.toastTimeout);
            } catch (e) {
                console.log("Toast.waitUntilDisplayed", e);
            }
            return false;
        })());
    }

    public waitUntilNotDisplayed(): promise.Promise<boolean> {
        return SpecHelpers.wrapPromise<boolean>((async () => {
            try {
                return await browser.wait( () =>
                     SpecHelpers.isNotPresentOrNotDisplayed(this),
                    ToastAtom.toastTimeout);
            } catch (e) {
                console.log("Toast.waitUntilNotDisplayed", e);
            }
            return false;
        })());
    }
}
