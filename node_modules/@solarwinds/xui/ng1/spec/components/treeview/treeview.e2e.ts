import * as protractor from "@solarwinds/uzi/protractor";
import {browser, by, element, promise} from "@solarwinds/uzi/protractor";
import Helpers from "../helpers";
import {Atom} from "@solarwinds/uzi";
import {ButtonAtom, TreeViewAtom} from "../index.atom";

describe("USERCONTROL treeview", () => {
    describe("Basic usage section", () => {
        describe("(default child nodes name)", () => {
            basicTestCase("basic-usage");
        });
        describe("(custom child nodes name)", () => {
            basicTestCase("basic-usage-custom-children");
        });
        function basicTestCase(elementSelector:string) {
            let treeView: TreeViewAtom;
            beforeEach(() => {
                Helpers.prepareBrowser("treeview");
                let section = element(by.id(elementSelector));
                treeView = Atom.findIn(TreeViewAtom, section);
            });
            it("should have first item selected", () => {
                const treeItem = treeView.getSubItem(0);
                expect(treeItem.isSelected()).toEqual(true);
            });
            it("should be expandable", () => {
                const treeItem = treeView.getSubItem(1);
                expect(treeItem.isExpanded()).toBe(false);
                expect(treeItem.getSubItemsCount()).toBe(0);
                treeItem.toggleExpand();
                expect(treeItem.getSubItemsCount()).toBeGreaterThan(0);
                expect(treeItem.isExpanded()).toBe(true);
                treeItem.toggleExpand();
                expect(treeItem.getSubItemsCount()).toBe(0);
                expect(treeItem.isExpanded()).toBe(false);
            });
            it("should expand after double-click on label", () => {
                const treeItem = treeView.getSubItem(2);
                expect(treeItem.getSubItemsCount()).toBe(0);
                browser.actions().doubleClick(<any>treeItem.getTitleElement()).perform();
                expect(treeItem.getSubItemsCount()).toBeGreaterThan(0);
                browser.actions().doubleClick(<any>treeItem.getTitleElement()).perform();
                expect(treeItem.getSubItemsCount()).toBe(0);
            });
            it("should be selectable", () => {
                const treeItem = treeView.getSubItem(3);
                expect(treeItem.isSelected()).toEqual(false);
                treeItem.getTitleElement().click();
                expect(treeItem.isSelected()).toEqual(true);
            });
            it("should not allow multiple selection", () => {
                const parentItem = treeView.getSubItem(4);
                parentItem.toggleExpand();
                const item1 = treeView.getSubItem(2);
                const item2 = parentItem.getSubItem(1);

                // Check that no item is selected
                expect(item1.isSelected()).toEqual(false);
                expect(item2.isSelected()).toEqual(false);

                // Click first item and check states
                item1.getTitleElement().click();
                expect(item1.isSelected()).toEqual(true);
                expect(item2.isSelected()).toEqual(false);

                // Click second item and check that first is unselected
                item2.getTitleElement().click();
                expect(item1.isSelected()).toEqual(false);
                expect(item2.isSelected()).toEqual(true);
            });
            it("should provide zebra striping just on top level", () => {
                const item1 = treeView.getSubItem(1);
                const item2 = treeView.getSubItem(2);
                expect(item1.getSubItems()).not.toEqual(item2.getBackgroundColor());
                item1.toggleExpand();
                const subItem1 = item1.getSubItem(1);
                const subItem2 = item1.getSubItem(2);
                expect(subItem1.getBackgroundColor()).toEqual(subItem2.getBackgroundColor());
            });
            it("should show currently focused node", () => {
                const getFocusedNodeText = function () {
                    const textElement = element(by.id(`${elementSelector}-focused`));
                    return textElement.getText();
                };
                const node6 = treeView.getSubItem(5);
                node6.toggleExpand();
                const node5 = node6.getSubItem(4);
                node5.getTitleElement().click();
                expect(getFocusedNodeText()).toEqual("Node5");
            });
        };
    });
    describe("Keyboard controls", () => {
        let treeView: TreeViewAtom;
        beforeEach(() => {
            Helpers.prepareBrowser("treeview");
            let section = element(by.id("basic-usage"));
            treeView = Atom.findIn(TreeViewAtom, section);
        });
        it("should provide control using arrows", () => {
            const firstItem = treeView.getSubItem(2);
            expect(firstItem.isFocused()).toBe(false);

            // going to the first child of the second child of fourth three element
            firstItem.getTitleElement().click();
            expect(firstItem.isFocused()).toBe(true);
            browser.actions().sendKeys(protractor.Key.DOWN).perform();
            browser.actions().sendKeys(protractor.Key.RIGHT).perform();
            browser.actions().sendKeys(protractor.Key.DOWN).perform();
            browser.actions().sendKeys(protractor.Key.DOWN).perform();
            browser.actions().sendKeys(protractor.Key.RIGHT).perform();
            browser.actions().sendKeys(protractor.Key.DOWN).perform();
            browser.actions().sendKeys(protractor.Key.SPACE).perform();
            const lastItem = treeView.getSubItem(3).getSubItem(1).getSubItem(0);
            expect(firstItem.isFocused()).toBe(false);
            expect(lastItem.isFocused()).toBe(true);
            expect(lastItem.isSelected()).toBe(true);

            // going back to firstItem
            browser.actions().sendKeys(protractor.Key.LEFT).perform();
            browser.actions().sendKeys(protractor.Key.LEFT).perform();
            browser.actions().sendKeys(protractor.Key.LEFT).perform();
            browser.actions().sendKeys(protractor.Key.UP).perform();
            browser.actions().sendKeys(protractor.Key.SPACE).perform();
            expect(firstItem.isFocused()).toBe(true);
            expect(firstItem.isSelected()).toBe(true);
        });
        xit("should provide expand current node with (*) functionality from keyboard", () => {
            // Defect UIF-2726
            const firstItem = treeView.getSubItem(0);
            const secondItem = treeView.getSubItem(1);
            firstItem.getTitleElement().click();
            browser.actions().sendKeys(protractor.Key.MULTIPLY).perform();
            expect(firstItem.getSubItemsCount()).toBe(10);
            expect(secondItem.getSubItemsCount()).toBe(0);
            expect(firstItem.getSubItem(0).getSubItemsCount()).toBe(10);
        });
        it("should provide expand/collapse functionality", () => {
            const firstItem = treeView.getSubItem(0);
            const secondItem = treeView.getSubItem(1);
            firstItem.getTitleElement().click();
            browser.actions().sendKeys(protractor.Key.ADD).perform();
            expect(firstItem.getSubItemsCount()).toBe(10);
            expect(secondItem.getSubItemsCount()).toBe(0);
            expect(firstItem.getSubItem(0).getSubItemsCount()).toBe(0);
            browser.actions().sendKeys(protractor.Key.SUBTRACT).perform();
            expect(firstItem.getSubItemsCount()).toBe(0);
            expect(secondItem.getSubItemsCount()).toBe(0);
        });
        it("should provide expand/collapse-all functionality", () => {
            const firstItem = treeView.getSubItem(0);
            const secondItem = treeView.getSubItem(1);
            firstItem.getTitleElement().click();
            browser.actions().sendKeys(protractor.Key.SHIFT, protractor.Key.ADD).perform();
            expect(firstItem.getSubItemsCount()).toBe(10);
            expect(secondItem.getSubItemsCount()).toBe(10);
            expect(firstItem.getSubItem(0).getSubItemsCount()).toBe(0);
            browser.actions().sendKeys(protractor.Key.SHIFT, protractor.Key.SUBTRACT).perform();
            expect(firstItem.getSubItemsCount()).toBe(0);
            expect(secondItem.getSubItemsCount()).toBe(0);
        });
    });
    describe("multi-select section", () => {
        let treeView: TreeViewAtom;
        beforeEach(() => {
            Helpers.prepareBrowser("treeview");
            let section = element(by.id("multi-select"));
            treeView = Atom.findIn(TreeViewAtom, section);
        });
        it("should be selectable", () => {
            const treeItem = treeView.getSubItem(3);
            expect(treeItem.isSelected()).toEqual(false);
            treeItem.invertSelection();
            expect(treeItem.isSelected()).toEqual(true);
        });
        it("should allow multi selection", () => {
            const item1 = treeView.getSubItem(3);
            const item2 = treeView.getSubItem(4);
            expect(item1.isSelected()).toEqual(false);
            expect(item2.isSelected()).toEqual(false);
            item1.invertSelection();
            item2.invertSelection();
            expect(item1.isSelected()).toEqual(true);
            expect(item2.isSelected()).toEqual(true);
        });
        it("should be controllable by keyboard", () => {
            const firstItem = treeView.getSubItem(0);
            expect(firstItem.isFocused()).toBe(false);
            firstItem.getTitleElement().click();
            browser.actions().sendKeys(protractor.Key.DOWN).perform();
            browser.actions().sendKeys(protractor.Key.SPACE).perform();
            browser.actions().sendKeys(protractor.Key.DOWN).perform();
            browser.actions().sendKeys(protractor.Key.SPACE).perform();
            const temp1 = treeView.getSubItem(1);
            expect(firstItem.isFocused()).toBe(false);
            expect(firstItem.isSelected()).toBe(true);
            expect(temp1.isFocused()).toBe(true);
            expect(temp1.isSelected()).toBe(true);
        });
    });
    describe("is-always-selected disabled section", () => {
        let treeView: TreeViewAtom;
        beforeEach(() => {
            Helpers.prepareBrowser("treeview");
            let section = element(by.id("is-always-selected-disabled"));
            treeView = Atom.findIn(TreeViewAtom, section);
        });
        it("should not have first item selected", () => {
            const treeItem = treeView.getSubItem(0);
            expect(treeItem.isSelected()).toEqual(false);
        });

    });
    describe("Links section", () => {
        let treeView: TreeViewAtom;
        beforeEach(() => {
            Helpers.prepareBrowser("treeview");
            let section = element(by.id("links-images"));
            treeView = Atom.findIn(TreeViewAtom, section);
        });
        it("should not show expander on last item", () => {
            const firstItem = treeView.getSubItem(0);
            const lastItem = treeView.getSubItem(9);
            expect(firstItem.isExpanderVisible()).toEqual(true);
            expect(lastItem.isExpanderVisible()).toEqual(false);
        });
        it("should be expandable by single click on label", () => {
            const treeItem = treeView.getSubItem(2);
            expect(treeItem.getSubItemsCount()).toBe(0);
            treeItem.getTitleElement().click();
            expect(treeItem.getSubItemsCount()).toBeGreaterThan(0);
            treeItem.getTitleElement().click();
            expect(treeItem.getSubItemsCount()).toBe(0);
        });
        it("should return icon atom instance", () => {
            const treeItem = treeView.getSubItem(2);
            const icon =  treeItem.getIcon();
            expect(icon).not.toBeNull();
        });
    });
    describe("Limit section", () => {
        let treeView: TreeViewAtom;
        beforeEach(() => {
            Helpers.prepareBrowser("treeview");
            let section = element(by.id("limit"));
            treeView = Atom.findIn(TreeViewAtom, section);
        });
        it("should display 'show more' and 'show all' links only if needed", () => {
            const limitLinks = element(by.className("xui-treeview-limit-links"));
            const limitLinksShowMore = limitLinks.element(by.className("xui-treeview-showmore"));
            const limitLinksShowAll = limitLinks.element(by.className("xui-treeview-showall"));
            expect(limitLinks.getText()).toBe("show more / show all");
            expect(treeView.getSubItemsCount()).toBe(4); // it happened that "show more/all" links are also "li"

            limitLinksShowMore.click();
            expect(treeView.getSubItemsCount()).toBe(7); // it happened that "show more/all" links are also "li"

            limitLinksShowAll.click();
            expect(treeView.getSubItemsCount()).toBe(10);
            expect(element(by.className("xui-treeview-limit-links")).isPresent()).toBe(false);
        });
    });
    describe("Sort behavior", () => {
        let treeView: TreeViewAtom;
        let sortroot:ButtonAtom;
        let sortchild:ButtonAtom;
        beforeEach(() => {
            Helpers.prepareBrowser("treeview");
            let section = element(by.id("sorter"));
            treeView = Atom.findIn(TreeViewAtom, section);
            sortroot = Atom.findIn(ButtonAtom, section, 0);
            sortchild = Atom.findIn(ButtonAtom, section, 1);
        });
        it("should be able to reorder root nodes", () => {
            let treeItem = treeView.getSubItem(0);
            expect(treeItem.getTitleElement().getText()).toBe("Node1");
            sortroot.click();
            treeItem = treeView.getSubItem(0);
            browser.wait(() => {
                return treeItem.getTitleElement().getText().then(
                    (text) => {
                        return text === "Node10";
                    }
                );
            }, 4000); //wait up to 4 seconds
            expect(treeItem.getTitleElement().getText()).toBe("Node10");
        });
        it("should be able to reorder child nodes", () => {
            const treeItem = treeView.getSubItem(0);
            treeItem.toggleExpand();
            let child = treeItem.getSubItem(0);
            expect(child.getTitleElement().getText()).toBe("Node1");
            sortchild.click();
            child = treeItem.getSubItem(0);
            expect(child.getTitleElement().getText()).toBe("Node10");
        });
    });
    describe("Treeview state", () => {
        let treeView: TreeViewAtom;
        beforeEach(() => {
            Helpers.prepareBrowser("treeview");
            let section = element(by.id("state"));
            treeView = Atom.findIn(TreeViewAtom, section);
        });
        it("should draw treeview with setted state", () => {
            const treeItem = treeView.getSubItem(0);
            expect(treeItem.getSubItemsCount()).toBe(5);
            let subItem = treeItem.getSubItem(2);
            expect(subItem.isSelected()).toBe(true);
        });
    });
    describe("Treeview events", () => {
        let treeView: TreeViewAtom;
        beforeEach(() => {
            Helpers.prepareBrowser("treeview");
            let section = element(by.id("events"));
            treeView = Atom.findIn(TreeViewAtom, section);
        });
        it("should fire onExpand", () => {
            const parentItem = treeView.getSubItem(0);
            parentItem.toggleExpand();
            expect(element(by.id("events-last-fired")).getText()).toBe("expanded");
        });
        it("should fire onCollapse", () => {
            const parentItem = treeView.getSubItem(0);
            parentItem.toggleExpand();
            parentItem.toggleExpand();
            expect(element(by.id("events-last-fired")).getText()).toBe("collapsed");
        });
        it("should fire onSelect", () => {
            const parentItem = treeView.getSubItem(0);
            parentItem.getTitleElement().click();
            expect(element(by.id("events-last-fired")).getText()).toBe("selected");
        });
        it("should fire onDblClick", () => {
            browser.actions().doubleClick(<any>treeView.getSubItem(0).getTitleElement()).perform();
            expect(element(by.id("events-last-fired")).getText()).toBe("dbClicked");
        });
    });
});
