import {by, ElementFinder, promise} from "@solarwinds/uzi/protractor";
import {Atom} from "@solarwinds/uzi";
import {ButtonAtom, DialogAtom, WizardStepAtom} from "../index.atom";

export class WizardAtom extends Atom {
    public static CSS_CLASS = "xui-wizard";

    public static fromDialog() {
        const dialog = DialogAtom.get();
        return new WizardAtom(dialog.getBody(), dialog);
    }

    public dialog: DialogAtom;
    public backButton: ButtonAtom;
    public nextButton: ButtonAtom;
    public finishButton: ButtonAtom;
    public cancelButton: ButtonAtom;
    public additionalButtons: promise.Promise<ButtonAtom[]>;

    constructor(element: ElementFinder, dialog?: DialogAtom) {
        super(element);

        if (dialog) {
            this.dialog = dialog;
            const buttons = dialog.getFooterButtons();
            this.backButton = new ButtonAtom(buttons.filter((el: ElementFinder)=> {
                return new promise.Promise((resolve) => {
                    Atom.hasClass(el, "xui-wizard__back-button").then((value)=> {
                        resolve(value);
                    });
                });
            }).first());
            this.nextButton = new ButtonAtom(buttons.filter((el: ElementFinder)=> {
                return new promise.Promise((resolve) => {
                    Atom.hasClass(el, "xui-wizard__next-button").then((value)=> {
                        resolve(value);
                    });
                });
            }).first());
            this.finishButton = new ButtonAtom(buttons.filter((el: ElementFinder)=> {
                return new promise.Promise((resolve) => {
                    Atom.hasClass(el, "xui-wizard__finish-button").then((value)=> {
                        resolve(value);
                    });
                });
            }).first());
            this.cancelButton = new ButtonAtom(buttons.filter((el: ElementFinder)=> {
                return new promise.Promise((resolve) => {
                    Atom.hasClass(el, "xui-wizard__cancel-button").then((value)=> {
                        resolve(value);
                    });
                });
            }).first());

            this.additionalButtons = buttons.filter((el: ElementFinder)=> {
                return new promise.Promise((resolve)=> {
                    const builtInButtons = ["xui-wizard__back-button",
                        "xui-wizard__next-button",
                        "xui-wizard__finish-button",
                        "xui-wizard__cancel-button"];
                    Atom.hasAnyClass(el, builtInButtons).then((result) => {
                        resolve(!result);
                    });
                });
            })
                .reduce((accumulator: ButtonAtom[], el: ElementFinder)=> {
                    accumulator.push(new ButtonAtom(el));
                    return accumulator;
                }, []);
        } else {
            this.backButton = new ButtonAtom(super.getElement().element(by.className("xui-wizard__back-button")));
            this.nextButton = new ButtonAtom(super.getElement().element(by.className("xui-wizard__next-button")));
            this.finishButton = new ButtonAtom(super.getElement().element(by.className("xui-wizard__finish-button")));
            this.cancelButton = new ButtonAtom(super.getElement().element(by.className("xui-wizard__cancel-button")));

            this.additionalButtons = super.getElement().all(by.className("xui-wizard__additional-button"))
                .reduce((accumulator: ButtonAtom[], el: ElementFinder)=> {
                    accumulator.push(new ButtonAtom(el));
                    return accumulator;
                }, []);
        }
    }

    public cancel = () => {
        return this.cancelButton.click();
    };

    public next = () => {
        return this.nextButton.click();
    };

    public back = () => {
        return this.backButton.click();
    };

    public finish = () => {
        return this.finishButton.click();
    };

    public goToStep = (index: number) => {
        const headerStep = super.getElement().all(by.className("xui-wizard__header-step")).get(index);
        headerStep.click();
    };

    public getHeaderSteps = () => {
        const stepsEl = super.getElement().element(by.className("xui-wizard__header-steps"));

        return stepsEl.all(by.className("xui-wizard__header-step")).map((el: ElementFinder)=> {
            return el.all(by.className("xui-wizard__header-step-title")).first().getText();
        });
    };

    public getSteps = () => {
        const stepsEl = super.getElement().element(by.className("xui-wizard__steps"));

        //this should really be a map operation.  However, map has a bug- if you put an element finder
        //in it, it will try to resolve EVERYTHING, and causes node to go into an infinite loop
        return stepsEl.all(by.className("xui-wizard__step"))
            .reduce((accumulator: WizardStepAtom[], el: ElementFinder)=> {
                accumulator.push(new WizardStepAtom(el));
                return accumulator;
            }, []);
    };

    public getCurrentStepTitle = () => {
        const el = super.getElement().element(by.className("xui-wizard__title"));
        return el.getText();
    };

}
