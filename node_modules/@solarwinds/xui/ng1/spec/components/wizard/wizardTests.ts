import {browser, by, element, promise} from "@solarwinds/uzi/protractor";
import {Atom} from "@solarwinds/uzi";
import {ButtonAtom, CheckboxAtom, TextboxAtom, WizardAtom} from "../index.atom";

export default class WizardTests {
    public static wizard: WizardAtom;
    public static run = () => {
        const expectedPromiseDelay = 1000;

        it("should be defined", () => {
            expect(WizardTests.wizard).toBeDefined();
        });

        it("should have 3 steps", () => {
            WizardTests.wizard.getSteps().then((steps)=> {
                expect(steps.length).toBe(3);
            });
        });

        it("clicking on additional button should do something", () => {
            WizardTests.wizard.additionalButtons.then((buttons) => {
                buttons[0].click();
                const clicked = Atom.find(CheckboxAtom, "additionalButtonClicked");
                expect(clicked.isChecked()).toBe(true);
            });
        });

        it("should display title & short title", () => {
            WizardTests.wizard.getHeaderSteps().then((steps)=> {
                expect(steps[0]).toBe("Step One");
                expect(steps[1]).toBe("2");
            });
        });

        it("should not show back button on first step", () => {
            expect(WizardTests.wizard.backButton.isVisible()).toBe(false);
        });

        it("should be able to go next", () => {
            const el = element(by.id("elementOnStep2"));
            expect(el.isDisplayed()).toBe(false);

            WizardTests.wizard.next();

            expect(WizardTests.wizard.getCurrentStepTitle().then((text: string) => {
                return text.toLowerCase();
            })).toBe("step two");

            expect(el.isDisplayed()).toBe(true);
        });

        it("should not be able to click on header steps until visited", () => {
            const el = element(by.id("elementOnStep2"));
            expect(el.isDisplayed()).toBe(false);
            WizardTests.wizard.goToStep(1);
            expect(el.isDisplayed()).toBe(false);
            WizardTests.wizard.next();
            expect(el.isDisplayed()).toBe(true);
        });

        it("should be able to move by clicking on header steps", () => {
            const el = element(by.id("elementOnStep1"));
            expect(el.isDisplayed()).toBe(true);

            WizardTests.wizard.next();
            WizardTests.wizard.next();
            expect(el.isDisplayed()).toBe(false);

            // Wait for step to finish.
            browser.sleep(expectedPromiseDelay);
            WizardTests.wizard.goToStep(0);
            expect(el.isDisplayed()).toBe(true);
        });

        it("should be able to go back", () => {
            const el = element(by.id("elementOnStep1"));
            expect(el.isDisplayed()).toBe(true);

            WizardTests.wizard.next();

            expect(el.isDisplayed()).toBe(false);
            WizardTests.wizard.back();
            expect(el.isDisplayed()).toBe(true);
        });

        it("should be able to disable forward/back navigation", () => {
            const canGoNext = Atom.find(CheckboxAtom, "canGoNext");
            const canGoBack = Atom.find(CheckboxAtom, "canGoBack");

            WizardTests.wizard.next();

            expect(WizardTests.wizard.backButton.isDisabled()).toBe(false);
            expect(WizardTests.wizard.nextButton.isDisabled()).toBe(false);
            canGoNext.click();
            canGoBack.click();
            expect(WizardTests.wizard.backButton.isDisabled()).toBe(true);
            expect(WizardTests.wizard.nextButton.isDisabled()).toBe(true);
        });

        it("should evaluate onNextStep,onEnterStep,onExitStep", () => {
            const step1Entered = Atom.find(CheckboxAtom, "step1StateEntered");
            const step1Exited = Atom.find(CheckboxAtom, "step1StateExited");
            const step2Entered = Atom.find(CheckboxAtom, "step2StateEntered");
            const step2Exited = Atom.find(CheckboxAtom, "step2StateExited");
            const step3Entered = Atom.find(CheckboxAtom, "step3StateEntered");
            const step3Exited = Atom.find(CheckboxAtom, "step3StateExited");

            expect(step1Entered.isChecked()).toBe(true);
            expect(step1Exited.isChecked()).toBe(false);
            expect(step2Entered.isChecked()).toBe(false);
            expect(step2Exited.isChecked()).toBe(false);
            expect(step3Entered.isChecked()).toBe(false);
            expect(step3Exited.isChecked()).toBe(false);

            WizardTests.wizard.next();
            expect(step1Entered.isChecked()).toBe(true);
            expect(step1Exited.isChecked()).toBe(true);
            expect(step2Entered.isChecked()).toBe(true);
            expect(step2Exited.isChecked()).toBe(false);
            expect(step3Entered.isChecked()).toBe(false);
            expect(step3Exited.isChecked()).toBe(false);

            WizardTests.wizard.next();
            expect(step1Entered.isChecked()).toBe(true);
            expect(step1Exited.isChecked()).toBe(true);
            expect(step2Entered.isChecked()).toBe(true);
            expect(step2Exited.isChecked()).toBe(true);
            expect(step3Entered.isChecked()).toBe(true);
            expect(step3Exited.isChecked()).toBe(false);

            WizardTests.wizard.back();
            expect(step1Entered.isChecked()).toBe(true);
            expect(step1Exited.isChecked()).toBe(true);
            expect(step2Entered.isChecked()).toBe(true);
            expect(step2Exited.isChecked()).toBe(true);
            expect(step3Entered.isChecked()).toBe(true);
            expect(step3Exited.isChecked()).toBe(true);
        });

        it("should maintain consumer state", () => {
            const inputValue = "input for textbox";

            WizardTests.wizard.next();
            const input = Atom.find(TextboxAtom, "step2InputField");
            expect(input).toBeDefined();

            input.acceptText(inputValue);
            WizardTests.wizard.next();

            const elResult = element(by.id("step2InputResult"));
            expect(elResult).toBeDefined();
            expect(elResult.getText()).toBe(inputValue);
        });

        it("should be able to track currentStepIndex", () => {
            WizardTests.wizard.next();

            const indexInput = element(by.id("currentStepIndex"));
            expect(indexInput.getAttribute("value")).toBe("1");
        });

        it("should be able to set currentStep by currentStepIndex", () => {
            const indexInput = element(by.id("currentStepIndex"));

            indexInput.clear();
            indexInput.sendKeys("2");

            const el = element(by.id("elementOnStep3"));
            expect(el.isDisplayed()).toBe(true);
        });

        it("should be able to get to last step", () => {
            WizardTests.wizard.next();
            WizardTests.wizard.next();

            // Wait for step to finish.
            browser.sleep(expectedPromiseDelay);
            const el = element(by.id("elementOnStep3"));
            expect(el.isDisplayed()).toBe(true);
        });

        it("should be able to cancel next", () => {
            const el = element(by.id("elementOnStep2"));
            expect(el.isDisplayed()).toBe(false);

            WizardTests.wizard.next();
            // Wait for step to finish.
            browser.sleep(expectedPromiseDelay);
            expect(el.isDisplayed()).toBe(true);

            const shouldCancel = Atom.find(CheckboxAtom, "shouldCancelNext");
            shouldCancel.click();
            expect(shouldCancel.isChecked()).toBe(true);

            WizardTests.wizard.next();
            expect(el.isDisplayed()).toBe(true);
        });

        it("should be able to cancel finish", () => {
            WizardTests.wizard.next();
            WizardTests.wizard.next();

            // Wait for step to finish.
            browser.sleep(expectedPromiseDelay);

            const shouldCancel = Atom.find(CheckboxAtom, "shouldCancelNext");
            shouldCancel.click();
            expect(shouldCancel.isChecked()).toBe(true);

            WizardTests.wizard.finish();
            // Wait for step to finish.
            browser.sleep(expectedPromiseDelay);

            const finished = Atom.find(CheckboxAtom, "wizardFinished");
            expect(finished.isChecked()).toBe(false);
        });

        it("should be able to cancel", () => {
            const cancelled = Atom.find(CheckboxAtom, "wizardCancelled");
            expect(cancelled.isChecked()).toBe(false);

            WizardTests.wizard.cancel();
            expect(cancelled.isChecked()).toBe(true);
        });

        it("should be able to finish", () => {
            WizardTests.wizard.next();
            WizardTests.wizard.next();

            // Wait for step to finish.
            browser.sleep(expectedPromiseDelay);
            WizardTests.wizard.finish();

            const finished = Atom.find(CheckboxAtom, "wizardFinished");
            expect(finished.isChecked()).toBe(true);
        });

        it("should be able to insert a step", () => {
            const insertBtn = Atom.find(ButtonAtom, "insertStepButton");
            insertBtn.click();

            WizardTests.wizard.next();

            const el = element(by.id("elementOnInsertedStep"));
            expect(el.isDisplayed()).toBe(true);
            expect(WizardTests.wizard.getCurrentStepTitle()).toBe("Inserted Step");
        });
    };
}
