import {browser, by, element, promise} from "@solarwinds/uzi/protractor";
import Helpers from "../helpers";
import {TimeframePickerAtom} from "../index.atom";

describe("USERCONTROL TimeframePicker >", () => {
    let timeframePicker: TimeframePickerAtom,
        timeframePickerMaxMin: TimeframePickerAtom;

    function getModelStartDatetime(id = "model-startDatetime") {
        return element(by.id(id)).getText();
    }

    function getModelEndDatetime(id = "model-endDatetime") {
        return element(by.id(id)).getText();
    }

    function getMaxDate() {
        return element(by.id("maxDatetime")).getText();
    }

    function getMinDate() {
        return element(by.id("minDatetime")).getText();
    }

    function getOnChangeText() {
        return element(by.id("model-onChangeTitle")).getText();
    }

    function getModelSelectedPresetId() {
        return element(by.id("model-selectedPresetId")).getText();
    }

    function getTime(): string {
        let hour = new Date().getHours();
        hour = hour === 1 ? 3 : 1;

        return "0" + hour + ":01 AM";
    }

    function getStartDate(): string {
        return "01-Jan-2010";
    }

    function getEndDate(): string {
        return "01-Feb-2010";
    }

    beforeEach(() => {
        Helpers.prepareBrowser("timeframepicker");

        timeframePicker = TimeframePickerAtom.findIn(TimeframePickerAtom, element(by.id("timeframepicker")));
        timeframePickerMaxMin = TimeframePickerAtom.findIn(TimeframePickerAtom, element(by.id("tfpMaxMin")));
    });

    describe("when the title is clicked", ()=> {

        it(" it opens the popover", ()=> {
            expect(timeframePicker.isOpened()).toEqual(false);

            timeframePicker.open();

            expect(timeframePicker.isOpened()).toEqual(true);
        });
    });

    describe("when the popover is opened", ()=> {
        describe("and a new quick pick is selected", ()=> {
            it(" it highlights the selected quick pick", ()=> {
                timeframePicker.selectPresetByTitle("Last 12 hours");
                browser.wait(() => {
                    return timeframePicker.getSelectedPreset().then((preset: string)=> {
                        return preset === "Last 12 hours";
                    });
                }, 20000);

                expect(timeframePicker.getSelectedPreset()).toEqual("Last 12 hours");
            });

            it(" it closes the confirmation panel", ()=> {
                timeframePicker.selectPresetByTitle("Last 12 hours");

                browser.wait(() => {
                    return timeframePicker.isOpened().then((isOpened: boolean)=> {
                        return !isOpened;
                    });
                }, 1000);

                expect(timeframePicker.isOpened()).toEqual(false);
            });

            it(" it changes model.selectedPresetId", ()=> {
                expect(getModelSelectedPresetId()).toBe("lastHour");

                timeframePicker.selectPresetByTitle("Last 12 hours");

                expect(getModelSelectedPresetId()).toBe("last12Hours");
            });
        });

        describe("and a date is changed", ()=> {
            it("it displays the confirmation panel", ()=> {
                timeframePicker.open();

                expect(timeframePicker.isConfirmationPanelShown()).toBe(false);

                timeframePicker.setStartTime(getTime());

                expect(timeframePicker.isConfirmationPanelShown()).toBe(true);
            });

            it(" no quick pick is selected", ()=> {
                expect(timeframePicker.getSelectedPreset()).not.toBeNull();

                timeframePicker.setStartTime(getTime());

                expect(timeframePicker.getSelectedPreset()).toBeNull();
            });

            it(" it restores dates when start date is greater then end date", ()=> {
                const startDatetime = getModelStartDatetime();
                const endDatetime = getModelEndDatetime();
                const selectedPresetId = getModelSelectedPresetId();

                timeframePicker.setStartDate(getEndDate());
                timeframePicker.setEndDate(getStartDate());

                expect(getModelStartDatetime()).toBe(startDatetime);
                expect(getModelEndDatetime()).toBe(endDatetime);
                expect(getModelSelectedPresetId()).toBe(selectedPresetId);
            });

            it(" it restores dates when start date or end date is empty", ()=> {
                const startDatetime = getModelStartDatetime();
                const selectedPresetId = getModelSelectedPresetId();

                timeframePicker.open();

                timeframePicker.getStartDatetimePicker().then((picker) => {
                    picker.getDatePicker().clearText();
                    picker.getDatePicker().clickCalendarIcon();
                });

                expect(getModelStartDatetime()).toBe(startDatetime);

                timeframePicker.getStartDatetimePicker().then((picker) => {
                    picker.getTimePicker().clearText();
                });

                expect(getModelStartDatetime()).toBe(startDatetime);
                expect(getModelSelectedPresetId()).toBe(selectedPresetId);
            });

            describe("and 'Use' button is clicked", ()=> {
                it(" it closes the popover", ()=> {
                    timeframePicker.setStartTime(getTime());

                    timeframePicker.clickUseButton();

                    browser.wait(() => {
                        return timeframePicker.isOpened().then((isOpened: boolean)=> {
                            return !isOpened;
                        });
                    }, 1000);

                    expect(timeframePicker.isOpened()).toBe(false);
                });

                it(" it changes the title", ()=> {
                    timeframePicker.getLinkElement().getText().then((link) => {
                        timeframePicker.open();

                        timeframePicker.setStartTime(getTime());

                        timeframePicker.clickUseButton();

                        browser.wait(() => {
                            return timeframePicker.getLinkElement().getText().then((updatedLink) => {
                                return updatedLink !== link;
                            });
                        }, 1000);

                        expect(timeframePicker.getLinkElement().getText()).not.toBe(link);
                    });
                });

                it(" it propagates the value to model", ()=> {
                    const startDatetime = getModelStartDatetime();
                    const endDatetime = getModelEndDatetime();

                    timeframePicker.setStartDate(getStartDate());
                    timeframePicker.setStartTime(getTime());
                    timeframePicker.setEndDate(getEndDate());
                    timeframePicker.setEndTime(getTime());

                    timeframePicker.clickUseButton();
                    const expectedStartDatetime = '"' + new Date(getStartDate() + " " + getTime()).toISOString() + '"';
                    const expectedEndDatetime = '"' + new Date(getEndDate() + " " + getTime()).toISOString() + '"';

                    expect(getModelStartDatetime()).toBe(expectedStartDatetime);
                    expect(getModelStartDatetime()).not.toBe(startDatetime);
                    expect(getModelEndDatetime()).toBe(expectedEndDatetime);
                    expect(getModelEndDatetime()).not.toBe(endDatetime);
                    expect(getModelSelectedPresetId()).toBe("");
                });

                it(" it raises on change event", () => {
                    timeframePicker.setStartTime(getTime());

                    timeframePicker.clickUseButton();

                    expect(getOnChangeText()).not.toBe("");
                });

                describe("and the time is changed", ()=> {
                    it(" it restores time when start time is set greater then" +
                        " end time and date is same for both", ()=> {
                        const startDatetime = getModelStartDatetime();
                        const endDatetime = getModelEndDatetime();
                        const selectedPresetId = getModelSelectedPresetId();

                        timeframePicker.setStartDate("1/10/2015");
                        timeframePicker.setEndDate("1/10/2015");
                        timeframePicker.setEndTime("22:00");
                        timeframePicker.setStartTime("23:00");

                        expect(getModelStartDatetime()).toBe(startDatetime);
                        expect(getModelEndDatetime()).toBe(endDatetime);
                        expect(getModelSelectedPresetId()).toBe(selectedPresetId);
                    });

                    it(" it restores time when end time is set lower then end time and date is same for both", ()=> {
                        const startDatetime = getModelStartDatetime();
                        const endDatetime = getModelEndDatetime();
                        const selectedPresetId = getModelSelectedPresetId();

                        timeframePicker.setStartDate("1/10/2015");
                        timeframePicker.setEndDate("1/10/2015");
                        timeframePicker.setStartTime("22:00");
                        timeframePicker.setEndTime("21:00");

                        expect(getModelStartDatetime()).toBe(startDatetime);
                        expect(getModelEndDatetime()).toBe(endDatetime);
                        expect(getModelSelectedPresetId()).toBe(selectedPresetId);
                    });
                });
            });

            describe("and 'Cancel' button is clicked", ()=> {
                xit(" it closes the popover", ()=> {
                    timeframePicker.setStartTime(getTime())
                        .then(() => timeframePicker.clickCancelButton())
                        .then(() => expect(timeframePicker.isOpened()).toBe(false));
                });

                xit(" it doesn't change the title", ()=> {
                    timeframePicker.getLinkElement().getText().then((link) => {
                        timeframePicker.setStartTime(getTime())
                            .then(() => timeframePicker.clickCancelButton())
                            .then(() => expect(timeframePicker.getLinkElement().getText()).toBe(link));
                    });
                });

                xit(" it doesn't propagate the value to model", ()=> {
                    const startDatetime = getModelStartDatetime();
                    const endDatetime = getModelEndDatetime();
                    const selectedPresetId = getModelSelectedPresetId();

                    timeframePicker.setStartTime(getTime())
                        .then(() => timeframePicker.setEndTime(getTime()))
                        .then(() => timeframePicker.clickCancelButton())
                        .then(() => {
                            expect(getModelStartDatetime()).toBe(startDatetime);
                            expect(getModelEndDatetime()).toBe(endDatetime);
                            expect(getModelSelectedPresetId()).toBe(selectedPresetId);
                        });
                });
            });
        });

        describe("and maxDate, minDate is set", () => {
            let minDate: Date,
                maxDate: Date;

            beforeEach( () => {
                return getMinDate().then( (dateStr: string) => {
                    minDate = new Date(dateStr.slice(1, -1));
                    return getMaxDate().then( (dateStr2: string) => {
                        maxDate = new Date(dateStr2.slice(1, -1));
                    });
                });
            });

            it("should forbid selection of date less than minDate", () => {
                //greater dates could be selected
                timeframePickerMaxMin.clickOnDateStartDTP(minDate.getDate() + 2);
                expect(getModelStartDatetime("modelMaxMin-startDatetime")).toEqual('"2012-08-16T00:00:00.000Z"');
                timeframePickerMaxMin.clickOnDateStartDTP(minDate.getDate() - 3).catch(() => {
                    //not-clickable element will fire webdriver error
                });
                //since there is no possibility to click on date less than minDate the model should left unchanged
                expect(getModelStartDatetime("modelMaxMin-startDatetime")).toEqual('"2012-08-16T00:00:00.000Z"');
            });

            it("should forbid selection of date greater than maxDate", () => {
                //smaller dates could be selected
                timeframePickerMaxMin.clickOnDateEndDTP(maxDate.getDate() - 2);
                expect(getModelStartDatetime("modelMaxMin-endDatetime")).toEqual('"2015-07-14T00:00:00.000Z"');
                timeframePickerMaxMin.clickOnDateEndDTP(maxDate.getDate() + 3).catch(() => {
                    //not-clickable element will fire webdriver error
                });
                //since there is no possibility to click on date greater than maxDate the model should left unchanged
                expect(getModelStartDatetime("modelMaxMin-endDatetime")).toEqual('"2015-07-14T00:00:00.000Z"');
            });
        });
    });
});
