import * as protractor from "@solarwinds/uzi/protractor";
import {browser, by, element, promise} from "@solarwinds/uzi/protractor";
import Helpers from "../helpers";
import {DatePickerAtom} from "../index.atom";
import {Atom} from "@solarwinds/uzi";

describe("USERCONTROL datePicker", () => {
    let datePickerInline: DatePickerAtom;
    let datePickerPopUp: DatePickerAtom;
    let datePickerInlineDisabled: DatePickerAtom;
    let datePickerPopUpDisabled: DatePickerAtom;
    let datePickerWithNgChange: DatePickerAtom;
    let datePickerMaxMin: DatePickerAtom;

    function getMaxDate() {
        return element(by.id("maxDate")).getText();
    }

    function getMinDate() {
        return element(by.id("minDate")).getText();
    }

    beforeEach(() => {
        Helpers.prepareBrowser("datePicker");
        datePickerInline = Atom.findIn(DatePickerAtom, element(by.id("inline-datepicker")));
        datePickerPopUp = Atom.findIn(DatePickerAtom, element(by.id("input-datepicker")));

        datePickerInlineDisabled =
            Atom.findIn(DatePickerAtom, element(by.id("disabled-inline-datepicker")));
        datePickerPopUpDisabled =
            Atom.findIn(DatePickerAtom, element(by.id("disabled-input-datepicker")));

        datePickerWithNgChange = DatePickerAtom.findIn(DatePickerAtom, element(by.id("datepicker-with-onchange")));

        datePickerMaxMin = Atom.findIn(DatePickerAtom, element(by.id("datepicker-with-maxmin")));
    });

    //----------INLINE MODE OF DATEPICKER---------------
    describe("when it is disabled", () => {
        it("clicking on title does nothing", () => {

            let originalTitle = datePickerInlineDisabled.getTitle();

            datePickerInlineDisabled.clickTitle().then(() => {
                    fail("Element should not be clickable for Observer");
                },
                (err) => {
                    expect(err.message.toString()).toMatch("is not clickable at point");
                });

            let modifiedTitle = datePickerInlineDisabled.getTitle();
            expect(originalTitle).toEqual(modifiedTitle);
        });

        it("clicking on next does nothing", () => {

            let originalTitle = datePickerInlineDisabled.getTitle();

            datePickerInlineDisabled.goNext().then(() => {
                    fail("Element should not be clickable for Observer");
                },
                (err) => {
                    expect(err.message.toString()).toMatch("is not clickable at point");
                });

            let modifiedTitle = datePickerInlineDisabled.getTitle();
            expect(originalTitle).toEqual(modifiedTitle);
        });

        it("clicking on back does nothing", () => {

            let originalTitle = datePickerInlineDisabled.getTitle();

            datePickerInlineDisabled.goBack().then(() => {
                    fail("Element should not be clickable for Observer");
                },
                (err) => {
                    expect(err.message.toString()).toMatch("is not clickable at point");
                });

            let modifiedTitle = datePickerInlineDisabled.getTitle();
            expect(originalTitle).toEqual(modifiedTitle);
        });
    });

    it("should show year in title and months in body upon click on title", () => {
        let currentYear: string = new Date().getFullYear().toString();
        //Get random month
        let randomMonth = () => {
            return DatePickerAtom.MONTHNAMES_SHORT[Math.floor(Math.random() * 12)];
        };
        //Go upper level in title
        datePickerInline.clickTitle();

        expect(datePickerInline.getTitle()).toEqual(currentYear);

        expect(datePickerInline.getMonthElement(randomMonth()).isPresent()).toBe(true);
    });

    it("should change title upon click on next/previous buttons", () => {
        //define current title and title which should appear upon click on Next button
        const date = new Date();
        const currentMonthNumber = date.getMonth();
        const thisYear = date.getFullYear();
        const nextYear = currentMonthNumber === 11 ? thisYear + 1 : thisYear; // hack for December

        let currentTitle: string = `${DatePickerAtom.MONTHNAMES_LONG[currentMonthNumber]} ${thisYear}`;
        let nextTitle: string = `${DatePickerAtom.MONTHNAMES_LONG[(currentMonthNumber + 1) % 12]} ${nextYear}`;

        //initial title
        expect(datePickerInline.getTitle()).toEqual(currentTitle);
        //go next
        datePickerInline.goNext();
        //title after click on Next button
        expect(datePickerInline.getTitle()).toEqual(nextTitle);
        //go back to initial title
        datePickerInline.goBack();
        //initial title
        expect(datePickerInline.getTitle()).toEqual(currentTitle);
    });

    it("should show years in body upon click on title (in state of year)", () => {
        let nextTitle: any = datePickerInline.getNextTitle();
        let currentYear: string = new Date().getFullYear().toString();
        datePickerInline.clickTitle();

        expect(datePickerInline.getTitle()).toEqual(nextTitle);

        expect(datePickerInline.getYearElement(currentYear).isPresent()).toBe(true);
    });

    //--------POPUP MODE OF DATEPICKER-------------
    it("should not be possible to click on icon when it is disabled", () => {
        expect(datePickerPopUpDisabled.getInput().isEnabled()).toBe(false);
    });

    it("should open popup upon click on icon", () => {
        datePickerPopUp.clickCalendarIcon();

        expect(datePickerPopUp.getPopup().isDisplayed()).toBe(true);
    });

    it("should show datepicker popup upon click on input", () => {
        datePickerPopUp.clickInput();

        expect(datePickerPopUp.getPopup().isDisplayed()).toBe(true);
    });

    // TC1: verify that current date on popup and date on opened calendar are the same

    it("should have the same date both on input form and popped up window upon the click on input", () => {
        let stringDate: string = "1/1/2020";

        //check if value on input is correct
        expect(datePickerPopUp.getInputValue()).toEqual(stringDate);

        //click on it
        datePickerPopUp.clickInput();

        expect(datePickerPopUp.getTitle()).toEqual("January 2020");

        //check that correct day is selected
        expect(datePickerPopUp.getActiveDay()).toEqual("01");
    });

    // 2TC: verify that all buttons (except "Close") working as expected

    it("should select current date upon click on 'Today'", () => {
        datePickerPopUp.clickInput();
        datePickerPopUp.clickToday();

        expect(datePickerPopUp.getInputValue()).toEqual(datePickerPopUp.formatDate(new Date()));
    });

    // TC3: open the calendar and choose some date, verify that date is choosen and popup show correct date
    it("should correctly change to the selected date", () => {
        let day: number = 20;
        let date: Date = new Date("1 Jan 2020");
        date.setDate(day);

        datePickerPopUp.clickInput();
        //select some date
        datePickerPopUp.selectDay(day);

        //check that input updated to selected date
        expect(datePickerPopUp.getInputValue()).toEqual(datePickerPopUp.formatDate(date));

        browser.wait(() => datePickerPopUp.isOpened().then((isOpened) => !isOpened));
        datePickerPopUp.clickCalendarIcon();
        //check that selected day is active
        expect(datePickerPopUp.getActiveDay()).toEqual("20");
    });

    // UIF-1271 - popup wasn't closing after selecting date
    it("should close datepicker popup upon click on a date", () => {
        // open popup by clicking on popup
        datePickerPopUp.clickInput();

        //browser.wait(()=>datePickerPopUp.getPopup().isDisplayed(), 1000);
        expect(datePickerPopUp.getPopup().isDisplayed()).toBe(true);

        // close popup by clicking on "Today" button
        datePickerPopUp.clickToday();
        expect(datePickerPopUp.getPopup().isPresent()).toBe(false);
    });

    // UIF-2140 - DatePicker: support text input
    describe("should be validate the text inputs accordingly, such ", () => {

        let wrongDates: string[] = [
            "abcdefg",
            "112233"
        ];

        for (let date of DatePickerAtom.ACCEPTED_DATES) {
            testDateFormat(date, true);
        }
        for (let date of wrongDates) {
            testDateFormat(date, false);
        }

        function testDateFormat(date: string, acceptable: boolean) {
            let validity = acceptable ? "valid" : "invalid";
            it(date + " as " + validity, () => {
                datePickerPopUp.clearText();
                datePickerPopUp.acceptText(date);
                expect(datePickerPopUp.isValid()).toBe(acceptable);
            });
        }

    });

    it("calls onChange when new value is selected", () => {
        datePickerWithNgChange.clickInput();
        datePickerWithNgChange.clickToday();
        const verificationInput = element(by.id("onChangeCalled"));
        expect(verificationInput.getAttribute("value")).toBe("true");
    });

    describe("when maxDate, minDate is set", () => {
        let minDate: Date;
        let maxDate: Date;

        beforeEach( (done: DoneFn) => {
            protractor.promise
               .all([getMinDate(), getMaxDate()])
               .then((values:string[]) => {
                   minDate = new Date(values[0].slice(1,-1));
                   maxDate = new Date(values[1].slice(1,-1));
                   done();
           });
        });

        it("should forbid selection of date less than minDate", () => {
            //larger dates can be selected
            let date: Date = new Date(minDate);
            date.setDate(date.getDate() + 2);

            datePickerMaxMin.clearText();
            datePickerMaxMin.acceptText(datePickerMaxMin.formatDate(date));
            datePickerMaxMin.clickCalendarIcon();

            expect(datePickerMaxMin.getInputValue()).toEqual(datePickerMaxMin.formatDate(date));

            //smaller dates should reset back to the minDate
            date = new Date(minDate);
            date.setDate(date.getDate() - 2);

            datePickerMaxMin.clearText();
            datePickerMaxMin.acceptText(datePickerMaxMin.formatDate(date));
            datePickerMaxMin.clickCalendarIcon();

            expect(datePickerMaxMin.getInputValue()).toEqual(datePickerMaxMin.formatDate(minDate));
        });

        it("should forbid selection of date greater than maxDate", () => {
            //smaller dates can be selected
            let date: Date = new Date(maxDate);
            date.setDate(date.getDate() - 2);

            datePickerMaxMin.clearText();
            datePickerMaxMin.acceptText(datePickerMaxMin.formatDate(date));
            datePickerMaxMin.clickCalendarIcon();

            expect(datePickerMaxMin.getInputValue()).toEqual(datePickerMaxMin.formatDate(date));

            //larger dates should reset back to the maxDate
            date = new Date(maxDate);
            date.setDate(date.getDate() + 2);

            datePickerMaxMin.clearText();
            datePickerMaxMin.acceptText(datePickerMaxMin.formatDate(date));
            datePickerMaxMin.clickCalendarIcon();

            expect(datePickerMaxMin.getInputValue()).toEqual(datePickerMaxMin.formatDate(maxDate));
        });
    });
});
