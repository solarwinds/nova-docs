import * as protractor from "@solarwinds/uzi/protractor";
import {browser, promise} from "@solarwinds/uzi/protractor";
import * as webdriver from "@solarwinds/uzi/webdriver";
import {Atom} from "@solarwinds/uzi";

// Node typings have conflicts with webpack-env
declare var process: any;

export default class SpecHelpers {

    /**
     * Checks if element is not present first. If it is present, returns true if the element is not displayed.
     * Internally getElement is used. If that call fails, the error is caught and onErrorResolveAs will be returned.
     * By default this value is false under the assumption that failure to locate the elemen means it is not present.
     * Useful in combination with browser.wait:
     * browser.wait(()=>SpecHelpers.isNotPresentOrNotDisplayed(myAtom));
     */
    public static isNotPresentOrNotDisplayed(atom: Atom, onErrorResolveAs: boolean = true):
        promise.Promise<boolean> {
        return SpecHelpers.wrapPromise<boolean>((async () => {
            let displayed: boolean = onErrorResolveAs;
            try {
                if (await atom.getElement().isPresent()) {
                    displayed = await atom.getElement().isDisplayed();
                    return !displayed;
                } else {
                    return true;
                }
            } catch (e) {
                // Catch error since we dont' want failures of getElement or isPresent to
                // stop tests. Instead we return onErrorResolveAs
            }
            return displayed;
        })());
    }

    /**
     * Checks if element is present first before calling element.isDisplayed to avoid error when element is
     * not even present
     */
    public static isPresentAndDisplayed(atom: Atom): promise.Promise<boolean> {
        return SpecHelpers.wrapPromise<boolean>((async () => {
            let displayed: boolean = false;
            try {
                if (await atom.getElement().isPresent()) {
                    displayed = await atom.getElement().isDisplayed();
                    return displayed;
                } else {

                    return displayed;
                }
            } catch (e) {
                console.log("SpecHelpers.isPresentAndDisplayed", e.message);
            }
            return false;
        })());
    }

    public static mouseOver(atom: Atom, offset?: webdriver.ILocation): promise.Promise<void> {
        return browser.actions().mouseMove(atom.getElement().getWebElement(), offset).perform();
    }

    public static mouseDown(atom: Atom, offset?: webdriver.ILocation): promise.Promise<void> {
        return SpecHelpers.wrapPromise<void>((async () => {
            try {
                await SpecHelpers.mouseOver(atom, offset);
                return await browser.actions().mouseDown().perform();
            } catch (e) {
                console.log("SpecHelpers.mouseDown", e.message);
            }
            return;
        })());
    }

    public static mouseUp(atom: Atom, offset?: webdriver.ILocation):
        promise.Promise<void> {
        return SpecHelpers.wrapPromise<void>((async () => {
            try {
                await SpecHelpers.mouseOver(atom, offset);
                return await browser.actions().mouseUp().perform();
            } catch (e) {
                console.log("SpecHelpers.mouseUp", e.message);
            }
            return;
        })());
    }

    /**
     * Wraps an ES6 Promise as a WebDriver promise for scenarions where promises are needed by Protractor methods.
     */
    public static wrapPromise<T>(promise: Promise<T>): promise.Promise<T> {
        let deferred = protractor.promise.defer<T>();
        promise.then((value) => deferred.fulfill(value))
            .catch((reason) => deferred.reject(reason));
        return deferred.promise;
    }
}
