import { browser, by, element, promise } from "@solarwinds/uzi/protractor";
import Helpers from "../helpers";
import { Atom, IAtomClass } from "@solarwinds/uzi";
import { IconAtom, ButtonAtom, MessageAtom } from "../index.atom";

//region Test cases
describe("USERCONTROL bindHtmlCompile:", () => {

    async function prepare() {
        await Helpers.prepareBrowser("bindHtmlCompile");
    }

    const idComplex = "testComplex";
    const idComplexData = "testComplexData";
    const idComplexScope = "testComplexScope";

    function getAtoms<T extends Atom>(atomClass: IAtomClass<T>, ids: string[]): T[] {
        return ids.map(id => Atom.findIn(atomClass, element(by.id(id))));
    }

    describe("should expand", () => {

        beforeAll(prepare);

        it("simple html", async () => {
            const text = await element(by.id("markerID")).getText();
            expect(text).toBe("simple");
        });

        it("compilable elements", async () => {
            const [ atom ] = getAtoms(ButtonAtom, [idComplex]);
            const text = await atom.getText();
            expect(await atom.isVisible()).toBe(true);
            expect(text.toLowerCase()).toBe("complex");
        });

        it("compilable elements with custom data", async () => {
            const [ atom ] = getAtoms(ButtonAtom, [idComplexData]);
            const text = await atom.getText();
            expect(await atom.isVisible()).toBe(true);
            expect(text.toLowerCase()).toBe("text from an object");
        });

        it("compilable elements with custom scope", async () => {
            const [ atom ] = getAtoms(ButtonAtom, [idComplexScope]);
            const text = await atom.getText();
            expect(await atom.isVisible()).toBe(true);
            expect(text.toLowerCase()).toBe("text from a scope");
        });
    });

    describe("should react on change", () => {

        beforeEach(prepare);

        it("of html", async () => {
            const ids = [ idComplex, idComplexData, idComplexScope ];
            const [ msgSimple, msgData, msgScope ] = getAtoms(MessageAtom, ids);

            expect(await msgSimple.isVisible()).toBe(false, "simple message visible before change");
            expect(await msgData.isVisible()).toBe(false, "data message visible before change");
            expect(await msgScope.isVisible()).toBe(false, "scope message visible before change");

            await browser.element(by.css("[id^='bnChangeTemplate']")).click();

            expect(await msgSimple.isVisible()).toBe(true, "simple message visible after change");
            expect(await msgData.isVisible()).toBe(true, "data message visible after change");
            expect(await msgScope.isVisible()).toBe(true, "scope message visible after change");
        });

        it("of scope", async () => {
            const ids = [ idComplexData, idComplexScope ];
            const [ btnData, btnScope ] = getAtoms(ButtonAtom, ids);
            await browser.element(by.css("[id^='bnChangeScope ']")).click();

            const textData = await btnData.getText();
            expect(textData.toLowerCase())
                .toBe("text from another object", "data button text after change");

            const textScope = await btnScope.getText();
            expect(textScope.toLowerCase())
                .toBe("text from another scope", "scope button text after change");
        });

    });
});
//endregion
