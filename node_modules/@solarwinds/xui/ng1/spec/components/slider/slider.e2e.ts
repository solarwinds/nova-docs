import {by, element, ElementFinder, promise} from "@solarwinds/uzi/protractor";
import {SliderAtom} from "../index.atom";
import {Atom} from "@solarwinds/uzi";
import Helpers from "../helpers";
import {IRangeResult} from "./slider.atom";

describe("USERCONTROL slider", () => {
    let singleValueSlider: SliderAtom;
    let singleSliderModelValue: ElementFinder;
    let rangeSlider: SliderAtom;
    let rangeSliderModelStartValue: ElementFinder;
    let rangeSliderModelEndValue: ElementFinder;
    let disabledRangeSlider: SliderAtom;
    let disabledSingleSlider: SliderAtom;

    /* these needs to be same as the real inputs what are in html */

    const minValue = 10;
    const maxValue = 100;
    const defaultMinRange = 1;
    const initialRange: IRangeResult = {
        start: 30,
        end: 60
    };
    const initialSingeValue: number = 50;
    const sliderOutrange: number = 800;

    const clickPrecision: number = 3;

    beforeEach(() => {
        Helpers.prepareBrowser("slider");
    });

    describe("single value slider", () => {

        describe("without steps", () => {
            beforeEach(() => {
                singleValueSlider = Atom.find(SliderAtom, "single-value-slider");
                singleSliderModelValue = element(by.id("single-value-slider-value"));
            });
            it("should have initial value set", () => {
                expect(singleValueSlider.getValue()).toBe(initialSingeValue);
            });

            it("should not have any steps at all", () => {
                expect(singleValueSlider.getSteps().count()).toBe(0);
            });

            it("should set the exact value by dragging", () => {
                let value = 40;
                singleValueSlider.dragSingleSliderToValue(value, minValue, maxValue);
                expect(singleValueSlider.getValue()).toBe(value);
            });
            it("should set the minimum value by dragging far to the left", async () => {
                await singleValueSlider.dragSingleSliderTo(-sliderOutrange);
                const val = await singleValueSlider.getValue();
                expect(val).toBe(minValue);
            });
            it("should set the maximum value by dragging far to the right", () => {
                singleValueSlider.dragSingleSliderTo(sliderOutrange);
                expect(singleValueSlider.getValue()).toBe(maxValue);
            });
            it("should set the exact value on clicking on the grey line", () => {
                const onLineValue: number = 66;

                singleValueSlider.setSingleSliderValueByLineclick(onLineValue, minValue, maxValue);
                singleValueSlider.getValue().then((value) => {
                    expect(Math.abs(value - onLineValue)).toBeLessThan(clickPrecision);
                });
            });
            it("should set the exact value on clicking on the blue line", () => {
                const val: number = 30;
                singleValueSlider.setSingleSliderValueByLineclick(val, minValue, maxValue);
                expect(singleValueSlider.getValue()).toBe(val);
            });
            it("should set the exact value on clicking on start edge", () => {
                const val: number = minValue;
                singleValueSlider.setSingleSliderValueByLineclick(val, minValue, maxValue);
                expect(singleValueSlider.getValue()).toBe(val);
            });
            it("should set the exact value on clicking on end edge", () => {
                const val: number = maxValue;
                singleValueSlider.setSingleSliderValueByLineclick(val, minValue, maxValue);
                expect(singleValueSlider.getValue()).toBe(val);
            });
            it("should remain initial value when dragging is canceled by pressing ESC", () => {
                singleValueSlider.dragSingleSliderToValue(90, minValue, maxValue, {finishDrag: false});
                singleValueSlider.cancelDragging();
                expect(singleValueSlider.getValue()).toBe(initialSingeValue);
            });
            it("should not update the model value on dragging by default", () => {
                singleValueSlider.dragSingleSliderToValue(33, minValue, maxValue, {finishDrag: false});
                singleSliderModelValue.getText().then((value: string) => {
                    expect(value).toBe(initialSingeValue.toString());
                });
            });

            describe("by touch", () => {
                it("should set the exact value by dragging", () => {
                    let value = 40;
                    singleValueSlider.dragSingleSliderToValue(value, minValue, maxValue, {useTouch: true});
                    expect(singleValueSlider.getValue()).toBe(value);
                });
                it("should set the minimum value by dragging far to the left", () => {
                    singleValueSlider.dragSingleSliderTo(-sliderOutrange, {useTouch: true});
                    expect(singleValueSlider.getValue()).toBe(minValue);
                });
                it("should set the maximum value by dragging far to the right", async () => {
                    await singleValueSlider.dragSingleSliderTo(sliderOutrange, {useTouch: true});
                    expect(singleValueSlider.getValue()).toBe(maxValue);
                });
                it("should not update the model value on dragging by default", () => {
                    singleValueSlider.dragSingleSliderToValue(33, minValue, maxValue,
                                                              {useTouch: true, finishDrag: false});
                    singleSliderModelValue.getText().then((value: string) => {
                        expect(value).toBe(initialSingeValue.toString());
                    });
                });
            });
        });
        describe("with steps defined", () => {
            const step: number = 5;
            const stepCount = Math.floor((maxValue - minValue) / step) + 1;
            beforeEach(() => {
                singleValueSlider = Atom.find(SliderAtom, "single-value-slider-with-steps");
            });
            it("should have the proper number of steps", () => {
                expect(singleValueSlider.getEndsideSteps().count()).toBe(stepCount);
            });
            it("should set the closest step value instead of the exact", () => {
                const lowerValue: number = 42;
                const upperValue: number = 43;

                singleValueSlider.dragSingleSliderToValue(lowerValue, minValue, maxValue);
                expect(singleValueSlider.getValue()).toBe(Math.round(lowerValue / step) * step);
                singleValueSlider.dragSingleSliderToValue(upperValue, minValue, maxValue);
                expect(singleValueSlider.getValue()).toBe(Math.round(upperValue / step) * step);
            });
            it("should set the minimum value by dragging far to the left", () => {
                singleValueSlider.dragSingleSliderTo(-sliderOutrange);
                expect(singleValueSlider.getValue()).toBe(minValue);
            });
            it("should set the maximum value by dragging far to the right", () => {
                singleValueSlider.dragSingleSliderTo(sliderOutrange);
                expect(singleValueSlider.getValue()).toBe(maxValue);
            });
            it("should set the rounded value to closest step when clicking on grey", () => {
                const val: number = 42;
                singleValueSlider.setSingleSliderValueByLineclick(val, minValue, maxValue);
                expect(singleValueSlider.getValue()).toBe(Math.round(val / step) * step);
            });
            it("should set the rounded value to closest step when clicking on grey", () => {
                const val: number = 73;
                singleValueSlider.setSingleSliderValueByLineclick(val, minValue, maxValue);
                expect(singleValueSlider.getValue()).toBe(Math.round(val / step) * step);
            });
            it("should set the exact value on clicking on start edge", () => {
                const val: number = minValue;
                singleValueSlider.setSingleSliderValueByLineclick(val, minValue, maxValue);
                expect(singleValueSlider.getValue()).toBe(val);
            });
            it("should set the exact value on clicking on end edge", () => {
                const val: number = maxValue;
                singleValueSlider.setSingleSliderValueByLineclick(val, minValue, maxValue);
                expect(singleValueSlider.getValue()).toBe(val);
            });
            it("should remain initial value when dragging is canceled by pressing ESC", () => {
                singleValueSlider.dragSingleSliderToValue(90, minValue, maxValue, {finishDrag: false});
                singleValueSlider.cancelDragging();
                expect(singleValueSlider.getValue()).toBe(initialSingeValue);
            });

            describe("by touch", () => {
                it("should set the closest step value instead of the exact", () => {
                    const lowerValue: number = 42;
                    const upperValue: number = 43;

                    singleValueSlider.dragSingleSliderToValue(lowerValue, minValue, maxValue, {useTouch: true});
                    expect(singleValueSlider.getValue()).toBe(Math.round(lowerValue / step) * step);
                    singleValueSlider.dragSingleSliderToValue(upperValue, minValue, maxValue, {useTouch: true});
                    expect(singleValueSlider.getValue()).toBe(Math.round(upperValue / step) * step);
                });
                it("should set the minimum value by dragging far to the left", () => {
                    singleValueSlider.dragSingleSliderTo(-sliderOutrange, {useTouch: true});
                    expect(singleValueSlider.getValue()).toBe(minValue);
                });
                it("should set the maximum value by dragging far to the right", async () => {
                    await singleValueSlider.dragSingleSliderTo(sliderOutrange, {useTouch: true});
                    expect(singleValueSlider.getValue()).toBe(maxValue);
                });
            });
        });
        describe("with update on drag", () => {
            let singleValueSliderDragUpdated: SliderAtom;
            let singleValueSliderDragUpdatedValue: ElementFinder;
            beforeEach(() => {
                singleValueSliderDragUpdated = Atom.find(SliderAtom, "single-value-slider-ondrag-update");
                singleValueSliderDragUpdatedValue = element(by.id("single-value-slider-ondrag-update-value"));
            });
            it("should update the model value during dragging", () => {
                const newValue = 66;
                singleValueSliderDragUpdated.dragSingleSliderToValue(newValue, minValue, maxValue, {finishDrag: false});
                singleValueSliderDragUpdatedValue.getText().then((value) => {
                    expect(value).toBe(newValue.toString());
                });
            });

            it("should be reverted to the previous value on cancel", () => {
                singleValueSliderDragUpdated.dragSingleSliderToValue(88, minValue, maxValue, {finishDrag: false});
                singleValueSliderDragUpdated.cancelDragging();
                singleValueSliderDragUpdated.getValue().then((value) => {
                    expect(value).toBe(initialSingeValue);
                });
            });

            describe("by touch", () => {
                it("should update the model value during dragging", () => {
                    const newValue = 66;
                    singleValueSliderDragUpdated.dragSingleSliderToValue(newValue, minValue, maxValue,
                                                                         {finishDrag: false, useTouch: true});
                    singleValueSliderDragUpdatedValue.getText().then((value) => {
                        expect(value).toBe(newValue.toString());
                    });
                });
            });
        });
    });
    describe("range slider", () => {
        describe("without steps", () => {
            beforeEach(() => {
                rangeSlider = Atom.find(SliderAtom, "range-slider");
                rangeSliderModelStartValue = element(by.id("range-slider-start-value"));
                rangeSliderModelEndValue = element(by.id("range-slider-end-value"));
            });
            it("should have initial values set", () => {
                let range: promise.Promise<IRangeResult> = rangeSlider.getRange();
                expect(range).toEqual(initialRange);
            });
            it("should not have any steps at all", () => {
                expect(rangeSlider.getSteps().count()).toBe(0);
            });

            describe("dragging the start handler", () => {
                it("far to the left should set the start value to the minimum value", () => {
                    rangeSlider.dragRangeStartTo(-sliderOutrange);
                    expect(rangeSlider.getRange()).toEqual({start: minValue, end: initialRange.end});
                });
                it("far to the right should set the start value to the end value minus the minus the min range", () => {
                    rangeSlider.dragRangeStartTo(sliderOutrange);
                    expect(rangeSlider.getRange()).toEqual({
                        start: initialRange.end - defaultMinRange,
                        end: initialRange.end
                    });
                });
                it("to exact value should set the start value to the expected value", async () => {
                    let value = 20;
                    await rangeSlider.dragRangeStartToValue(value, minValue, maxValue);
                    expect(rangeSlider.getRange()).toEqual({start: value, end: initialRange.end});
                });
                it("should remain initial value when dragging is canceled by pressing ESC", () => {
                    rangeSlider.dragRangeStartToValue(10, minValue, maxValue, {finishDrag: false});
                    rangeSlider.cancelDragging();
                    expect(rangeSlider.getRange()).toEqual(initialRange);
                });
                it("should not update the model value on dragging by default", () => {
                    rangeSlider.dragRangeStartToValue(33, minValue, maxValue, {finishDrag: false});
                    rangeSliderModelStartValue.getText().then((value: string) => {
                        expect(value).toBe(initialRange.start.toString());
                    });
                });

                describe("by touch", () => {
                    it("far to the left should set the start value to the minimum value", () => {
                        rangeSlider.dragRangeStartTo(-sliderOutrange, {useTouch: true});
                        expect(rangeSlider.getRange()).toEqual({start: minValue, end: initialRange.end});
                    });
                    it("far to the right should set the start value to the end value minus the minus the min range",
                       async () => {
                        await rangeSlider.dragRangeStartTo(sliderOutrange, {useTouch: true});
                        expect(rangeSlider.getRange()).toEqual({
                            start: initialRange.end - defaultMinRange,
                            end: initialRange.end
                        });
                    });
                    it("to exact value should set the start value to the expected value", () => {
                        let value = 20;
                        rangeSlider.dragRangeStartToValue(value, minValue, maxValue, {useTouch: true});
                        expect(rangeSlider.getRange()).toEqual({start: value, end: initialRange.end});
                    });
                    it("should not update the model value on dragging by default", () => {
                        rangeSlider.dragRangeStartToValue(33, minValue, maxValue, {finishDrag: false, useTouch: true});
                        rangeSliderModelStartValue.getText().then((value: string) => {
                            expect(value).toBe(initialRange.start.toString());
                        });
                    });
                });
            });
            describe("dragging the end handler", () => {
                it("far to the right should set the start value to the maximum value", () => {
                    rangeSlider.dragRangeEndTo(sliderOutrange);
                    expect(rangeSlider.getRange()).toEqual({start: initialRange.start, end: maxValue});
                });
                it("far to the left should set the end value to the start value plus min range", () => {
                    rangeSlider.dragRangeEndTo(-sliderOutrange);
                    expect(rangeSlider.getRange()).toEqual({
                        start: initialRange.start,
                        end: initialRange.start + defaultMinRange
                    });
                });
                it("to exact value should set the end value to the expected value", () => {
                    let value = 80;
                    rangeSlider.dragRangeEndToValue(value, minValue, maxValue);
                    expect(rangeSlider.getRange()).toEqual({start: initialRange.start, end: value});
                });
                it("should remain initial value when dragging is canceled by pressing ESC", () => {
                    rangeSlider.dragRangeEndToValue(80, minValue, maxValue, {finishDrag: false});
                    rangeSlider.cancelDragging();
                    expect(rangeSlider.getRange()).toEqual(initialRange);
                });
                it("should not update the model value on dragging by default", () => {
                    rangeSlider.dragRangeEndToValue(66, minValue, maxValue, {finishDrag: false});
                    rangeSliderModelEndValue.getText().then((value: string) => {
                        expect(value).toBe(initialRange.end.toString());
                    });
                });

               describe("by touch", () => {
                    it("far to the right should set the start value to the maximum value", async () => {
                        await rangeSlider.dragRangeEndTo(sliderOutrange, {useTouch: true});
                        expect(rangeSlider.getRange()).toEqual({start: initialRange.start, end: maxValue});
                    });
                    it("far to the left should set the end value to the start value plus min range", () => {
                        rangeSlider.dragRangeEndTo(-sliderOutrange, {useTouch: true});
                        expect(rangeSlider.getRange()).toEqual({
                            start: initialRange.start,
                            end: initialRange.start + defaultMinRange
                        });
                    });
                    it("to exact value should set the end value to the expected value", () => {
                        let value = 80;
                        rangeSlider.dragRangeEndToValue(value, minValue, maxValue, {useTouch: true});
                        expect(rangeSlider.getRange()).toEqual({start: initialRange.start, end: value});
                    });
                    it("should not update the model value on dragging by default", () => {
                        rangeSlider.dragRangeEndToValue(66, minValue, maxValue, {finishDrag: false, useTouch: true});
                        rangeSliderModelEndValue.getText().then((value: string) => {
                            expect(value).toBe(initialRange.end.toString());
                        });
                    });
                });
            });
            describe("clicking the line", () => {
                it("should set the exact value on the start side grey", () => {
                    const val: number = 10;
                    rangeSlider.setRangeStartValueByClicking(val, minValue, maxValue);
                    rangeSlider.getRange().then((result) => {
                        expect(Math.abs(result.start - val)).toBeLessThan(clickPrecision);
                    });
                });
                it("should set the exact value on the start side blue", () => {
                    const val: number = 40;
                    rangeSlider.setRangeStartValueByClicking(val, minValue, maxValue);
                    expect(rangeSlider.getRange()).toEqual({start: val, end: initialRange.end});
                });
                it("should set the exact value on the end side grey", () => {
                    const val: number = 100;
                    rangeSlider.setRangeEndValueByClicking(val, minValue, maxValue);
                    expect(rangeSlider.getRange()).toEqual({start: initialRange.start, end: val});
                });
                it("should set the exact value on the end side blue", () => {
                    const val: number = 50;
                    rangeSlider.setRangeEndValueByClicking(val, minValue, maxValue);
                    expect(rangeSlider.getRange()).toEqual({start: initialRange.start, end: val});
                });
            });
            describe("dragging the rangeline as a whole", () => {
                it("should keep the distance when dragging far to the left and start value equal to the min value",
                    async () => {
                        await rangeSlider.dragRangeLineTo(-sliderOutrange);
                        const range = await rangeSlider.getRange();

                        expect(range.end - range.start).toBe(initialRange.end - initialRange.start);
                        expect(range.start).toBe(minValue);
                    });
                it("should keep the distance when dragging far to the right and end value equal to the max value",
                    () => {
                    rangeSlider.dragRangeLineTo(sliderOutrange);
                    rangeSlider.getRange().then((range: IRangeResult) => {
                        expect(range.end - range.start).toBe(initialRange.end - initialRange.start);
                        expect(range.end).toBe(maxValue);
                    });
                });
                it("should keep the distance when dragging between min and max", () => {
                    rangeSlider.dragRangeLineTo(100);
                });
                it("should be reverted if pressing cancel", () => {
                    const startValue = 10;
                    const endValue = 80;
                    rangeSlider.dragRangeStartToValue(startValue, minValue, maxValue);
                    rangeSlider.dragRangeEndToValue(endValue, minValue, maxValue);
                    rangeSlider.dragRangeLineTo(sliderOutrange, false);
                    rangeSlider.cancelDragging();
                    expect(rangeSlider.getRange()).toEqual({start: startValue, end: endValue});
                });
            });
        });
        describe("with steps", () => {
            const step: number = 10;
            const stepCount = Math.floor((maxValue - minValue) / step) + 1;

            beforeEach(() => {
                rangeSlider = Atom.find(SliderAtom, "range-slider-with-steps");
            });
            it("should have the proper number of steps", () => {
                expect(rangeSlider.getEndsideSteps().count()).toBe(stepCount);
                expect(rangeSlider.getStartsideSteps().count()).toBe(stepCount);
            });
            describe("dragging the start handler", () => {
                it("far to the left should set the start value to the minimum value", () => {
                    rangeSlider.dragRangeStartTo(-sliderOutrange);
                    expect(rangeSlider.getRange()).toEqual({start: minValue, end: initialRange.end});
                });
                it("far to the right should set the start value to the end value minus the min range", () => {
                    // as default the step is the min range
                    rangeSlider.dragRangeStartTo(sliderOutrange);
                    expect(rangeSlider.getRange()).toEqual({
                        start: initialRange.end - step,
                        end: initialRange.end
                    });
                });
                it("should set the closest step instead of the exact", () => {
                    const lowerValue: number = 23;
                    const upperValue: number = 33;
                    rangeSlider.dragRangeStartToValue(lowerValue, minValue, maxValue);
                    expect(rangeSlider.getRange())
                        .toEqual({start: Math.round((lowerValue - minValue)/step) * step
                            + minValue, end: initialRange.end});
                    rangeSlider.dragRangeStartToValue(upperValue, minValue, maxValue);
                    expect(rangeSlider.getRange())
                        .toEqual({start: Math.round((upperValue - minValue)/step) * step
                            + minValue, end: initialRange.end});
                });
                it("should remain initial value when dragging is canceled by pressing ESC", () => {
                    rangeSlider.dragRangeStartToValue(10, minValue, maxValue, {finishDrag: false});
                    rangeSlider.cancelDragging();
                    expect(rangeSlider.getRange()).toEqual(initialRange);
                });

                describe("by touch", () => {
                    it("far to the left should set the start value to the minimum value", () => {
                        rangeSlider.dragRangeStartTo(-sliderOutrange, {useTouch: true});
                        expect(rangeSlider.getRange()).toEqual({start: minValue, end: initialRange.end});
                    });
                    it("far to the right should set the start value to the end value minus the min range",
                        async () => {
                            // as default the step is the min range
                            await rangeSlider.dragRangeStartTo(sliderOutrange, {useTouch: true});
                            expect(rangeSlider.getRange()).toEqual({
                                start: initialRange.end - step,
                                end: initialRange.end
                            });
                        });
                    it("should set the closest step instead of the exact", () => {
                        const lowerValue: number = 23;
                        const upperValue: number = 33;
                        rangeSlider.dragRangeStartToValue(lowerValue, minValue, maxValue, {useTouch:true});
                        expect(rangeSlider.getRange())
                            .toEqual({start: Math.round((lowerValue - minValue)/step) * step
                                + minValue, end: initialRange.end});
                        rangeSlider.dragRangeStartToValue(upperValue, minValue, maxValue, {useTouch: true});
                        expect(rangeSlider.getRange())
                            .toEqual({start: Math.round((upperValue - minValue)/step) * step
                                + minValue, end: initialRange.end});
                    });
                });
            });
            describe("dragging the end handler", () => {
                it("far to the right should set the start value to the maximum value", () => {
                    rangeSlider.dragRangeEndTo(sliderOutrange);
                    expect(rangeSlider.getRange()).toEqual({start: initialRange.start, end: maxValue});
                });
                it("far to the left should set the end value to the start value plus the min range", () => {
                    // as default the step is the min range
                    rangeSlider.dragRangeEndTo(-sliderOutrange);
                    expect(rangeSlider.getRange()).toEqual({
                        start: initialRange.start,
                        end: initialRange.start + step
                    });
                });
                it("should set the closest step instead of the exact", () => {
                    const lowerValue: number = 75;
                    const upperValue: number = 81;

                    rangeSlider.dragRangeEndToValue(lowerValue, minValue, maxValue);
                    expect(rangeSlider.getRange()).toEqual({start: initialRange.start,
                        end: Math.round((lowerValue - minValue)/step) * step + minValue});

                    rangeSlider.dragRangeEndToValue(upperValue, minValue, maxValue);
                    expect(rangeSlider.getRange()).toEqual({start: initialRange.start,
                        end: Math.round((upperValue - minValue)/step) * step + minValue});
                });
                it("should remain initial value when dragging is canceled by pressing ESC", () => {
                    rangeSlider.dragRangeEndToValue(80, minValue, maxValue, {finishDrag: false});
                    rangeSlider.cancelDragging();
                    expect(rangeSlider.getRange()).toEqual(initialRange);
                });

                describe("by touch", () => {
                    it("far to the right should set the start value to the maximum value", async () => {
                        await rangeSlider.dragRangeEndTo(sliderOutrange, {useTouch: true});
                        expect(rangeSlider.getRange()).toEqual({start: initialRange.start, end: maxValue});
                    });
                    it("far to the left should set the end value to the start value plus the min range", () => {
                        // as default the step is the min range
                        rangeSlider.dragRangeEndTo(-sliderOutrange, {useTouch: true});
                        expect(rangeSlider.getRange()).toEqual({
                            start: initialRange.start,
                            end: initialRange.start + step
                        });
                    });
                    it("should set the closest step instead of the exact", () => {
                        const lowerValue: number = 75;
                        const upperValue: number = 81;

                        rangeSlider.dragRangeEndToValue(lowerValue, minValue, maxValue, {useTouch: true});
                        expect(rangeSlider.getRange()).toEqual({start: initialRange.start,
                            end: Math.round((lowerValue - minValue)/step) * step + minValue});

                        rangeSlider.dragRangeEndToValue(upperValue, minValue, maxValue, {useTouch: true});
                        expect(rangeSlider.getRange()).toEqual({start: initialRange.start,
                            end: Math.round((upperValue - minValue)/step) * step + minValue});
                    });
                });
            });
            describe("clicking the line", () => {
                it("should set the rounded value on the start side grey", () => {
                    const val: number = 20;
                    const roundedVal: number = Math.round((val - minValue)/step) * step + minValue;
                    rangeSlider.setRangeStartValueByClicking(val, minValue, maxValue);
                    expect(rangeSlider.getRange()).toEqual({start: roundedVal, end: initialRange.end});
                });
                it("should set the exact value on the start side blue", () => {
                    const val: number = 45;
                    const roundedVal: number = Math.round((val - minValue)/step) * step + minValue;
                    rangeSlider.setRangeStartValueByClicking(val, minValue, maxValue);
                    expect(rangeSlider.getRange()).toEqual({start: roundedVal, end: initialRange.end});
                });
                it("should set the exact value on the end side grey", () => {
                    const val: number = 85;
                    const roundedVal: number = Math.round((val - minValue)/step) * step + minValue;
                    rangeSlider.setRangeEndValueByClicking(val, minValue, maxValue);
                    expect(rangeSlider.getRange()).toEqual({start: initialRange.start, end: roundedVal});
                });
                it("should set the exact value on the end side blue", () => {
                    const val: number = 55;
                    const roundedVal: number = Math.round((val - minValue)/step) * step + minValue;
                    rangeSlider.setRangeEndValueByClicking(val, minValue, maxValue);
                    expect(rangeSlider.getRange()).toEqual({start: initialRange.start, end: roundedVal});
                });
            });
            describe("dragging the rangeline as a whole", () => {
                it("should keep the distance when dragging far to the left", () => {
                    rangeSlider.dragRangeLineTo(-sliderOutrange);
                    rangeSlider.getRange().then((range: IRangeResult) => {
                        expect(range.end - range.start).toBe(initialRange.end - initialRange.start);
                    });
                });
                it("should keep the distance when dragging far to the right", () => {
                    rangeSlider.dragRangeLineTo(sliderOutrange);
                    rangeSlider.getRange().then((range: IRangeResult) => {
                        expect(range.end - range.start).toBe(initialRange.end - initialRange.start);
                    });
                });
                it("should keep the distance when dragging between min and max", () => {
                    rangeSlider.dragRangeLineTo(100);
                });
            });
        });
        describe("with min range", () => {
            const minRange: number = 10;
            beforeEach(() => {
                rangeSlider = Atom.find(SliderAtom, "range-slider-with-min-range");
            });
            describe("dragging the start handler", () => {
                it("far to the right should set the start value based on min-range property", () => {
                    rangeSlider.dragRangeStartTo(sliderOutrange);
                    expect(rangeSlider.getRange()).toEqual({start: 8, end: 18});
                });
            });
            describe("dragging the end handler", () => {
                it("far to the left should set the end value to based on the min-range property", () => {
                    rangeSlider.dragRangeEndTo(-sliderOutrange);
                    expect(rangeSlider.getRange()).toEqual({start: 2, end: 12});
                });
            });
            describe("clicking the line", () => {
                it("should set the exact value on the start side blue", () => {
                    const val: number = 10;
                    rangeSlider.setRangeStartValueByClicking(val, 0, 20);
                    expect(rangeSlider.getRange()).toEqual({start: 8, end: 18});
                });
                it("should set the exact value on the end side blue", () => {
                    const val: number = 10;
                    rangeSlider.setRangeEndValueByClicking(val, 0, 20);
                    expect(rangeSlider.getRange()).toEqual({start: 2, end: 12});
                });
            });

            describe("by touch", () => {
                describe("dragging the start handler", () => {
                    it("far to the right should set the start value based on min-range property", async () => {
                        await rangeSlider.dragRangeStartTo(sliderOutrange, {useTouch: true});
                        expect(rangeSlider.getRange()).toEqual({start: 8, end: 18});
                    });
                });
                describe("dragging the end handler", () => {
                    it("far to the left should set the end value to based on the min-range property", () => {
                        rangeSlider.dragRangeEndTo(-sliderOutrange, {useTouch: true});
                        expect(rangeSlider.getRange()).toEqual({start: 2, end: 12});
                    });
                });
            });
        });
        describe("with update on drag", () => {
            let rangeValueSliderDragUpdated: SliderAtom;
            let rangeValueSliderDragUpdatedStartValue: ElementFinder;
            let rangeValueSliderDragUpdatedEndValue: ElementFinder;

            beforeEach(() => {
                rangeValueSliderDragUpdated = Atom.find(SliderAtom, "range-slider-ondrag-update");
                rangeValueSliderDragUpdatedStartValue = element(by.id("range-slider-ondrag-update-start-value"));
                rangeValueSliderDragUpdatedEndValue = element(by.id("range-slider-ondrag-update-end-value"));
            });
            it("should update the model start value during dragging first button", () => {
                const newValue = 22;
                rangeValueSliderDragUpdated.dragRangeStartToValue(newValue, minValue, maxValue, {finishDrag: false});
                rangeValueSliderDragUpdatedStartValue.getText().then((value) => {
                    expect(value).toBe(newValue.toString());
                });
            });
            it("should update the model end value during dragging end button", () => {
                const newValue = 66;
                rangeValueSliderDragUpdated.dragRangeEndToValue(newValue, minValue, maxValue, {finishDrag: false});
                rangeValueSliderDragUpdatedEndValue.getText().then((value) => {
                    expect(value).toBe(newValue.toString());
                });
            });
            it("should be reverted to the previous value on cancel", () => {
                rangeValueSliderDragUpdated.dragRangeEndToValue(88, minValue, maxValue, {finishDrag: false});
                rangeValueSliderDragUpdated.cancelDragging();
                rangeValueSliderDragUpdated.getRange().then((range)=> {
                    expect(range.end).toBe(initialRange.end);
                });
            });

            describe("by touch", () => {
                it("should update the model start value during dragging first button", () => {
                    const newValue = 22;
                    rangeValueSliderDragUpdated.dragRangeStartToValue(newValue, minValue, maxValue,
                                                                      {useTouch: true, finishDrag: false});
                    rangeValueSliderDragUpdatedStartValue.getText().then((value) => {
                        expect(value).toBe(newValue.toString());
                    });
                });
                it("should update the model end value during dragging end button", () => {
                    const newValue = 66;
                    rangeValueSliderDragUpdated.dragRangeEndToValue(newValue, minValue, maxValue,
                                                                    {useTouch: true, finishDrag: false});
                    rangeValueSliderDragUpdatedEndValue.getText().then((value) => {
                        expect(value).toBe(newValue.toString());
                    });
                });
            });
        });
    });
    describe("disabled", () => {
        beforeEach(() => {
            disabledRangeSlider =  Atom.find(SliderAtom, "disabled-range-slider");
            disabledSingleSlider = Atom.find(SliderAtom, "disabled-single-value-slider");
        });
        it("range slider should not be draggable", () => {
            disabledRangeSlider.dragRangeEndTo(10);
            disabledRangeSlider.dragRangeStartTo(-10);
            expect(disabledRangeSlider.getRange()).toEqual(initialRange);
        });
        it("single value slider should not be draggable", () => {
            disabledSingleSlider.dragSingleSliderTo(20);
            expect(disabledSingleSlider.getValue()).toBe(initialSingeValue);
        });

        describe("by touch", () => {
            it("range slider should not be draggable", () => {
                disabledRangeSlider.dragRangeEndTo(10, {useTouch: true});
                disabledRangeSlider.dragRangeStartTo(-10, {useTouch: true});
                expect(disabledRangeSlider.getRange()).toEqual(initialRange);
            });
            it("single value slider should not be draggable", () => {
                disabledSingleSlider.dragSingleSliderTo(20, {useTouch: true});
                expect(disabledSingleSlider.getValue()).toBe(initialSingeValue);
            });
        });
    });

    describe("single-slider with text input", () => {
        let slider: SliderAtom;
        describe("and without steps", () => {
            beforeEach(() => {
                slider =  Atom.find(SliderAtom, "single-value-slider-with-text");
            });

            it("should set the initial value on the text input", () => {
               expect(slider.getInputValue()).toBe(initialSingeValue);
            });
            it("should set the min value on the text input when moving far to the left", () => {
                slider.dragSingleSliderTo(-sliderOutrange);
                expect(slider.getInputValue()).toBe(minValue);
            });
            it("should set the max value on the text input when moving far to the right", () => {
                slider.dragSingleSliderTo(sliderOutrange);
                expect(slider.getInputValue()).toBe(maxValue);
            });
            it("text input between min and max should set the handle at exact position", () => {
                const newValue: number = 33;
                slider.setInputValue(newValue);
                expect(slider.getValueFromPosition(minValue, maxValue)).toBe(newValue);

            });
            it("non numeric text input should be reverted to the original value", () => {
                slider.setInputValue("bela", initialSingeValue);
                expect(slider.getInputValue()).toBe(initialSingeValue);
            });
            it("lower numeric text input then min should reverted to the min value", () => {
                const newValue: number = 5;
                slider.setInputValue(newValue, minValue);
                expect(slider.getValueFromPosition(minValue, maxValue)).toBe(minValue);
                expect(slider.getInputValue()).toBe(minValue);
            });
            it("higher numeric text input then max should reverted to the max value", () => {
                const newValue: number = 105;
                slider.setInputValue(newValue, maxValue);
                expect(slider.getValueFromPosition(minValue, maxValue)).toBe(maxValue);
                expect(slider.getInputValue()).toBe(maxValue);
            });
            it("should remain initial value when dragging is canceled by pressing ESC", async () => {
                await slider.dragSingleSliderToValue(90, minValue, maxValue, {finishDrag: false});
                await slider.cancelDragging();
                expect(slider.getInputValue()).toBe(initialSingeValue);
            });

            describe("by touch", () => {
                it("should set the min value on the text input when moving far to the left", () => {
                    slider.dragSingleSliderTo(-sliderOutrange, {useTouch: true});
                    expect(slider.getInputValue()).toBe(minValue);
                });
                it("should set the max value on the text input when moving far to the right", async () => {
                    await slider.dragSingleSliderTo(sliderOutrange, {useTouch: true});
                    expect(slider.getInputValue()).toBe(maxValue);
                });
            });
        });
        describe("and with steps", () => {
            beforeEach(() => {
                slider =  Atom.find(SliderAtom, "single-value-slider-with-steps-and-text");
            });

            it("should set the initial value on the text input", () => {
                expect(slider.getInputValue()).toBe(initialSingeValue);
            });
            it("should set the min value on the text input when moving far to the left", () => {
                slider.dragSingleSliderTo(-sliderOutrange);
                expect(slider.getInputValue()).toBe(minValue);
            });
            it("should set the max value on the text input when moving far to the right", () => {
                slider.dragSingleSliderTo(sliderOutrange);
                expect(slider.getInputValue()).toBe(maxValue);
            });
            it("text input between min and max should set the value to the closest step", () => {
                const newValue: number = 33;
                const step: number = 5;
                const expectedResult: number = Math.round(newValue / step) * step;
                slider.setInputValue(newValue, expectedResult);

                expect(slider.getValueFromPosition(minValue, maxValue)).toBe(expectedResult);
                expect(slider.getInputValue()).toBe(expectedResult);
            });
            it("non numeric text input should be reverted to the original value", () => {
                slider.setInputValue("bela", initialSingeValue);
                expect(slider.getInputValue()).toBe(initialSingeValue);
            });
            it("lower numeric text input then min should reverted to the min value", () => {
                const newValue: number = 5;
                slider.setInputValue(newValue, minValue);
                expect(slider.getValueFromPosition(minValue, maxValue)).toBe(minValue);
                expect(slider.getInputValue()).toBe(minValue);
            });
            it("higher numeric text input then max should reverted to the max value", () => {
                const newValue: number = 105;
                slider.setInputValue(newValue, maxValue);
                expect(slider.getValueFromPosition(minValue, maxValue)).toBe(maxValue);
                expect(slider.getInputValue()).toBe(maxValue);
            });
            it("should remain initial value when dragging is canceled by pressing ESC", async () => {
                await slider.dragSingleSliderToValue(90, minValue, maxValue, {finishDrag: false});
                await slider.cancelDragging();
                expect(slider.getInputValue()).toBe(initialSingeValue);
            });

            describe("by touch", () => {
                it("should set the min value on the text input when moving far to the left", () => {
                    slider.dragSingleSliderTo(-sliderOutrange, {useTouch: true});
                    expect(slider.getInputValue()).toBe(minValue);
                });
                it("should set the max value on the text input when moving far to the right", async () => {
                    await slider.dragSingleSliderTo(sliderOutrange, {useTouch: true});
                    expect(slider.getInputValue()).toBe(maxValue);
                });
            });
        });
    });
});
