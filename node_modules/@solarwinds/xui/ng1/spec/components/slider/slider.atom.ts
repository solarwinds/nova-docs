import * as protractor from "@solarwinds/uzi/protractor";
import {browser, by, ElementArrayFinder, ElementFinder, promise} from "@solarwinds/uzi/protractor";
import * as webdriver from "@solarwinds/uzi/webdriver";
import {Atom} from "@solarwinds/uzi";
import {TextboxAtom} from "../textbox/textbox.atom";
import * as _ from "lodash";

export interface IRangeResult {
    start: number;
    end: number;
}

export interface ISliderAtomOptions {
    finishDrag?: boolean;
    useTouch?: boolean;
};

export class SliderAtom extends Atom {

    public static CSS_CLASS = "xui-slider";

    private adjustedClientWidth: number;

    constructor(element: ElementFinder) {
        super(element);
        browser.executeScript(() => {
            const clientWidth = document.documentElement.clientWidth || document.body.clientWidth;
            return clientWidth;
        }).then((clientWidth: number) => {
            // The real width must be decremented by 1
            // otherwise webdriver will throw exception when you try to move touch to the edge of area width
            this.adjustedClientWidth = clientWidth - 1;
        });
    }

    // public API

    // Params:
    // value - number - distance in pixels to grag
    // finish - boolean - flag, if mouse has to release grabbed element after move is done.
    //
    public dragRangeLineTo(value: number, finish: boolean = true): promise.Promise<void> {
        const sequence: webdriver.ActionSequence =
            browser.actions()
            .mouseMove(this.getRangeLine().getWebElement())
            .mouseDown();

        if (+value) {
            this.moveMouseIteratively(sequence, +value);
        }

        if (finish) {
            sequence.mouseUp();
        }
        return sequence.perform();
    };

    public setSingleSliderValueByLineclick(value: number, min: number, max: number):promise.Promise<void> {
        return this.clickSliderLineAtValue(value, min, max);
    }
    public setRangeStartValueByClicking(value: number, min: number, max: number):promise.Promise<void> {
        return this.clickSliderLineAtValue(value, min, max, true);
    }
    public setRangeEndValueByClicking(value: number, min: number, max: number):promise.Promise<void> {
        return this.clickSliderLineAtValue(value, min, max, true, true);
    }

    public getValue(expectedValue?: number): promise.Promise<number> {
        let label = super.getElement().element(by.css(".xui-slider__lines-label.xui-slider-end-label"));
        return label.getText().then((text) => {
            return Number(text);
        });
    }
    public  getValueFromPosition(min: number, max: number): promise.Promise<number> {
        let value: number;
        let lineWidth: number;
        let handleWidth: number;
        let handleX: number;
        let lineX: number;
        return this.getRangeLine().getSize().then((lineSize) => {
            lineWidth = lineSize.width;
            return this.getRangeLine().getLocation().then((lineLocation) => {
                lineX = lineLocation.x;
                return this.getValueHandle().getSize().then((buttonSize) => {
                    handleWidth = buttonSize.width;
                    return this.getValueHandle().getLocation().then((handleLocation) => {
                        handleX = handleLocation.x - lineX;
                        let percent: number = handleX / (lineWidth - handleWidth);
                        value = (max - min) * percent + min;
                        return Math.round(value);
                    });
                });
            });
        });
    }
    public dragSingleSliderToValue(value:number, min: number, max: number, options?: ISliderAtomOptions):
            promise.Promise<void> {
        let lineWidth: number;
        let handleWidth: number;
        let handleX: number;
        let lineX: number;
        return this.getRangeLine().getSize().then((lineSize) => {
            lineWidth = lineSize.width;
            return this.getRangeLine().getLocation().then((lineLocation) => {
                lineX = lineLocation.x;
                return this.getValueHandle().getSize().then((buttonSize) => {
                    handleWidth = buttonSize.width;
                    return this.getValueHandle().getLocation().then((handleLocation) => {
                        handleX = handleLocation.x;
                        let moveTo: number =
                            (value - min) /
                            (max - min) *
                            (lineWidth - handleWidth);
                        let moveBy = moveTo - handleX + lineX;
                        moveBy = Math.round(moveBy);
                        return this.dragSingleSliderTo(moveBy, options);
                    });
                });
            });
        });
    }

    public dragSingleSliderTo(value:number, options?: ISliderAtomOptions):promise.Promise<void> {
        return this.dragHandleTo(this.getValueHandle().getWebElement(), value, options);
    }

    public dragRangeStartTo(value:number, options?: ISliderAtomOptions):promise.Promise<void> {
        return this.dragHandleTo(this.getRangeStartHandle().getWebElement(), value, options);
    }

    public dragRangeEndTo(value:number, options?: ISliderAtomOptions):promise.Promise<void> {
        return this.dragHandleTo(this.getRangeEndHandle().getWebElement(), value, options);
    }

    public dragRangeStartToValue(value:number, min: number, max: number, options?: ISliderAtomOptions):
            promise.Promise<void> {
        let lineWidth: number;
        let handleWidth: number;
        let handleX: number;
        let lineX: number;
        return this.getRangeLine().getSize().then((lineSize) => {
            lineWidth = lineSize.width;
            return this.getRangeLine().getLocation().then((lineLocation) => {
                lineX = lineLocation.x;
                return this.getRangeStartHandle().getSize().then((buttonSize) => {
                    handleWidth = buttonSize.width;
                    return this.getRangeStartHandle().getLocation().then((handleLocation) => {
                        handleX = handleLocation.x;
                        let moveTo: number =
                            (value - min) /
                            (max - min) *
                            (lineWidth - 2 * handleWidth);
                        let moveBy = moveTo - handleX + lineX;
                        moveBy = Math.round(moveBy);
                        return this.dragRangeStartTo(moveBy, options);
                    });
                });
            });
        });
    }

    public dragRangeEndToValue(value:number, min: number, max: number, options?: ISliderAtomOptions):
            promise.Promise<void> {
        let lineWidth: number;
        let handleWidth: number;
        let handleX: number;
        let lineX: number;
        return this.getRangeLine().getSize().then((lineSize) => {
            lineWidth = lineSize.width;
            return this.getRangeLine().getLocation().then((lineLocation) => {
                lineX = lineLocation.x;
                return this.getRangeEndHandle().getSize().then((buttonSize) => {
                    handleWidth = buttonSize.width;
                    return this.getRangeEndHandle().getLocation().then((handleLocation) => {
                        handleX = handleLocation.x;
                        let moveTo: number =
                            (value - min) /
                            (max - min) *
                            (lineWidth - 2 * handleWidth) +
                            handleWidth;
                        let moveBy = moveTo - handleX + lineX;
                        moveBy = Math.round(moveBy);
                        return this.dragRangeEndTo(moveBy, options);
                    });
                });
            });
        });
    }

    public cancelDragging(): promise.Promise<void> {
        return browser.actions().sendKeys(protractor.Key.ESCAPE).perform();
    }

    public getRange(): promise.Promise<IRangeResult> {
        let startLabel = super.getElement().element(by.css(".xui-slider__lines-label.xui-slider-first-label"));
        let endLabel = super.getElement().element(by.css(".xui-slider__lines-label.xui-slider-end-label"));
        return startLabel.getText().then((startLabelText) => {
            return endLabel.getText().then((endLabelText) => {
                return {
                    start: Number(startLabelText),
                    end: Number(endLabelText)
                };
            });
        });
    }

    public getInputValue(): promise.Promise<number> {
        const input: TextboxAtom = Atom.findIn(TextboxAtom, this.getElement());
        return input.getText().then((value) => {
            return Number(value);
        });
    }
    public setInputValue(value: any, expectedValue: any = null): void {
        const expected = expectedValue || value;
        const input: TextboxAtom = Atom.findIn(TextboxAtom, this.getElement());
        input.acceptText(protractor.Key.BACK_SPACE + protractor.Key.BACK_SPACE + value.toString());
        browser.wait(() => {
            return this.getInputValue().then((result) => {
                return result === expected;
            });
        }, 1000);
    }

    public getSteps(): ElementArrayFinder {
        return super.getElement().all(by.css(".xui-slider__lines-step"));
    }
    public getStartsideSteps(): ElementArrayFinder {
        return super.getElement().all(by.css(".xui-slider__lines-startside-steps .xui-slider__lines-step"));
    }
    public getEndsideSteps(): ElementArrayFinder {
        return super.getElement().all(by.css(".xui-slider__lines-endside-steps .xui-slider__lines-step"));
    }

    // internal methods

    private defaultOptions: ISliderAtomOptions = {
        finishDrag: true,
        useTouch: false
    };

    private getValueHandle(): ElementFinder {
        return super.getElement().element(by.css(".xui-slider__button.xui-slider-end-button"));
    }

    private getRangeStartHandle(): ElementFinder {
        return super.getElement().element(by.css(".xui-slider__button.xui-slider-first-button"));
    }

    private getRangeEndHandle(): ElementFinder {
        return super.getElement().element(by.css(".xui-slider__button.xui-slider-end-button"));
    }

    private getRangeLine(): ElementFinder {
        return super.getElement().element(by.css(".xui-slider__lines"));
    }

    private clickSliderLineAtValue(value:number, min:number, max:number,
                                   isRange:boolean = false, isRangeEnd: boolean = false,
                                   options?: ISliderAtomOptions):promise.Promise<void> {
        let lineLength: number;
        let lineThickness: number;
        let lineX: number;
        let lineY: number;
        let handlerDiameter: number;
        let rangeLine = this.getRangeLine();

        options = _.defaults({}, options, this.defaultOptions);

        return rangeLine.getSize().then((lineSize) => {
            lineLength = lineSize.width;
            lineThickness = lineSize.height;
            return this.getRangeLine().getLocation().then((lineLocation) => {
                lineX = lineLocation.x;
                lineY = lineLocation.y;
                return this.getRangeEndHandle().getSize().then((buttonSize) => {
                    handlerDiameter = buttonSize.width;
                    const usefulLineDimension: number = isRange ?
                        lineLength - 2 * handlerDiameter :
                        lineLength - handlerDiameter;
                    let clickTo: number =
                        (value - min) /
                        (max - min) *
                        usefulLineDimension;

                    // protractor counts the origin from the center instead of it's docs
                    clickTo -= lineLength / 2;
                    // within slider there is a radius offset for better user experience
                    clickTo += handlerDiameter / 2;
                    if (isRange && isRangeEnd) {
                        clickTo += handlerDiameter;
                    }

                    clickTo = Math.round(clickTo);

                    let promise: promise.Promise<void>;

                    if (options.useTouch) {
                        promise = browser.touchActions()
                            .tapAndHold({x: lineX + clickTo, y: lineY})
                            .release({x: lineX + clickTo, y: lineY})
                            .perform();
                    } else {
                        promise = browser.actions()
                            .mouseMove(this.getRangeLine().getWebElement())
                            .mouseMove({x: clickTo, y: 0})
                            .click()
                            .perform();
                    }

                    return promise;
                });
            });
        });
    }

    private dragHandleTo(handle: protractor.WebElement, value:number, options?: ISliderAtomOptions):
            promise.Promise<void> {
        options = _.defaults({}, options, this.defaultOptions);

        if (options.useTouch) {
            return handle.getLocation()
                .then((location: webdriver.ILocation) => {
                    return handle.getSize()
                        .then((size: webdriver.ISize) => {
                            return {location, size};
                        });
                })
                .then(({location, size}: { location: webdriver.ILocation, size: webdriver.ISize }) => {
                    location.y += size.height / 2;
                    let destination = {x: location.x + value, y: location.y};
                    this.makeForTouch(location);
                    this.makeForTouch(destination);

                    let sequence = browser.touchActions()
                        .tapAndHold(location)
                        .move(destination);

                    if (options.finishDrag) {
                        sequence.release(destination);
                    }

                    return sequence.perform();
                });

        } else {
            let sequence = browser.actions()
                .mouseMove(handle)
                .mouseDown();

            if (+value) {
                this.moveMouseIteratively(sequence, +value);
            }

            if (options.finishDrag) {
                sequence.mouseUp();
            }

            return sequence.perform();
        }
    }

    // location for touch events must by rounded to int and bounded to viewport without vertical scrollbar
    // "adjustedClientWidth" fits this
    private makeForTouch(location: webdriver.ILocation): void {
        location.x = Math.min(Math.max(Math.round(location.x), 0), this.adjustedClientWidth);
        location.y = Math.max(Math.round(location.y), 0);
    }

    // Adds set of mouse iteratively moves to pass required px-distance ("value") to given sequence.
    // It splits all distance into steps to prevent moving over start/end of slider
    // without being located at it.
    //
    // More:
    // An issue it solves is when the end of move is out of item container, no move happens at all.
    private moveMouseIteratively(sequence: webdriver.ActionSequence, value: number): void {
        // These values are empiric:
        const maxAllowedStep = 10; // (pixels) max step
        const minAllowedAmountOfSteps = 10;
        const maxIterations = 400;

        let iterationInd = 0;
        let goneTrack = 0;
        // <direction (1 or -1)> * <size of step>
        // limitation of step size prevails to amount of steps
        let step = (Math.sign(value) || 1)
            * Math.round(Math.min(maxAllowedStep, Math.abs(value) / minAllowedAmountOfSteps));

        while (Math.abs(goneTrack) < Math.abs(value)
            && (maxIterations > iterationInd)) {

            // reduce step up to one-pixel
            // not to step over end of slider range
            if ((Math.abs(value) - Math.abs(goneTrack)) <= Math.abs(step)) {
                step = Math.sign(step);
            }

            iterationInd++;
            goneTrack += step;

            sequence.mouseMove({x: step, y: 0});
        }
    }
}
