import {by, element, promise} from "@solarwinds/uzi/protractor";
import Helpers from "../helpers";
import {ChicletsAtom} from "../index.atom";
import {Atom} from "@solarwinds/uzi";
import * as _ from "lodash";

describe("USERCONTROL chiclets", () => {

    const itemsSource = {
        "statusId": ["downId", "criticalId", "warningId", "okId"],
        "vendorId": ["ciscoId", "hpId", "uniperId"]
    };
    const flatItemsSource = ["downId", "criticalId", "warningId", "okId"];

    const groupsCount = 2, // Object.keys(itemsSource).length
        groupItemsCount = 7, // Object.keys(itemsSource).reduce((p,c) => p+itemsSource[c].length,0)
        itemsCount = 4; // flatItemsSource.length;

    const parsedGroupNames = ["Status", "Vendor"];

    const parsedChickletNamesForGroups = ["Down", "Critical", "Warning", "Ok", "Cisco", "Hp", "Uniper"];
    const parsedChickletNamesForFlat = ["Down", "Critical", "Warning", "Ok"];

    describe("when chiclets are in horizontal mode with groups", () => {
        basicGroupTestCase("uc1");
    });

    describe("when chiclets are in horizontal mode without groups", () => {
        basicFlatTestCase("uc2");
    });

    describe("when chiclets are in vertical mode with groups", () => {
        basicGroupTestCase("uc3");
    });

    describe("when chiclets are in vertical mode without groups", () => {
        basicFlatTestCase("uc4");
    });

    function basicGroupTestCase(elementClassName:string) {
        let atom: ChicletsAtom;

        beforeEach(() => {
            Helpers.prepareBrowser("chiclets");
            atom = ChicletsAtom.findIn(ChicletsAtom, element(by.className(elementClassName)));
        });

        it("should have " + groupsCount + " filter groups on the page", () => {
            expect(atom.getChicletsGroupCount()).toBe(groupsCount);
        });

        it("should have correct group names with specified item-label-fn", () => {
            expect(atom.getChicletsGroupNames()).toEqual(parsedGroupNames);
        });

        it("should have correct chicklets names with specified item-label-fn", () => {
            expect(atom.getChicletsNames()).toEqual(parsedChickletNamesForGroups);
        });

        it("should have " + groupItemsCount + " filter values on the page", () => {
            expect(atom.getChicletsCount()).toBe(groupItemsCount);
        });

        it("should have correct number near 'Applied Filters' string", () => {
            expect(atom.getChicletsQuantityFromLabel()).toBe(groupItemsCount);
        });

        it("one filter should be removed", () => {
            atom.removeItem(0);
            expect(atom.getChicletsCount()).toBe(groupItemsCount - 1);
        });

        it("one group label should be removed when all items are unchecked", () => {
            _.times(itemsCount, () => atom.removeItem(0));
            expect(atom.getChicletsGroupCount()).toBe(groupsCount - 1);
        });

        it("should disappear after unchecking all filters", () => {
            expect(atom.isVisible()).toEqual(true);
            _.times(groupItemsCount, () => atom.removeItem(0));
            expect(atom.isVisible()).toEqual(false);
        });

        it("should disappear when 'clear all' link is used (= no filters are applied)", () => {
            atom.clearAll();
            expect(atom.isVisible()).toEqual(false);
        });

        it("itemsSource should be empty when 'clear all' is used", () => {
            const pre = element(by.id("itemsSourcePre"));
            atom.clearAll();
            pre.getText().then((text) => {
                let dataSource = JSON.parse(text);
                expect(dataSource.statusId.length).toBe(0);
                expect(dataSource.vendorId.length).toBe(0);
            });
        });
    }

    function basicFlatTestCase(elementClassName:string) {
        let atom: ChicletsAtom;

        beforeEach(() => {
            Helpers.prepareBrowser("chiclets");
            atom = Atom.findIn(ChicletsAtom, element(by.className(elementClassName)));
        });

        it("should have no filter groups on the page", () => {
            expect(atom.getChicletsGroupCount()).toBe(0);
        });

        it("should have correct chicklets names with specified item-label-fn", () => {
            expect(atom.getChicletsNames()).toEqual(parsedChickletNamesForFlat);
        });

        it("should have " + itemsCount + " filter values on the page", () => {
            expect(atom.getChicletsCount()).toBe(itemsCount);
        });

        it("one filter should be removed", () => {
            atom.removeItem(0);
            expect(atom.getChicletsCount()).toBe(itemsCount - 1);
        });

        it("should disappear when when all items are unchecked", () => {
            expect(atom.isVisible()).toEqual(true);
            _.times(itemsCount, () => atom.removeItem(0));
            expect(atom.isVisible()).toEqual(false);
        });

        it("should disappear when 'clear all' link is used (= no filters are applied)", () => {
            atom.clearAll();
            expect(atom.isVisible()).toEqual(false);
        });

        it("itemsSource should be empty when 'clear all' is used", () => {
            const pre = element(by.id("flatItemsSourcePre"));
            atom.clearAll();
            expect(pre.getText()).toBe("[]");
        });
    }
});
