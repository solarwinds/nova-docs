import * as protractor from "@solarwinds/uzi/protractor";
import {by, element, ElementFinder, promise} from "@solarwinds/uzi/protractor";
import {Atom} from "@solarwinds/uzi";
import {ButtonAtom} from "../index.atom";

export class TextboxAtom extends Atom {
    public static CSS_CLASS = "xui-textbox";

    //error styles are applied to the form consistently; styles applied to
    //input boxes are not
    static isFormValidWith(validatorName: string): promise.Promise<boolean> {
        let formInvalidStyle = "ng-form.ng-invalid-" + validatorName;
        return element.all(by.css(formInvalidStyle))
            .count()
            .then((count: number) => {
                return count === 0;
            });
    }

    public isInWarningState = (): Promise<boolean> => {
        return this.hasClass("has-warning");
    };

    public getInput(): ElementFinder {
        return super.getElement().element(by.className("form-control"));
    }

    public getText(): promise.Promise<string> {
        // tslint:disable-next-line:max-line-length
        // https://github.com/angular/protractor/blob/master/docs/faq.md#the-result-of-gettext-from-an-input-element-is-always-empty
        return this.getInput().getAttribute("value");
    }

    public getNumericUpButton(): ButtonAtom {
        let buttonSpan = super.getElement().element(by.className("xui-textbox__up-button"));
        return Atom.findIn(ButtonAtom, buttonSpan);
    }

    public getNumericDownButton(): ButtonAtom {
        let buttonSpan = super.getElement().element(by.className("xui-textbox__down-button"));
        return Atom.findIn(ButtonAtom, buttonSpan);
    }

    public acceptText(text: string): promise.Promise<void> {
        return this.getInput().sendKeys(text, protractor.Key.ENTER);
    }

    public clearText(): promise.Promise<void> {
        return this.getInput().clear();
    }

    /**
     * Gets a boolean indicating whether all validators are valid
     */
    public isValid(): promise.Promise<boolean> {
        const xpath = `.//div[contains(@class, 'xui-validation')]`;
        const validationElem = this.getElement().element(by.xpath(xpath));

        // note: since using ng-show for changing visibility, we consider 
        //  textbox to be valid in case it is not displayed
        return validationElem.isDisplayed().then(isDisplayed => !isDisplayed);
    }

    /**
     * Gets a number of displayed validation messages
     */
    public async getValidationMessagesCount(): Promise<number> {
        const xpath = `.//div[contains(@class, 'xui-validation')]/*[@ng-message]`;
        const messages = this.getElement().all(by.xpath(xpath));
        const count = await messages.count();

        let displayedCount = 0;
        for (let i = 0; i < count; i++) {
            if (await messages.get(i).isDisplayed()) {
                displayedCount++;
            }
        }

        return displayedCount;
    }

    /**
     * Gets a message of ng-message element
     * @returns Text of validation message if present on page, otherwise undefined
     */
    public getValidationMessage(ngMessage: string): promise.Promise<string> {
        const xpath = `.//div[contains(@class, 'xui-validation')]/*[@ng-message='${ngMessage}']`;
        const validatorElem = this.getElement().element(by.xpath(xpath));

        // note: isPresent() check is here to prevent "NoSuchElementError" before getting the actual text
        return validatorElem.isPresent().then(isPresent => {
            if (!isPresent) {
                return undefined;
            }

            return validatorElem.getText();
        });
    }
}
