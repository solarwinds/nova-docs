import {browser, by, element, promise} from "@solarwinds/uzi/protractor";
import Helpers from "../helpers";
import {Atom} from "@solarwinds/uzi";
import {DropdownAtom} from "../index.atom";

describe("USERCONTROL Dropdown >", () => {
    beforeEach(() => {
        Helpers.prepareBrowser("dropdown");
    });

    describe("dropdown >", ()=> {
        describe("basic >", ()=> {
            let ddBasic: DropdownAtom;

            beforeEach(()=> {
                ddBasic = Atom.find(DropdownAtom, "dropdownBasic");
            });

            it("contains expected items", () => {
                expect(ddBasic.getNumberOfItems()).toBe(20);
                expect(ddBasic.getItemText(0)).toBe("Item 1");
                expect(ddBasic.getItemText(19)).toBe("Item 20");
            });

            describe("when a value is picked from dropdown, it", ()=> {
                it("should display selected item on dropdown button", () => {
                    let target = "Item 2";
                    ddBasic.select(target);
                    expect(ddBasic.getCurrentValue()).toEqual(target);
                });

                it("should mark the selected item in the dropdown menu", ()=> {
                    let target = "Item 2";
                    ddBasic.select(target);
                    expect(ddBasic.getCurrentValue()).toEqual(target);

                    let items = ddBasic.getItemsWithClass("xui-listitem--selected");
                    ddBasic.click();
                    expect(items.count()).toEqual(1);
                    expect(items.get(0).getText()).toEqual("Item 2");
                });
            });
        });

        describe("complex >", ()=> {
            let ddComplex: DropdownAtom;

            beforeEach(()=> {
                ddComplex = Atom.find(DropdownAtom, "dropdownComplex");
            });

            it("applies the correct template", () => {
                expect(ddComplex.getItemsWithNestedClass("custom-template-class").count()).toBe(5);
            });
        });

        describe("required >", ()=> {
            let ddRequired: DropdownAtom;

            beforeEach(()=> {
                ddRequired = Atom.find(DropdownAtom, "dropdownRequired");
            });

            it("should display placeholder", () => {
                const placeholder = "(select item)";
                expect(ddRequired.getPlaceholder()).toBe(placeholder);
            });

            it("should not display selection-required hints when pristine when is-required is true", () => {
                expect(ddRequired.isValidationTextDisplayed()).toBe(false);
                expect(ddRequired.isRequiredStyleDisplayed()).toBe(false);
            });

            it("should not display selection-required hints when focused when is-required is true", () => {
                // pristine
                expect(ddRequired.isValidationTextDisplayed()).toBe(false);
                expect(ddRequired.isRequiredStyleDisplayed()).toBe(false);
                // focus
                ddRequired.click();
                expect(ddRequired.isValidationTextDisplayed()).toBe(false);
                expect(ddRequired.isRequiredStyleDisplayed()).toBe(false);
            });

            it("should display selection-required hints on-blur when is-required is true", () => {
                // pristine
                expect(ddRequired.isValidationTextDisplayed()).toBe(false);
                expect(ddRequired.isRequiredStyleDisplayed()).toBe(false);
                // focus
                ddRequired.click();
                expect(ddRequired.isValidationTextDisplayed()).toBe(false);
                expect(ddRequired.isRequiredStyleDisplayed()).toBe(false);
                // blur
                ddRequired.getLabelElement().click();
                expect(ddRequired.isValidationTextDisplayed()).toBe(true);
                expect(ddRequired.isRequiredStyleDisplayed()).toBe(true);
                // focus again
                ddRequired.click();
                expect(ddRequired.isValidationTextDisplayed()).toBe(false);
                expect(ddRequired.isRequiredStyleDisplayed()).toBe(false);
                // blur again
                ddRequired.getLabelElement().click();
                expect(ddRequired.isValidationTextDisplayed()).toBe(true);
                expect(ddRequired.isRequiredStyleDisplayed()).toBe(true);
            });

            it("should not indicate invalid on-blur if item is selected", () => {
                // pristine
                expect(ddRequired.isValidationTextDisplayed()).toBe(false);
                expect(ddRequired.isRequiredStyleDisplayed()).toBe(false);
                // focus and select
                ddRequired.select("Item 5");
                expect(ddRequired.isValidationTextDisplayed()).toBe(false);
                expect(ddRequired.isRequiredStyleDisplayed()).toBe(false);
                // blur after select
                ddRequired.getLabelElement().click();
                expect(ddRequired.isValidationTextDisplayed()).toBe(false);
                expect(ddRequired.isRequiredStyleDisplayed()).toBe(false);
                // focus again
                ddRequired.click();
                expect(ddRequired.isValidationTextDisplayed()).toBe(false);
                expect(ddRequired.isRequiredStyleDisplayed()).toBe(false);
                // blur again
                ddRequired.getLabelElement().click();
                expect(ddRequired.isValidationTextDisplayed()).toBe(false);
                expect(ddRequired.isRequiredStyleDisplayed()).toBe(false);
            });
        });

        describe("justified >", ()=> {
            it("should not indicate invalid on-blur if item is selected", () => {
                const ddJustified = Atom.find(DropdownAtom, "dropdownjustified");
                ddJustified.getGroupElement().getSize().then((directiveSize: any) => {
                    element(by.className("xui-dropdown--justified")).getSize().then((containerSize: any) => {
                        expect(directiveSize.width).toEqual(containerSize.width);
                    });
                });
            });
        });

        describe("divided", () => {
            it("should divide items based on their separator property is set to true", () => {
                const ddDivided = Atom.find(DropdownAtom, "dropdownWithSeparators");
                ddDivided.click().then( () => {
                    ddDivided.getDividers().count().then((count: number) => {
                        expect(count).toEqual(2);
                    });
                });
            });
        });

    });

    describe("combobox >", ()=> {
        let combobox: DropdownAtom;

        beforeEach(() => {
            combobox = Atom.find(DropdownAtom, "combobox");
        });

        it("should display initial value in textbox", ()=> {
            expect(combobox.getInputValue()).toBe("unset");
        });

        it("should change the model after changing the text input", ()=> {
            combobox.clearText();
            const something = "There is something in the way she moves ...";
            combobox.acceptText(something);
            expect(combobox.getInputValue()).toBe(something);
            expect(element(by.id("combobox-model")).getText()).toBe(something);
        });

        it("should change the input value and model after clicking on dropdown item", ()=> {
            combobox.select("Item 1");

            expect(combobox.getInputValue()).toBe("Item 1");
            expect(element(by.id("combobox-model")).getText()).toBe("Item 1");
        });

        describe("Zooming: it should always show the selected element >", ()=> {

            it("after scrolling to the bottom and selected item is at the top", () => {
                let lastItem = 0;
                combobox.getNumberOfItems().then(function (result: number) {
                    expect(result).toBeGreaterThan(10);// with less than 11 items there will be no scroll
                    lastItem = result - 1;

                    let selectedElementInitialLocation = 0;
                    let selectedElementFinalLocation = 0;
                    let selectedItemText = "Item 1";
                    let selectedElement: any = combobox.getItemByText(selectedItemText);

                    combobox.select(selectedItemText);

                    // open the combobox and get the location of the selected item
                    combobox.click();
                    selectedElement.getLocation().then(function (initialLocation: any) {
                        selectedElementInitialLocation = initialLocation.y;

                        // scroll to the first element in the top and close combobox
                        let scrollToScript = "document.getElementById('combobox').getElementsByTagName('LI')" +
                            "[" + lastItem + "].scrollIntoView()";
                        browser.executeScript(scrollToScript).then(function () {
                            // check location after scrolling is different
                            selectedElement.getLocation().then(function (location: any) {
                                expect(location.y).not.toEqual(selectedElementInitialLocation);
                            });
                            combobox.click();
                        });
                    });

                    // open the combobox and get the location of the selected item
                    combobox.click();
                    selectedElement.getLocation().then(function (location: any) {
                        selectedElementFinalLocation = location.y;
                        // with zooming implemented both locations must be the same
                        // checked that location is in a range because of padding of the LU element
                        // 10 because of @padding-base-vertical*2
                        expect(selectedElementFinalLocation - 10 <= selectedElementInitialLocation &&
                            selectedElementInitialLocation <= selectedElementFinalLocation + 10).toBeTruthy();
                    });
                });
            });

            it("after scrolling to the top and selected item is at the bottom", () => {
                combobox.getNumberOfItems().then(function (result: number) {
                    expect(result).toBeGreaterThan(10);// with less than 11 items there will be no scroll
                });

                let selectedElementInitialLocation = 0;
                let selectedElementFinalLocation = 0;
                let selectedItemText = "Item 20";
                let selectedElement: any = combobox.getItemByText(selectedItemText);

                combobox.scrollToAndSelect(selectedItemText);

                // open the combobox and get the location of the selected item
                combobox.click();
                selectedElement.getLocation().then(function (initialLocation: any) {
                    selectedElementInitialLocation = initialLocation.y;

                    // scroll to the first element in the top and close combobox
                    let scrollToScript = "document.getElementById('combobox').getElementsByTagName('LI')[0]" +
                        ".scrollIntoView()";
                    browser.executeScript(scrollToScript).then(function () {
                        // check location after scrolling is different
                        selectedElement.getLocation().then(function (location: any) {
                            expect(location.y).not.toEqual(selectedElementInitialLocation);
                        });
                        combobox.click();
                    });
                });

                // open the combobox and get the location of the selected item
                combobox.click();
                selectedElement.getLocation().then(function (location: any) {
                    selectedElementFinalLocation = location.y;
                    // with zooming implemented both locations must be the same
                    // checked that location is in a range because of padding of the LU element
                    // 10 because of @padding-base-vertical*2
                    expect(selectedElementFinalLocation - 10 <= selectedElementInitialLocation &&
                        selectedElementInitialLocation <= selectedElementFinalLocation + 10).toBeTruthy();
                });
            });
        });

        describe("Type ahead >", ()=> {

            beforeEach(() => {
                combobox.clearText();
            });

            it("should not show type ahead text when control is empty", () => {
                expect(combobox.areSuggestionsDisplayed()).toBe(false);
            });

            it("should show type ahead suggestions which contain input text", () => {
                combobox.acceptInput("Ite");
                expect(combobox.areSuggestionsDisplayed()).toBe(true);
                expect(combobox.getSuggestions().count()).toBe(10); // no more than 10 suggestions are shown

            });

            it("should not show type ahead suggestions which not contain input text", () => {
                combobox.acceptInput("3");
                expect(combobox.areSuggestionsDisplayed()).toBe(true);
                expect(combobox.getSuggestions().count()).toBe(2); // Item 3 and Item 13
            });

            it("should select the correct type ahead suggestion", () => {
                combobox.acceptInput("item");
                let suggestion = combobox.getSuggestionLink(2);

                expect(suggestion.getText()).toEqual("Item 3");
                suggestion.click();

                expect(combobox.getValueAttr()).toEqual("Item 3");
            });
        });

        describe("Clear on blur >", ()=> {
            let comboClearOnBlur: DropdownAtom;

            beforeEach(() => {
                comboClearOnBlur = Atom.find(DropdownAtom, "comboClearOnBlur");
            });

            it("should clear input on blur if its value is not in a source array", ()=> {
                comboClearOnBlur.acceptInput("Not in a source array");
                comboClearOnBlur.click();
                expect(comboClearOnBlur.getInputValue()).toBe("");
                expect(element(by.id("combo-clear-on-blur-model")).getText()).toBe("");
            });

            it("should remain input value on blur if its value is in a source array", ()=> {
                comboClearOnBlur.acceptInput("Item 1");
                comboClearOnBlur.click();
                expect(comboClearOnBlur.getInputValue()).toBe("Item 1");
                expect(element(by.id("combo-clear-on-blur-model")).getText()).toBe("Item 1");
            });
        });
    });
    describe("edge detection", () => {
        describe("a top right aligned component opens dropdown", () => {
            let topRightItem: DropdownAtom;
            beforeEach(() => {
                topRightItem = Atom.find(DropdownAtom, "test-alignments-top-right");
                topRightItem.click();
            });
            it("downside if there is no place to upside", () => {
                topRightItem.isChildElementPresent(by.className("dropup")).then((isPresented) => {
                    expect(isPresented).toBeFalsy();
                });
            });
            it("right aligned if there is no place to right side", () => {
                topRightItem.isChildElementPresent(by.className("dropdown-menu-right")).then((isPresented) => {
                    expect(isPresented).toBeTruthy();
                });
            });
        });
        describe("a bottom left aligned component opens dropdown", () => {
            let topLeftItem: DropdownAtom;
            beforeEach(() => {
                topLeftItem = Atom.find(DropdownAtom, "test-alignments-left-bottom");
                topLeftItem.click();
            });
            it("upside if there is no place to downside", () => {
                topLeftItem.isChildElementPresent(by.className("dropup")).then((isPresented) => {
                    expect(isPresented).toBeTruthy();
                });
            });
            it("left aligned if there is no place to left side", () => {
                topLeftItem.isChildElementPresent(by.className("dropdown-menu-right")).then((isPresented) => {
                    expect(isPresented).toBeFalsy();
                });
            });
        });
    });
});
