import IEmptyData = xui.IEmptyData;
/**
 * <xui-listview /> controller
 */
export default class ListviewController {
    public static $inject = ["$templateCache", "$scope", "$log"];

    public stripe:boolean;
    public templateUrl:string;
    public templateFn:()=>((item:any)=>string);
    public selectionMode:xui.ListSelectionModeEnum;
    public rowPadding:string;
    public selection:any[];
    public selectionProperty: string;
    public selectionInvert:boolean;
    public itemsSource:any[];
    public trackBy:string;
    public emptyText: string;
    public emptyTemplateUrl:string;
    public emptyData: IEmptyData;
    public showEmpty: boolean;

    constructor(private $templateCache:ng.ITemplateCacheService,
                private $scope:ng.IScope,
                private $log:ng.ILogService) {
        if (angular.isUndefined(this.stripe)) {
            this.stripe = true;
        }
        if (this.selectionMode && !_.includes(["single", "radio", "multi"], this.selectionMode)) {
            throw new Error("Invalid selectionMode: '" + this.selectionMode +
                "'. Use one of ['single', 'radio', 'multi']");
        }

        if (!_.isBoolean(this.showEmpty)) {
            this.showEmpty = true;
        }

        const { emptyText, emptyTemplateUrl } = this;

        if (!_.isObject(this.emptyData)) {
            this.emptyData = {};
        }

        if (_.isString(emptyText) && !_.isEmpty(emptyText)) {
            $log.warn("'empty-text' attr is now deprecated in flavor of xui-empty, use 'empty-data' instead");

            // emptyText is deprecated but used though
            _.set(this.emptyData, "title", emptyText);

            // Not to show the description by default(legacy approach)
            if (_.isEmpty(this.emptyData.description)) {
                this.emptyData.description = "";
            }
        }
        if (_.isString(emptyTemplateUrl) && !_.isEmpty(emptyTemplateUrl)) {
            $log.warn("'empty-template-url' attr is now deprecated in flavor of xui-empty, use 'empty-data' instead");

            // emptyTemplateUrl is deprecated but used though
            _.set(this.emptyData, "templateUrl", emptyTemplateUrl);
        }
    }

    /**
     * Listview's internal templating system used to distinguish between selectable/default template rows
     * The selectable template adds checkbox to every row whereas the default template just shows the listview/item
     * template
     *
     * @returns {any}
     */
    public getInternalTemplateUrl():string {
        return `xui/components/listview/templates/listview-${this.getInternalTemplateId()}.html`;
    }

    /**
     * Replace listview with specified template when itemsSource is empty or undefined
     *
     * @returns {string}
     */
    public getEmptyTemplateUrl():string {
        return "xui/components/listview/templates/listview-empty.html";
    }

    /**
     * Get template for every row.
     * item.$templateUrl > item.templateUrl > listview.templateUrl (function or string) > listview-missing.html
     *
     * @param item
     * @returns {any}
     */
    public getTemplateUrl(item:xui.IListViewItem):string {
        // templateUrl on item
        const itemTemplate = (item.$templateUrl || item.templateUrl);
        if (itemTemplate && this.isValidTemplate(itemTemplate)) {
            return itemTemplate;
        }

        // templateFn on listview
        const templateFn = angular.isFunction(this.templateFn) ? this.templateFn() : null;
        if (angular.isFunction(templateFn)) {
            const result = templateFn(item);
            if (this.isValidTemplate(result)) {
                return result;
            }
        }

        // templateUrl on listview
        if (this.isValidTemplate(this.templateUrl)) {
            return this.templateUrl;
        }

        return "xui/components/listview/templates/listview-missing.html";
    }

    public trackByFunction(item: any, idGenerator: any): any {
        if (angular.isString(this.trackBy) && !angular.isUndefined(item[this.trackBy])) {
            return item[this.trackBy];
        }
        let id:any = idGenerator(item);
        return id;
    }

    public isItemSelected(item: xui.IListViewItem):boolean {
        const value: any = this.selectionProperty ? (<any>item)[this.selectionProperty] : item;
        switch (this.selectionMode) {
            case "single":
            case "radio":
                return (this.selection && angular.equals(value, this.selection[0]));
            case "multi":
                return (this.selection && this.selection.length && this.selection.indexOf(value) !== -1);
            default:
                return false;
        }
    }

    public itemClicked(item: any) {
        if (this.selectionMode === "single" || this.selectionMode === "radio") {
            this.selection = [this.selectionProperty ? item[this.selectionProperty] : item];
        }
    }

    private getInternalTemplateId():string {
        return this.selectionMode ? this.selectionMode : "default";
    }

    /**
     * Check if template is stored in $templateCache. Otherwise issue a warning and return null.
     *
     * @param templateId
     * @returns {string}
     */
    private isValidTemplate(templateUrl:string) {
        return this.$templateCache.get(templateUrl);
    }

}
