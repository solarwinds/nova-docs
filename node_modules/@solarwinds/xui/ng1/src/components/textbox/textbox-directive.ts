import TextboxController from "./textbox-controller";

/**
 * @ngdoc directive
 * @name xui.directive:xuiTextbox
 * @restrict E
 *
 * @description
 * XUI Textbox description.
 *
 * @parameters
 * @param {string} caption Value used as a label for the text box.
 * @param {string} placeholder Value used as a placeholder for the text box.
 * @param {string} validators Comma-delimmited string of validator identifiers along with parameters (e.g. min=-5).
 * @param {string} type Type of input box (e.g. email, number, password).
 * @param {string} rows Number of rows for input.
 * @param {string} name Name of the element.
 * @param {string} help-text Help content provided below the text box.
 * @param {string} is-disabled Expression to disable the text box.
 * @param {string} is-read-only Expression to make the text box read only.
 * @param {boolean=} is-required Attribute to set/change conditional 'required' validation.
 * @param {object} ng-model-options This component also supports `ng-model-options` directive for binding to forms.
 * @param {string} custom-box-width Use to set a custom width for the input field.
 * @param {string} suffix Use to set suffix (in conjunction with custom width).
 *
 * @example
 *<example module="xui">
 *     <file src="src/components/textbox/docs/textbox-examples.html" name="index.html"></file>
 *     <file src="src/components/textbox/docs/textbox-examples.js" name="app.js"></file>
 *</example>
 */

interface ITextboxScope extends ng.IScope {
    name:string;
}

//this directive does an unusual thing- it delays compiling the input it contains
//the reason for this is for validators.  The validators need to be able to be pulled from the
//directive's attributes, and be put on the child input control.  There are 2 hiccups here.
//The first is that we can have a custom validator that must be placed on the input PRE compile, so
//that it can be compiled with the input.  The second is that bindings put on some of the validators
//need to be compiled against the directive's scope, not the isolated one inside the directive.
//Putting the logic in the link allows bindings to be resolved; delayed compilation on the
//input allows custom validators to be compiled properly.
class Textbox implements ng.IDirective {
    public static $inject = ["swUtil", "$compile"];

    constructor(private swUtil:any, private $compile:ng.ICompileService) {
    }

    public require = ["xuiTextbox"];
    public restrict = "E";
    public replace = true;
    public transclude = true;
    public templateUrl = "xui/components/textbox/textbox-directive.html";
    public scope = {};
    public controller = "xuiTextboxController";
    public controllerAs = "textCtrl";
    public bindToController = {
        name: "@?",
        caption: "@?",
        type: "@?",
        placeholder: "@?",
        validators: "@?",
        helpText: "@?",
        rows: "@?",
        customBoxWidth: "@?",
        suffix: "@?",
        modelOptions: "<?ngModelOptions",
        value: "=ngModel",
        onChange: "&?ngChange",
        onBlur: "&?ngBlur",
        onFocus: "&?ngFocus",
        isRequired: "<?"
    };

    public link = (scope:ITextboxScope, element:ng.IAugmentedJQuery,
                   attrs:ng.IAttributes, controllers:any,
                   transcludeFn:ng.ITranscludeFunction) => {
        const textboxController:TextboxController = controllers[0];

        this.swUtil.initComponent(attrs, "textbox");

        if (!("caption" in attrs)) {
            element.find(".xui-textbox__control-label-container")
                .addClass("xui-textbox__control-label-container--hidden");
        }

        this.swUtil.watchBoolean(attrs, "isDisabled", textboxController);
        this.swUtil.watchBoolean(attrs, "isReadOnly", textboxController);

        //normally, scope.name would be populated after a digest cycle from the attr collection
        //however, we need the name immediately, so it can be put on the form controller
        //without setting this here, the formController[scope.name] call later on will fail
        if (!scope.name) {
            scope.name = attrs["name"];
        }

        textboxController.multiline = (attrs["rows"] && attrs["rows"] > 1) || false;

        let elementToUse:ng.IAugmentedJQuery = null;

        if (textboxController.multiline) {
            elementToUse = element.find("textarea");
            element.find("input").remove();
        } else {
            elementToUse = element.find("input");
            element.find("textarea").remove();
        }

        if (attrs["validators"]) {
            _.each(attrs["validators"].split(","), (validator:string) => {
                let parts = validator.split("=");
                let name = parts[0];
                let value = parts.length > 1 ? parts[1] : "";
                if (name === "required") {
                    textboxController.isRequired = true;
                } else {
                    elementToUse.attr(name, value);
                }
            });
        }

        if (attrs["ngPattern"]) {
            elementToUse.attr("ng-pattern", attrs["ngPattern"]);
        }

        elementToUse.removeAttr("ng-non-bindable");
        this.$compile(elementToUse)(scope);
        textboxController.input = elementToUse.controller("ngModel");
    };
}

export default Textbox;
