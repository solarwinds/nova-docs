import IPromise = ng.IPromise;
import IVirtualNode = xui.IVirtualNode;
import ITreeviewOptions = xui.ITreeviewOptions;
import ITreeviewContext = xui.ITreeviewContext;
import ITreeviewState = xui.ITreeviewState;

export class VirtualNode implements IVirtualNode {
    $children:Array<VirtualNode>;
    $level:number;
    $hasChildren:boolean;
    $hasGrandChildren:boolean;
    collapsed:boolean = true;
    checked:boolean = false;
    indeterminate:boolean = false;
    loading:boolean = false;
    limitMultiplier:number = null;
    constructor(public $model:any, public $parent:IVirtualNode) {}
}

/**
 * Service handling functionality related to XUI.Treeview component
 */
export class TreeviewService {

    public children(node:IVirtualNode, options:ITreeviewOptions):Array<any> {
        const children = node.$model[options.childrenKey];
        if (angular.isFunction(children)) {
            return children();
        } else if (angular.isArray(children)) {
            return children;
        } else {
            throw new Error("Children is neither an array nor a function.");
        }
    }

    /**
     * Turns a node into a virtual node containing all necessary meta information
     *
     * @param node
     * @param parent
     * @param options
     * @returns {VirtualNode}
     */
    public nodify(node:any, parent:IVirtualNode, options:ITreeviewOptions):IVirtualNode {
        const vnode = new VirtualNode(node, parent);
        vnode.$hasChildren = this.hasChildren(node, options);
        vnode.$level = this.nodeLevel(vnode);
        if (options.limit != null) {
            vnode.limitMultiplier = 1; // limit on vnode is a multiple
        }
        //vnode.$id = (typeof index === "undefined") ? "/" : service.pathId(vnode, index);

        if (vnode.$hasChildren) {
            const children = this.children(vnode, options);
            vnode.$children = this.nodifyArray(children, vnode, options);
            vnode.$hasGrandChildren = _.some(vnode.$children, { $hasChildren: true });
        }

        if (parent != null && options.selectionMode === "multi" && parent.checked != null) {
            vnode.checked = parent.checked;
        }

        return vnode;
    }

    /**
     * Turns an array of nodes into virtual nodes
     *
     * @param nodes
     * @param parent
     * @param options
     * @returns {Array}
     */
    public nodifyArray(nodes:any[], parent:IVirtualNode, options:ITreeviewOptions):IVirtualNode[] {
        //noinspection JSPrimitiveTypeWrapperUsage
        const vnodes = new Array<IVirtualNode>();
        angular.forEach(nodes, (node) => {
            vnodes.push(this.nodify(node, parent, options));
        });
        return vnodes;
    }

    /**
     * Returns next visible node for given node respecting treeview collapsed/expanded nodes
     *
     * @param current
     * @returns {any}
     */
    public nextVisibleNode(current:IVirtualNode):IVirtualNode {
        // return first child if expanded
        if (!current.collapsed && current.$children.length > 0) {
            return current.$children[0];
        }

        let n = current;
        // return next sibling if current is not the last one
        while (n.$parent != null) {
            const siblings = n.$parent.$children;
            const idx:number = siblings.indexOf(n);
            const nextIdx:number = idx + 1;
            if (nextIdx < siblings.length) {
                return siblings[nextIdx];
            }
            n = n.$parent;
        }

        // otherwise return current node
        return current;
    }

    /**
     * Returns previous visible node for given node respecting treeview collapsed/expanded nodes
     *
     * @param current
     * @returns {any}
     */
    public previousVisibleNode(current:IVirtualNode):IVirtualNode {
        const siblings = current.$parent.$children;
        const idx:number = siblings.indexOf(current);
        if (idx === 0) {
            // for the first node in first level just return the node
            return (current.$level <= 2) ? current : current.$parent;
        } else {
            // start with the previous sibling
            let lastChild:IVirtualNode = siblings[idx - 1];

            while (true) {
                // continue until a collapsed node (or without children) is found
                if (lastChild.collapsed || !lastChild.$hasChildren) {
                    return lastChild;
                }
                lastChild = lastChild.$children[lastChild.$children.length - 1];
            }
        }
    }

    /**
     * Creates an TreeviewOptions object based on given data with filled default values
     *
     * @param clientOptions
     * @returns {ITreeviewOptions}
     */
    public fillOptionDefaults(clientOptions:ITreeviewOptions):ITreeviewOptions {
        clientOptions = clientOptions || <ITreeviewOptions>{};

        const options:ITreeviewOptions = {
            childrenKey: clientOptions.childrenKey || "children",
            hasChildrenKey: clientOptions.hasChildrenKey || "has_children",
            onExpand: clientOptions.onExpand || angular.noop,
            onCollapse: clientOptions.onCollapse || angular.noop,
            onSelect: clientOptions.onSelect || angular.noop,
            onDblClick: clientOptions.onDblClick || angular.noop,
            load: clientOptions.load || null,
            limit: clientOptions.limit || null,
            selectionMode: clientOptions.selectionMode || null,
            trackBy: clientOptions.trackBy || null,
            isAlwaysSelected: clientOptions.isAlwaysSelected || false
        };

        return options;
    }

    public fillChildrenNodes(vnode:IVirtualNode, options:ITreeviewOptions, context:ITreeviewContext, $scope:ng.IScope) {
        if (options.load) {
            vnode.loading = true;
            vnode.$model.children = [];
            vnode.$children = [];

            options.load(vnode)
                .then((result:any[])=> {
                    vnode.$model.children = result;
                    vnode.$children = this.nodifyArray(result, vnode, options);
                })
                .catch(()=> {
                    console.log("ERROR"); // TODO proper error handling
                })
                .finally(()=> {
                    vnode.loading = false;
                });
        } else if (vnode.$hasChildren) {

            const populateChildren = () => {
                angular.forEach(vnode.$children, (child) => {
                    if (child.$hasChildren) {
                        const children = this.children(child, options);
                        child.$children = this.nodifyArray(children, child, options);
                    }
                });
            };

            $scope.$watchCollection(()=> vnode.$model[options.childrenKey],
                (newNodes:Array<any>, oldNames:Array<any>) => {
                    vnode.$children = this.nodifyArray(vnode.$model[options.childrenKey], vnode, options);
                    vnode.$hasChildren = vnode.$children.length > 0;
                    populateChildren();
            });

            populateChildren();
        }
    }

    public createRootNode(nodes:Array<any>, options:ITreeviewOptions, context:ITreeviewContext,
                          $scope:ng.IScope):IVirtualNode {
        const node:IVirtualNode = new VirtualNode(null, null);
        (<any>node)[options.childrenKey] = nodes;
        const root = this.nodify(node, null, options);

        $scope.$watchCollection(()=> nodes, (newNodes:Array<any>, oldNames:Array<any>)=> {
            (<any>node)[options.childrenKey] = newNodes;
            root.$children = this.nodifyArray(nodes, root, options);
            root.$hasChildren = root.$children.length > 0;
        });

        root.$children = this.nodifyArray(nodes, root, options);
        this.fillChildrenNodes(root, options, context, $scope);
        root.collapsed = false;
        return root;
    }

    public updateGroupCheck(vnode:IVirtualNode):void {
        const check = this.calculateGroupCheck(vnode);
        //console.log("Check result for ", vnode.$parent.$model.label, ":", vnode.$model.label, " is ", check);
        if (check === null) {
            vnode.checked = false;
            vnode.indeterminate = true;
        } else {
            vnode.checked = check;
            vnode.indeterminate = false;
        }
    }

    public findNodeByState(nodeIdentifier:string, state:ITreeviewState, context:ITreeviewContext):IVirtualNode {
        let node:IVirtualNode = context.rootNode;
        let path = angular.copy(state.path);
        while (path.length !== 0 && node !== null) {
            let nodeId = path.shift();
            node = _.find(node.$children, (vnode:IVirtualNode) => {
                return vnode.$model[nodeIdentifier] === nodeId;
            });
        }

        if (node !== null && path.length === 0) {
            return _.find(node.$children, (vnode:IVirtualNode) => {
                return vnode.$model[nodeIdentifier] === state.id;
            });
        }

        return null;
    }

    /**
     * Get check/indeterminate status for node's checkbox
     *
     * @param vnode
     * @returns {boolean}
     */
    private calculateGroupCheck(vnode:IVirtualNode):boolean {
        if (!vnode.$hasChildren || typeof (vnode.$children) === "undefined") {
            return false;
        }
        let checked:boolean = null;
        for (let i = 0; i < vnode.$children.length; i++) {
            const c = vnode.$children[i];
            if (c.indeterminate === null) {
                this.updateGroupCheck(c);
            }
            if (checked === null) {
                checked = c.checked;
            }
            if ((c.$hasChildren && c.indeterminate) || checked !== c.checked) {
                return null;
            }
        }
        return checked;
    }

    private hasChildren(node:any, options:ITreeviewOptions):boolean {
        return angular.isArray(node[options.childrenKey]) || node[options.hasChildrenKey] || false;
    }

    private nodeLevel(vnode:IVirtualNode):number {
        let level = 0;
        while (vnode !== null && typeof (vnode = vnode.$parent) !== "undefined") {
            level++;
        }
        return level;
    }
}
