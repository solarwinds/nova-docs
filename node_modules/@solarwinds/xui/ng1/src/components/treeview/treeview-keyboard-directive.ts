import {TreeviewService} from "./treeview-service";
import {Constants} from "../../common/constants";
import ITreeviewScope = xui.ITreeviewScope;
import ITreeviewController = xui.ITreeviewController;
import IVirtualNode = xui.IVirtualNode;

export class TreeviewKeyboard implements ng.IDirective {
    public static $inject = ["xuiTreeviewService", "xuiConstants"];

    public restrict = "A";
    public require = "^xuiTreeview";

    public constructor(private treeviewService:TreeviewService, private constants:Constants) {
        this.link = this.link.bind(this);
    }

    public link($scope:ITreeviewScope, element:ng.IAugmentedJQuery,
                attrs:ng.IAttributes, ctrl:ITreeviewController) {
        let onKeyDown = ($event:JQueryEventObject) => this.onKeyDown($event, $scope, ctrl);

        element.attr("tabindex", "0");
        element.bind("keydown", onKeyDown.bind(this));
    }

    /**
     * Keyboard event handling for the treeview. The rules are following:
     *
     * Left arrow: Collapse open node or focus parent not when already collapsed or without child nodes
     * Right arrow: Expand node or focus it's first child if expanded
     * Down/up arrows: Shift focus to next/previous visible node (respecting expanded and collapsed nodes)
     * Space: toggle selection if multi-selection is enabled
     * Asterisk: expand current node
     * Minus: collapse current node
     *
     * @param $event
     * @param $scope
     * @param ctrl
     */
    private onKeyDown($event:JQueryEventObject, $scope:ITreeviewScope, ctrl:ITreeviewController) {
        const context = ctrl.context;
        const options = ctrl.options;
        const vnode = context.focusedNode;
        const keyCodes = this.constants.KEY_CODE;

        this.onKeyDownCommon.bind(this)($event, $scope, ctrl);

        if (vnode == null) {
            if (options.selectionMode !== null) {
                if (_.includes([
                        keyCodes.UP_ARROW,
                        keyCodes.DOWN_ARROW,
                        keyCodes.LEFT_ARROW,
                        keyCodes.RIGHT_ARROW,
                    ], $event.keyCode)) {
                    context.focusedNode = context.rootNode.$children[0];
                }
            }
        } else {
            this.onKeyDown4FocusedNode.bind(this)($event, vnode, $scope, ctrl);
        }

        $scope.$digest();
    }

    /**
     * Handle keyboard input common for all selection modes
     *
     * @param $event
     * @param $scope
     * @param ctrl
     */
    private onKeyDownCommon($event:JQueryEventObject, $scope:ITreeviewScope, ctrl:ITreeviewController) {
        const context = ctrl.context;
        const keyCodes = this.constants.KEY_CODE;

        switch ($event.keyCode) {
            case keyCodes.ASTERISK: // ASTERISK
            case keyCodes.PLUS: // PLUS
                if (($event.keyCode === keyCodes.ASTERISK && context.focusedNode === null) ||
                    ($event.keyCode === keyCodes.PLUS && $event.shiftKey)) {
                    ctrl.expandAll($event);
                }
                break;
            case keyCodes.MINUS: // MINUS
                if ($event.shiftKey) {
                    ctrl.collapseAll($event);
                }
                break;
        }
    }

    /**
     * Handle keyboard input when a node is focused
     *
     * @param $event
     * @param vnode
     * @param $scope
     * @param ctrl
     */
    private onKeyDown4FocusedNode($event:JQueryEventObject, vnode:IVirtualNode,
                                  $scope:ITreeviewScope, ctrl:ITreeviewController) {
        const context = ctrl.context;
        const options = ctrl.options;
        const keyCodes = this.constants.KEY_CODE;

        switch ($event.keyCode) {
            case keyCodes.LEFT_ARROW: // LEFT
                if (vnode.$hasChildren && !vnode.collapsed) {
                    ctrl.collapse($event, vnode);
                } else if (vnode.$parent !== context.rootNode) {
                    // move to parent if node doesn't have any children
                    context.focusedNode = vnode.$parent;
                }
                break;
            case keyCodes.RIGHT_ARROW: // RIGHT
            case keyCodes.PLUS: // PLUS
                if (vnode.$hasChildren) {
                    if (vnode.collapsed) {
                        //$log.debug("Expanding node: ", vnode);
                        ctrl.expand($event, vnode);
                    } else if ($event.keyCode === 39) {
                        context.focusedNode = vnode.$children[0];
                    }
                }
                break;
            case keyCodes.UP_ARROW: // UP
                context.focusedNode = this.treeviewService.previousVisibleNode(context.focusedNode);
                $event.preventDefault();
                break;
            case keyCodes.DOWN_ARROW: // DOWN
                context.focusedNode = this.treeviewService.nextVisibleNode(context.focusedNode);
                $event.preventDefault();
                break;
            case keyCodes.SPACE: // SPACE
                context.focusedNode.checked = !context.focusedNode.checked;
                ctrl.applySelection($event, context.focusedNode);
                $event.preventDefault();
                break;
            case keyCodes.ASTERISK: // ASTERISK
                ctrl.expandAll($event, context.focusedNode);
                break;
            case keyCodes.MINUS: // MINUS
                ctrl.collapseAll($event);
                break;
        }
    }
}

export default TreeviewKeyboard;
