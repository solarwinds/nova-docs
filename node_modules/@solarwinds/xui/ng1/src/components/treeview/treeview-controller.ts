import {TreeviewService} from "./treeview-service";
import ITreeviewController = xui.ITreeviewController;
import ITreeviewScope = xui.ITreeviewScope;
import ITreeviewContext = xui.ITreeviewContext;
import ITreeviewOptions = xui.ITreeviewOptions;
import IVirtualNode = xui.IVirtualNode;
import ITreeviewState = xui.ITreeviewState;

export class TreeviewController implements ITreeviewController {
    public static $inject = ["$scope", "xuiTreeviewService"];

    public transcludeFn:any;
    public model:any;
    public context:ITreeviewContext;
    public options:ITreeviewOptions;
    public nodeIdentifier:string;
    public state:string;
    public onStateChanged:(params:{newState: string, oldState: string}) => void;

    private stateData: ITreeviewState[];

    constructor(public $scope:ITreeviewScope,
                private treeviewService:TreeviewService) {
        this.options = this.treeviewService.fillOptionDefaults(this.options);

        this.context = this.context || <ITreeviewContext>{};
        this.context.selectedNode = this.context.selectedNode || null;
        this.context.selectedNodes = this.context.selectedNodes || [];
        this.state = this.state || "[]";
        this.onStateChanged = this.onStateChanged || angular.noop;

        this.initRootNode(this.model);
        this.applyDefaultSelection();

        $scope.$watch(()=> this.model, ((newValue:any[], oldValue:any[]) => {
            if (newValue !== oldValue) {
                this.initRootNode(newValue);
                $scope.node = this.context.rootNode;
                this.applyDefaultSelection();
            }
        }).bind(this));
        this.stateData = <ITreeviewState[]>JSON.parse(this.state);

        if (typeof this.nodeIdentifier !== "undefined") {
            this.$scope.$watch(
                ()=> this.state, ((newState:string, oldState:string) => {
                    if (newState!==oldState) {
                        this.stateData = <ITreeviewState[]>JSON.parse(this.state);
                        this.updateState();
                    }
                }).bind(this));
        }
    }

    public getNodeCssStyle = (node:IVirtualNode):any => {
        if (node.$level > 2) {
            const offset = 50 * (node.$level - 2);
            return {
                "margin-left": -(offset),
                "padding-left": offset
            };
        }

        return {};
    };

    /**
     * Expand the given node
     *
     * @param $event
     * @param vnode
     */
    public expand($event:JQueryEventObject, vnode:IVirtualNode) {
        if (vnode.$hasChildren && vnode.collapsed) {
            this.treeviewService.fillChildrenNodes(vnode, this.options, this.context, this.$scope);
            vnode.collapsed = false;

            this.options.onExpand($event, vnode, this.context);
        }
    }

    /**
     * Collapse given node
     *
     * @param $event
     * @param vnode
     */
    public collapse($event:JQueryEventObject, vnode:IVirtualNode) {
        if (!vnode.collapsed) {
            vnode.collapsed = true;
            //treeviewService.fillChildrenNodes(vnode, options, context, []);
            angular.forEach(vnode.$children, (child) => {
                child.collapsed = true;
            });
            this.options.onCollapse($event, vnode, this.context);
        }
    }

    /**
     * Expand all nodes under given node
     *
     * @param $event
     * @param vnode
     */
    public expandAll($event:JQueryEventObject, vnode:IVirtualNode) {
        this.traverse(vnode || this.context.rootNode, (n:IVirtualNode)=> {
            if (n.collapsed) {
                this.expand($event, n);
            }
        });
    };

    /**
     * Collapse all nodes under given node
     *
     * @param $event
     */
    public collapseAll($event:JQueryEventObject) {
        this.traverse(this.context.rootNode, (n:IVirtualNode)=> {
            if (!n.collapsed) {
                this.collapse($event, n);
            }
        });
    }

    /**
     * Toggle expand/collapse state of given node
     *
     * @param $event
     * @param vnode
     */
    public toggle($event:JQueryEventObject, vnode:IVirtualNode):void {
        $event.stopPropagation();

        if (vnode.collapsed) {
            this.expand($event, vnode);
        } else {
            this.collapse($event, vnode);
        }
        this.changeState();
    }

    /**
     * Node selection handler
     *
     * @param $event
     * @param vnode
     */
    public checkNode($event:JQueryEventObject, vnode:IVirtualNode):void {
        this.applyMultiSelection(vnode);
        this.options.onSelect($event, vnode, this.context);
    }

    public showMore($event:JQueryEventObject, vnode:IVirtualNode):boolean {
        vnode.limitMultiplier += 1;
        return false;
    }

    public showAll($event:JQueryEventObject, vnode:IVirtualNode):boolean {
        vnode.limitMultiplier = null;
        return false;
    }

    public showLimitLinks(vnode:IVirtualNode):boolean {
        return vnode.$hasChildren && vnode.limitMultiplier != null &&
            (vnode.limitMultiplier * this.options.limit < vnode.$children.length);
    }

    /**
     * Node click handler
     *
     * @param $event
     * @param vnode
     */
    public onNodeClick($event:JQueryEventObject, vnode:IVirtualNode) {
        $event.stopPropagation();

        // toggle node if selection is disabled
        if (this.options.selectionMode === null) {
            // don't toggle node when clicking on a link
            if ($event.target.nodeName.toLowerCase() !== "a") {
                this.toggle($event, vnode);
            }
        }

        if (this.options.selectionMode === "single") {
            this.context.focusedNode = vnode;
            vnode.checked = true;
            this.applySingleSelection(vnode);
            this.options.onSelect($event, vnode, this.context);
        }
    }

    /**
     * Node double click handler
     *
     * @param $event
     * @param vnode
     */
    public onNodeDblClick($event:JQueryEventObject, vnode:IVirtualNode) {
        if (this.options.selectionMode !== null) {
            this.toggle($event, vnode);
        }

        this.options.onDblClick($event, vnode, this.context);
    }
    /*
    * TrackBy functionality for the ngRepeat of nodes
    *
    * if trackBy specified on options and the property exists on node, it uses otherwise uses the $index
    *
    */
    public trackByFunction(node: any, index: number): any {
        if ((typeof this.options.trackBy === "string") && node && node.$model && node.$model[this.options.trackBy]) {
            return node.$model[this.options.trackBy];
        }
        return index;
    }

    /***
     * @param $event
     * @param vnode
     */
    public applySelection($event:JQueryEventObject, vnode:IVirtualNode):void {

        if (this.options.selectionMode === "single") {
            this.applySingleSelection(vnode);
        }

        if (this.options.selectionMode === "multi") {
            this.applyMultiSelection(vnode);
        }

        this.options.onSelect($event, vnode, this.context);
    }

    /**
     * Initialize root node from given model
     *
     * @param model
     */
    private initRootNode(model:any) {
        this.context.rootNode = this.treeviewService.createRootNode(model, this.options, this.context, this.$scope);
    }

    /**
     * Traverse callback to given vnode and all it's children's children's children ...
     *
     * @param vnode
     * @param callback
     */
    private traverse(vnode:IVirtualNode, callback:(vn:IVirtualNode, path: string[]) => void, path: string[] = null) {
        if (vnode !== this.context.rootNode) {
           callback(vnode, path);
        }

        if (vnode.$hasChildren) {
            angular.forEach(vnode.$children, (e:IVirtualNode) => {
                 this.traverse(e, callback, angular.copy(path));
            });
        }
    }

    /**
     * After IVirtualNode is changed, previous one have to be unchecked.
     *
     * @param vnode
     */
    private applySingleSelection(vnode:IVirtualNode) {
        if (this.context.selectedNode) {
            this.context.selectedNode.checked = false;
        }
        if (vnode.checked === true) {
            this.context.selectedNode = vnode;
        }
        if (vnode.checked === false) {
            this.context.selectedNode = null;
        }
        this.changeState();
    }

    /**
     * After IVirtualNode is changed, it has to be distributed
     * to children and parent nodes.
     *
     * @param vnode
     */
    private applyMultiSelection(vnode:IVirtualNode) {
        this.traverse(vnode, (n:IVirtualNode) => {
            if (n.$hasChildren) {
                n.indeterminate = null;
            }

            n.checked = vnode.checked;

            const idx = this.context.selectedNodes.indexOf(n);
            if (vnode.checked === true) {
                if (idx === -1) {
                    this.context.selectedNodes.push(n);
                }
            } else if (idx !== -1) {
                this.context.selectedNodes.splice(idx, 1);
            }
        });

        // distribute check status to node's parents
        let n = vnode.$hasChildren ? vnode : vnode.$parent;

        while (n !== this.context.rootNode) {
            n.indeterminate = null;
            n = n.$parent;
        }
        this.treeviewService.updateGroupCheck(this.context.rootNode);
        this.changeState();
    }

    private changeState() {
        if (typeof this.nodeIdentifier === "undefined") {
            return;
        }

        let oldStateData = this.stateData;
        this.stateData = [];

        this.traverse(this.context.rootNode, (node:IVirtualNode, path:string[]) => {
            let currentPath = angular.copy(path);

            path.push(node.$model[this.nodeIdentifier]);

            if (node.checked || !node.collapsed) {
                this.stateData.push(<ITreeviewState>{
                    id: node.$model[this.nodeIdentifier],
                    path: currentPath,
                    expanded: !node.collapsed,
                    checked: node.checked
                });
            }

        }, []);

        let oldState = JSON.stringify(oldStateData);
        let newState = JSON.stringify(this.stateData);
        if (oldState !== newState) {
            this.onStateChanged({newState: newState, oldState: oldState});
        }
    }

    public updateState() {
        this.context.focusedNode = null;
        this.context.selectedNode = null;
        this.context.selectedNodes = [];
        this.traverse(this.context.rootNode, (node:IVirtualNode)=> {
            node.collapsed = true;
            node.checked = false;
        });
        this.stateData.forEach((item) => {
            let node:IVirtualNode = this.treeviewService.findNodeByState(this.nodeIdentifier, item, this.context);
            if (node !== null && (item.checked || item.expanded)) {
                if (this.options.selectionMode === "single" && item.checked === true) {
                    this.context.focusedNode = node;
                    node.checked = item.checked;
                    this.context.focusedNode.checked = item.checked;
                    this.context.selectedNode = node;
                } else if (this.options.selectionMode === "multi") {
                    node.checked = item.checked;
                    this.context.selectedNodes.push(node);
                } else {
                    node.checked = item.checked;
                }
                node.collapsed = !item.expanded;
            }
        });
    }

    /**
     * Creates default selection.
     */
    private applyDefaultSelection() {
        if (this.options.selectionMode === "single" &&
            this.options.isAlwaysSelected &&
            this.context.selectedNode === null &&
            this.context.rootNode.$hasChildren) {
            this.$scope.$applyAsync(() => {
                let defaultNode = this.context.rootNode.$children[0];
                defaultNode.checked = true;
                this.context.selectedNode = defaultNode;
                this.context.focusedNode = defaultNode;
                this.context.focusedNode.checked = true;
            });
        }
    }
}
