import DropdownController from "./dropdown-controller";
import InputProxyService from "../../services/inputProxy-service";
import {IAttributeProxies} from "../../services/inputProxy-service";

import IEdgeDetectionResult = xui.IEdgeDetectionResult;

/**
 * @ngdoc directive
 * @name xui.directive:xuiDropdown
 * @restrict E
 *
 * @description
 * XUI Dropdown component.  The styling can be altered by applying a class to the container element.
 * Currently supported classes are xui-dropdown-inline and xui-dropdown--justified.
 *
 * @parameters
 * @param {string=} caption Value used as a label for the dropdown.
 * @param {boolean=} is-disabled Value used to set dropdown to read only mode.
 * @param {array} items-source Array of values that are bound to the list of dropdown items. If the array itself
 * consists of several arrays, e. g. [["item 1", "item 2"], ["item 3", "item 4"]], each of the sub-arrays will be
 * treated as a separate group of items. Logical separators will be shown between these groups.
 * @param {function=} on-changed Callback event when the current selection has changed.
 * @param {function=} on-secondary-action Callback event that provides split-button behavior and interaction.
 * @param {string=} displayFormat Template for formatting selected item on the dropdown button.
 * @param {string=} displayValue Name of the item property that will be shown in the dropdown menu.
 * @param {function=} displayValueFn Template function for formatting items in dropdown.
 * @param {object=} ng-model This component also supports `ng-model` directive for binding to forms.
 * @param {object=} selected-item Two-way model value that contains the currently selected item.
 * @param {string=} item-template-url URL of the content to load for the items in the dropdown.
 * @param {string=} placeholder Text displayed when no item is selected.
 * @param {boolean=} is-required Indicates whether a selection must be made for validation.
 * @param {boolean=} is-editable Turns the dropdown into a combobox.
 * @param {boolean=} clear-on-blur Clears combobox input if its value is not in a source array.
 * @param {boolean=} dropdown-append-to-body Appends the menu to '$body' instead of the parent element.
 * @internalParam {Boolean} [single-value-hide=false] Hides dropdown button if items-source array consists of 1 element.
 * @example
 *    <example module="xui">
 *        <file src="src/components/dropdown/docs/dropdown-examples.html" name="index.html"></file>
 *        <file src="src/components/dropdown/docs/dropdown-examples.js" name="app.js"></file>
 *    </example>
 **/
class Dropdown implements ng.IDirective {
    public static $inject = ["swUtil", "xuiInputProxyService", "$timeout", "xuiEdgeDetectionService"];

    public restrict = "E";
    public require = ["xuiDropdown", "?^form", "?ngModel"];
    public scope = {};
    public templateUrl = "xui/components/dropdown/dropdown-directive.html";
    public replace = true;
    public transclude = true;
    public controller = DropdownController;
    public controllerAs = "vm";
    public bindToController = {
        name: "@?",
        itemsSource: "=",
        selectedItem: "=?",
        model: "=?ngModel",
        caption: "@?",
        displayFormat: "@?",
        displayValue: "@?",
        displayValueFn: "&?",
        zoomingFn: "&?",
        isDisabled: "=?",
        size: "@?",
        helpText: "@?",
        onChanged: "&?",
        onSecondaryAction: "&?",
        icon: "@?",
        itemTemplateUrl: "@?",
        placeholder: "@?",
        isRequired: "=?",
        isEditable: "=?",
        comboType: "@?", // this is internal attribute, not supposed to be documented
        itemToSelect: "<",
        singleValueHide: "<?", // this is internal attribute, not supposed to be documented
        clearOnBlur: "<?",
        dropdownAppendToBody: "<?"
    };

    constructor(private swUtil: any, private xuiInputProxyService: InputProxyService,
                private $timeout: ng.ITimeoutService, private edgeDetector: xui.IEdgeDetectionService) {
    }

    public compile = (element: ng.IAugmentedJQuery, attrs: ng.IAttributes) => {
        if ("isDisabled" in attrs) {
            const $btns = element.find(".xui-dropdown__toggle, .xui-dropdown__action, .xui-dropdown__input-control");
            $btns.attr("ng-disabled", "vm.isDisabled");
        }

        const input = element.find(".xui-dropdown__input");
        if (attrs["isEditable"]) {
            if (attrs["comboType"] === "drombo") {
                // first we need to switch the dropdown toggle from button to input
                input.attr("xui-dropdown-input-toggle", "");
                input.attr("xui-select-on-focus", "");
                input.addClass("xui-dropdown__toggle");

                const toggleButton = element.find(".xui-dropdown__toggle-button");
                toggleButton.remove();

                // then we remove all typeahead attributes as they would interfere with the dropdown
                input.removeAttr("uib-typeahead");
                input.removeAttr("typeahead-on-select");
                input.removeAttr("typeahead-template-url");
            }

            const handlers = this.xuiInputProxyService.proxyAttributesCompile(attrs, input);
            return {post: this.postLinkFactory(handlers)};
        } else {
            input.remove();
            return {post: this.postLinkFactory()};
        }
    };

    private postLinkFactory = (proxyEventHandlers?: IAttributeProxies) => {
        return (scope: ng.IScope,
                element: ng.IAugmentedJQuery,
                attrs: ng.IAttributes,
                controllers: any) => {
            this.swUtil.initComponent(attrs, "dropdown");

            const $toggle = element.find(".xui-dropdown__toggle");
            const $action = element.find(".xui-dropdown__action");
            const dropdownCtrl: DropdownController = controllers[0];

            if (!angular.isArray(dropdownCtrl.itemsSource)) {
                throw new Error("Property items-source of component xui-dropdown must be of type Array.");
            }

            if (angular.isFunction(dropdownCtrl.onSecondaryAction)) {
                $toggle.find(".xui-dropdown__display-value").remove();
            } else {
                $action.remove();
            }

            if (dropdownCtrl.itemsSource.every(angular.isArray)) {
                dropdownCtrl.insertSeparators();
            }

            dropdownCtrl.zoomingFn = () => {
                let selected = dropdownCtrl.getSelectedItem();

                if (selected && selected !== "") { // When nothing is selected, not modify scrolling
                    selected = dropdownCtrl.getItemDisplay(selected);
                    let container = $(element).find("ul.xui-dropdown__menu");
                    let elementToZoom = $(element).find("ul li.xui-dropdown__menuitem.xui-listitem--selected");

                    let zoomAttempts = 0;
                    const maxZoomAttempts = 30;
                    const zoomInterval = 10;
                    const zoom = () => {
                        if (container && elementToZoom && elementToZoom.position()) {
                            // sets the zoomed element in the middle of the scroll
                            const desiredPositionTop = container.height() / 2 - elementToZoom.height() / 2;
                            if (Math.abs(elementToZoom.position().top - desiredPositionTop) > 5 &&
                                zoomAttempts < maxZoomAttempts) {
                                container.scrollTop(container.scrollTop() + elementToZoom.position().top -
                                    desiredPositionTop);
                                zoomAttempts++;
                                this.$timeout(zoom, zoomInterval);
                            }
                        }
                    };

                    this.$timeout(zoom, zoomInterval);
                }
            };

            dropdownCtrl.adjustMenuAlignment = () => {
                const menu = element.find(".xui-dropdown__menu");
                const button = element.find(".xui-dropdown__btn-group");
                const canBe: IEdgeDetectionResult = this.edgeDetector.canBe(button, menu);

                // switch menu expand direction if needed
                if (!canBe.placed.bottom && canBe.placed.top) {
                    element.find(".dropdown").addClass("dropup").removeClass("dropdown");
                } else {
                    // default
                    element.find(".dropup").addClass("dropdown").removeClass("dropup");
                }

                // switch menu alignment if needed
                if (!canBe.aligned.right && canBe.aligned.left) {
                    menu.removeClass("dropdown-menu-right");
                } else if (canBe.aligned.right && !canBe.aligned.left) {
                    menu.addClass("dropdown-menu-right");
                } else {
                    // default
                    menu.hasClass("menu-right")
                        ? menu.addClass("dropdown-menu-right")
                        : menu.removeClass("dropdown-menu-right");
                }
            };

            const ngModelCtrl = <ng.INgModelController>controllers[2];
            if (ngModelCtrl) {
                const input = element.find(".xui-dropdown__input");
                const inputNgModelCtrl = input.controller("ngModel");

                dropdownCtrl.initNgModels(ngModelCtrl, inputNgModelCtrl);

                ngModelCtrl.$validators["required"] = (modelValue: any, viewValue: any): boolean => {
                    return dropdownCtrl.isValid(viewValue);
                };

                // select corresponding object from the source array
                if (attrs["isEditable"]) {
                    input.on("blur", () => {
                        const blurDelay = 100; // this delay is needed to wait for possible dropdown select action
                        this.$timeout(() => {
                            let isInArray = false;
                            angular.forEach(dropdownCtrl.itemsSource, (item) => {
                                if ((attrs["displayValue"] ? item[attrs["displayValue"]] : item) === input.val()) {
                                    isInArray = true;
                                    dropdownCtrl.select(item);
                                }
                            });
                            // empty input if its value is not in a source array
                            if (attrs["clearOnBlur"] && !isInArray) {
                                ngModelCtrl.$setViewValue("");
                            }
                        }, blurDelay);
                    });
                }
            }

            // we need to propagate the presence of this css class to internal components
            if (element.hasClass("xui-dropdown--narrow")) {
                dropdownCtrl.isNarrow = true;
            }

            if (proxyEventHandlers) {
                this.xuiInputProxyService.proxyAttributesLink(proxyEventHandlers, dropdownCtrl, scope);
            }
        };
    };
}

export default Dropdown;
