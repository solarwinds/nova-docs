/// <reference path="../../ref.d.ts" />

import InputProxyService from "../../services/inputProxy-service";
import SwUtil from "../../services/swUtil-service";

class DropdownController {
    public static $inject = ["$scope", "$timeout", "xuiInputProxyService","swUtil"];

    public name:string;
    public model:any;
    public itemsSource:any[];
    public selectedItem:any;
    public caption:string;
    public displayFormat:string;
    public displayValueFn:(params:{item:any})=>string;
    public displayValue:string;
    public size:string;
    public helpText:string;
    public onChanged:(params:any) => void;
    public onSecondaryAction:(params:any) => void;
    public itemTemplateUrl:string;
    public icon:string;
    public placeholder:string;
    public isDisabled:boolean;
    public isRequired:boolean;
    public isEditable:boolean;
    public isInputActive:boolean;
    public ngModelCtrl:ng.INgModelController;
    public internalNgModelCtrl:ng.INgModelController; // this is the ng-model controller of the <input type="text" />
    public comboType:string;
    public itemToSelect:any;
    public singleValueHide:boolean;

    // internal variables
    public isDropdownOpen = false;
    public isNarrow = false;
    public zoomingFn:() => void;
    public adjustMenuAlignment:() => void;
    public isBlurred:boolean;
    public separatorTemplateUrl:string;

    constructor(private $scope:ng.IScope, private $timeout:ng.ITimeoutService,
                private xuiInputProxyService:InputProxyService,
            private swUtil: SwUtil) {
        if (!this.itemTemplateUrl) {
            this.itemTemplateUrl = "xui/components/dropdown/templates/dropdown-item-default.html";
        }
        this.separatorTemplateUrl = "xui/components/dropdown/templates/dropdown-separator.html";
        this.isBlurred = false;
        this.addDropDownToggleWatch();
    }

    public initNgModels = (ngModelCtrl:ng.INgModelController, internalNgModelCtrl:ng.INgModelController) => {
        this.ngModelCtrl = ngModelCtrl;
        this.internalNgModelCtrl = internalNgModelCtrl;
        this.ngModelCtrl.$formatters.push((item)=> {
            return this.getItemDisplay(item);
        });
        if (internalNgModelCtrl) {
            this.xuiInputProxyService.proxyModel(internalNgModelCtrl, ngModelCtrl, this.$scope,
                "input", "dropdown");
        }

        this.selectedItem = ngModelCtrl.$viewValue;
    };

    public addDropDownToggleWatch = () => {
        this.$scope.$watch(()=> this.isDropdownOpen, () => {
            if (angular.isFunction(this.zoomingFn) && this.isDropdownOpen) {
                this.zoomingFn();
            }
            if (this.isDropdownOpen) {
                this.adjustMenuAlignment();
            }
        });
    };

    public select = (item:any) => {
        const oldValue = this.selectedItem;
        this.selectedItem = item;
        if (this.ngModelCtrl) {
            this.model = item;
            this.ngModelCtrl.$validate();
        }

        if (angular.isFunction(this.onChanged)) {
            this.$timeout(() => {
                this.onChanged({newValue: item, oldValue: oldValue});
            });
        }
    };

    public getSelectedItem():any {
        if (angular.isDefined(this.itemToSelect)) {
            return this.itemToSelect;
        }
        if (this.ngModelCtrl) {
            return this.ngModelCtrl.$modelValue;
        }
        return this.selectedItem;
    }

    public isItemSelected(item:any):boolean {
        return this.getSelectedItem() === item;
    }

    public getFilterValue(viewValue:any) {
        return this.displayValue ? {[this.displayValue]: viewValue} : viewValue;
    }

    public getItemDisplay = (item:any):any => {
        if (!item) {
            return "";
        }
        if (this.displayValue) {
            return item[this.displayValue];
        } else if (angular.isFunction(this.displayValueFn)) {
            const value = this.displayValueFn({item: item});
            if (value) {
                return value;
            }
        }
        return item;
    };

    public getDisplayValueFormatted = (item:any):string => {
        if (!item) {
            return "";
        }
        if (this.displayFormat) {
            const displayedItem = this.getItemDisplay(item);
            // handle the case where item isn't empty
            // but is garbage w.r.t this.displayValue
            if (!displayedItem) {
                return "";
            }
            return this.swUtil.formatString(this.displayFormat, displayedItem);
        }

        return this.getItemDisplay(item);
    };

    public action = () => {
        if (angular.isFunction(this.onSecondaryAction)) {
            this.$timeout(() => {
                this.onSecondaryAction({selectedItem: this.getSelectedItem()});
            });
        }
    };

    public isValid = (value?:any):boolean => {
        const selectedItem = angular.isDefined(value) ? value : this.getSelectedItem();
        return (!this.isRequired || (angular.isDefined(selectedItem) && selectedItem !== "" && selectedItem !== null));
    };

    public displayPlaceholder = ():boolean => {
        return angular.isDefined(this.placeholder) &&
            angular.isUndefined(this.getSelectedItem());
    };

    public isDromboBox() {
        return this.isEditable && this.comboType === "drombo";
    }

    public wasFocused = ():boolean => {
        return this.ngModelCtrl && this.ngModelCtrl.$touched;
    };

    public isInErrorState = ():boolean => {
        if (this.isEditable) {
            return this.wasFocused() && !this.isDisabled && this.ngModelCtrl.$invalid;
        } else if (angular.isDefined(this.ngModelCtrl) && this.ngModelCtrl.$dirty) {
            return !this.isDisabled && !this.isDropdownOpen && !this.isValid();
        } else {
            return !this.isValid() && this.isBlurred === true && !this.isDropdownOpen;
        }
    };

    public showFeedback = ():boolean => {
        return this.isInErrorState() || this.showValidityIcon();
    };

    public showValidityIcon = ():boolean => {
        return this.wasFocused() && this.isInErrorState();
    };

    public onInputFocus = ():void => {
        this.isInputActive = true;
        this.isDropdownOpen = false;
    };

    public onInputBlur = ():void => {
        this.isInputActive = false;
    };

    public showDropdown = ():boolean => {
        if (this.singleValueHide) {
            return !this.isDromboBox() && this.itemsSource.length > 1;
        } else {
            return !this.isDromboBox();
        }
    };

    //insert separators and flatten the itemsSource array
    public insertSeparators = (): void => {
        this.itemsSource = this.itemsSource.reduce( (a: any[], b: any[]) => {
            if (a.length) {
                a.push({
                    separator: true
                });
            }
            return a.concat(b);
        }, []);
    }
}

export default DropdownController;
