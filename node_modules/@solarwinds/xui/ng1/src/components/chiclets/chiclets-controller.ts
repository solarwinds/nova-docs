import IMap = xui.IMap;

export interface IChicletsController {
    allowClearAll: boolean;
    autoHide: boolean;
    clearAllLinkText: string;
    itemsSource: string[] | IMap<any[]>;
    isDraggable: boolean;
    orientation: string;
    title: string;
    getGroupIds: () => string[];
    getItemsCount: () => number;
    hasGroups: () => boolean;
    isEmpty: () => boolean;
    itemLabelFn: (params: { itemId: string, groupId: string }) => string;
    removeAllItems: () => void;
    removeItem: (itemId: string, groupId: string) => void;
}

export default class ChicletsController implements IChicletsController {

    public allowClearAll: boolean;
    public autoHide: boolean;
    public clearAllLinkText: string;
    public itemLabelFn: (params: { itemId: string, groupId: string }) => string;
    public itemsSource: string[] | IMap<any[]>;
    public orientation: string;
    public title: string;
    public isDraggable: boolean;
    public onRemove: (params: { itemId?: string, groupId?: string, clearAll?: boolean }) => void;

    constructor() {
        if (angular.isUndefined(this.allowClearAll)) {
            this.allowClearAll = true;
        }
        if (angular.isUndefined(this.autoHide)) {
            this.autoHide = true;
        }
        if (angular.isUndefined(this.isDraggable)) {
            this.isDraggable = false;
        }
        if (angular.isUndefined(this.clearAllLinkText)) {
            this.clearAllLinkText = "Clear All";
        }
        if (angular.isUndefined(this.itemsSource)) {
            throw new Error("ItemsSource property is undefined.");
        }
        if (!angular.isObject(this.itemsSource) && !angular.isArray(this.itemsSource)) {
            throw new Error("Invalid ItemsSource. ItemsSource must be an 'dictionary-like' Object or an Array.");
        }
        if (angular.isUndefined(this.orientation)) {
            this.orientation = "horizontal";
        }
        if (angular.isDefined(this.orientation) && !_.includes(["horizontal", "vertical"], this.orientation)) {
            throw new Error("Invalid orientation: '" + this.orientation +
                "'. Use one of ['horizontal', 'vertical']");
        }
    }

    public get flatItems(): string[] {
        return <string[]>this.itemsSource;
    }

    public get groupedItems(): IMap<any[]> {
        return <IMap<any[]>>this.itemsSource;
    }

    public getGroupIds() {
        if (!this.hasGroups()) {
            return null;
        }
        return _.filter(Object.getOwnPropertyNames(_.omit(this.itemsSource, ["$$hashKey"])),
            (groupId: string) => {
                return this.groupedItems[groupId] && this.groupedItems[groupId].length > 0;
            });
    }

    public getItemsCount() {
        let count = 0;
        if (this.hasGroups()) {
            for (let property in _.omit(this.itemsSource, ["$$hashKey"])) {
                if (this.itemsSource.hasOwnProperty(property)) {
                    count += this.groupedItems[property].length;
                }
            }
        } else {
            count = this.flatItems.length;
        }
        return count;
    }

    public isEmpty() {
        if (this.hasGroups()) {
            const groupedItems = this.groupedItems;
            for (let property in _.omit(groupedItems, ["$$hashKey"])) {
                if (groupedItems.hasOwnProperty(property)
                    && groupedItems[property]
                    && groupedItems[property].length > 0) {
                    return false;
                }
            }
        } else {
            return this.flatItems.length === 0;
        }
        return true;
    }

    public hasGroups() {
        return !angular.isArray(this.itemsSource);
    }

    public removeItem(itemId: string, groupId: string) {
        const onRemoveArgs = {itemId: itemId, groupId: groupId};

        if (this.hasGroups() && groupId) {
            let newGroupItemsSource = _.remove(this.groupedItems[groupId], (x: any) => {
                return x !== itemId;
            });
            this.groupedItems[groupId] = newGroupItemsSource;
        } else {
            let newItemsSource = _.remove(this.flatItems, (x: string) => {
                return x !== itemId;
            });
            this.itemsSource = newItemsSource;

            delete onRemoveArgs.groupId;
        }

        if (this.onRemove) {
            this.onRemove(onRemoveArgs);
        }
    }

    public removeAllItems() {
        if (this.hasGroups()) {
            const groupedItems = this.groupedItems;
            for (let property in _.omit(groupedItems, ["$$hashKey"])) {
                if (groupedItems.hasOwnProperty(property)
                    && groupedItems[property]
                    && groupedItems[property].length > 0) {
                    groupedItems[property].splice(0);
                }
            }
        } else {
            this.flatItems.splice(0);
        }

        if (this.onRemove) {
            this.onRemove({clearAll: true});
        }
    }

}
