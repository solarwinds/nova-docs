import * as _ from "lodash";

/**
 * @ngdoc directive
 * @name xui.directive:xuiIcon
 * @restrict E
 *
 * @description
 * XUI Icon description.
 *
 * @parameters
 * @param {string} [icon-size="medium"] Values: "xsmall", "small", "medium", "large", or "xlarge".
 * @param {xui.IconName} icon The icon to be rendered.
 * @param {string} icon-color The color to be applied to the icon.
 * @param {string} icon-hover-color The color to be applied to the icon on hover.
 * @param {string} tool-tip Tooltip for the icon.
 * @param {xui.IconStatusName} status The status icon to be applied in addition to the current icon.
 * @param {string} counter The counter property to be applied in addition to the current icon. This has to be a valid
 * integer number.
 * @param {string} [text-alignment="none"] Whether or not the icon has spacing for text associated with it. Values:
 * "none", "left", "right", or "left-right".
 * @param {boolean} is-dynamic If "true", this icon will set watches on the icon, icon-size, and status attributes in
 * order to properly update itself in real-time.
 * @param {boolean=} tooltip-append-to-body Appends the tooltip to '$body' instead of the parent element.
 * @param {boolean} [fill-container=false] Icon fills its container, so the hover area can be set. The icon always stays
 * centralized.
 *
 * @example
 *    <example module="xui">
 *        <file src="src/components/icon/docs/icon-examples.html" name="index.html"></file>
 *        <file src="src/components/icon/docs/icon-examples.js" name="app.js"></file>
 *    </example>
 */

const icons = require<any[]>("../../../../data/icons.json");

export interface IIconScope extends ng.IScope {
}

export default class Icon implements ng.IDirective {

    public static $inject = ["swUtil"];

    public sizeMap: {[key: string]: string} = {
        "xlarge": "xui-icon-size-xlg",
        "large": "xui-icon-size-lg",
        "small": "xui-icon-size-sm",
        "xsmall": "xui-icon-size-xsm"
    };

    public textAlignMap: {[key: string]: string} = {
        "left": "xui-icon--text-align-left",
        "right": "xui-icon--text-align-right"
    };

    // this was introduced to provide backward compatibility after changes in naming
    public compatibilityMap: {[key: string]: string} = {
        "interface": "network-interface",
        "vcenter": "virtual-center",
        "vserver": "virtual-server",
        "detatch": "detach",
        "status_shutdown": "status_notrunning"
    };

    public restrict = "E";
    public templateUrl = "xui/components/icon/icon-directive.html";
    public replace = true;
    public transclude = false;
    public scope = {
        toolTip: "@?",
        tooltipAppendToBody: "<?"
    };

    constructor(private swUtil: any) {
    }

    public link = (scope: ng.IScope, element: ng.IAugmentedJQuery, attrs: ng.IAttributes): void => {
        // Observe attribute changes if needed. By default changes are not available.
        // The is-dynamic attribute will enable dynamic changes to the icon otherwise they
        // are rendered once.
        if (attrs["isDynamic"]) {
            _.each(["icon", "status", "iconSize", "cssClass", "iconColor", "iconHoverColor", "textAlignment"],
                (name: string) => {
                if (name in attrs) {
                    attrs.$observe(name, (newValue: string) => {
                        this.renderIcon(element, attrs);
                    });
                }
            });
        }

        this.renderIcon(element, attrs);
    };

    private renderIcon = (element: ng.IAugmentedJQuery, attrs: ng.IAttributes) => {
        let iconName = this.compatibilityMap[attrs["icon"]] || attrs["icon"];
        let icon = this.getIcon(iconName);
        const $elm = element.get(0);
        let className = "xui-icon " + "xui-icon-" + iconName + " ";

        element.children().remove(); //removes the previous icon

        if (icon) {
            if (icon.code) {
                element.append(icon.code);
            }

            if (icon.brushType) {
                className += " " + icon.brushType + " ";
            }

            if (icon.cssAmendments) {
                className += " " + icon.cssAmendments;
            }
        } else {
            className += " xui-icon-not-found";
        }

        if (attrs["iconColor"]) {
            className += " " + attrs["iconColor"] + "-icon";
        }

        if (attrs["iconHoverColor"]) {
            className += " " + attrs["iconHoverColor"] + "-hover-icon";
        }

        if (attrs["iconSize"]) {
            className += " " + this.sizeMap[attrs["iconSize"].toLowerCase()];
        }

        if (attrs["cssClass"]) {
            className += " " + attrs["cssClass"];
        }

        if (attrs["fillContainer"]) {
            className += " " + "xui-icon--fill-container";
        }

        if (attrs["textAlignment"]) {
            const textAlign = attrs["textAlignment"];

            if (textAlign === "left") {
                className += " " + this.textAlignMap["left"];
            }
            if (textAlign === "right") {
                className += " " + this.textAlignMap["right"];
            }
            if (textAlign === "left-right") {
                className += " " + this.textAlignMap["left"] + " " + this.textAlignMap["right"];
            }
        }

        $elm["className"] = className;

        if (attrs["counter"]) {
            const counterAttrValue = +attrs["counter"];

            //The value behind the attribute has to be integer, if not it is removed at all
            if (_.isInteger(counterAttrValue)) {
                element.attr("counter", counterAttrValue);
            } else {
                element.removeAttr("counter");
            }
        }

        if (attrs["status"]) {
            element.attr("status", attrs["status"].toLowerCase());
        }

    };

    private getIcon = (iconName: string) => {
        return _.find(icons, function (el: any) {
            return el.name === iconName;
        });
    };
}
