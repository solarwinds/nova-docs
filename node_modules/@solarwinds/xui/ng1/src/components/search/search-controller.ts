import {Constants} from "../../common/constants";
import Inject from "../../decorators/di";

export interface ISearchRemoteControl {
    search?: (searchTerm?: string) => void;
}

export class SearchController {
    public name: string;
    public itemsSource: any[];
    public value: any;
    public caption: string;
    public placeholder: string;
    public itemLimit: number;
    public displayValue: string;
    public isDisabled: boolean;
    public searchOnChange: boolean;
    public searchDebounce: number;
    public captureFocus: boolean = false;
    public isBusy: boolean = false;
    public isActive: boolean = false;
    public onSearch: (params: {value: any,cancellation: ng.IPromise<void>}) => ng.IPromise<void>;
    public onClear: () => ng.IPromise<void>;
    public onCancel: () => void;
    public onChange: () => void; // [DEPRECATED]
    public remoteControl: ISearchRemoteControl;

    constructor(@Inject("$scope") private $scope: ng.IScope,
                @Inject("$q") private $q: ng.IQService,
                @Inject("xuiConstants") private constants: Constants,
                @Inject("$log") private $log: ng.ILogService,
                @Inject("$translate") private $translate: angular.translate.ITranslateService) {
        if (angular.isFunction(this.onChange)) {
            this.$log.warn("on-change event is now deprecated.");
        }

        if (angular.isUndefined(this.searchDebounce) || !this.searchOnChange) {
            this.searchDebounce = 0;
        }

        this.placeholder = this.placeholder || this.$translate.instant("xui_search_placeholder") + "...";
        this.initializeRemoteControl();
    }

    public search = () => {
        // If we're currently searching
        // then ignore this request to search. This can occur when
        // the user repeatedly clicks the search button
        if (this.isBusy) {
            return;
        }

        // The onSearch expression is not optional but let's ensure its there anyway.
        if (angular.isFunction(this.onSearch)) {
            this.isBusy = this.isActive = true;
            this._cancellation = this.$q.defer<void>();
            this._cancellation.promise.catch(angular.noop);

            this.$scope.$evalAsync(() => {
                const onSearchArgs = {
                    value: this.value,
                    cancellation: this._cancellation.promise
                };

                const result = this.onSearch(onSearchArgs);

                if (result && angular.isFunction(result.catch)) {
                    result.catch(angular.noop);
                }

                if (result && angular.isFunction(result.finally)) {
                    result.finally(() => {
                        this.isBusy = false;
                    });
                } else {
                    this.isBusy = false;
                }
            });
        }
    };

    public onKeypress = ($event: JQueryKeyEventObject) => {
        // this is hang on keyup event, because keypress didn't work for chrome and IE
        this.deactive();

        if ($event.which === this.constants.KEY_CODE.ENTER) {
            this.search();
        }
    };

    public onChangeModel = () => {
        this.cancel();

        if (this.searchOnChange) {
            this.search();
        }

        if (angular.isFunction(this.onChange)) {
            this.$scope.$evalAsync(this.onChange);
        }
    };

    public cancel = () => {
        if (angular.isDefined(this._cancellation)) {
            this._cancellation.resolve();
            this._cancellation = undefined;
        }
    };

    public clear = () => {

        if (!this.isBusy) {
            // 1st click on cancel while searching cancels the search, the 2nd clears the input
            this.value = undefined;
        }
        this.captureFocus = true;

        this.cancel();
        this.deactive();

        if (angular.isFunction(this.onChange)) {
            this.$scope.$evalAsync(this.onChange);
        }

        if (angular.isFunction(this.onCancel)) {
            this.$scope.$evalAsync(this.onCancel);
        }

        if (angular.isFunction(this.onClear)) {
            this.isBusy = this.isActive = true;

            this.$scope.$evalAsync(() => {

                const result = this.onClear();

                if (result && angular.isFunction(result.catch)) {
                    result.catch(angular.noop);
                }

                if (result && angular.isFunction(result.finally)) {
                    result.finally(() => {
                        this.isBusy = false;
                    });
                } else {
                    this.isBusy = false;
                }
            });
        }
    };

    public select = () => {
        this.search();
    };

    public getItemLimit = () => {
        return this.itemLimit || 10;
    };

    public getItemDisplay = (item: any): any => {
        if (item && this.displayValue) {
            return item[this.displayValue];
        }

        return item;
    };

    public getFilterValue = (viewValue: any) => {
        return this.displayValue ? {[this.displayValue]: viewValue} : viewValue;
    };

    private _cancellation: ng.IDeferred<void>;

    private deactive = () => {
       this.isActive = false;
    };

    private initializeRemoteControl = () => {
        if (this.remoteControl) {
            this.remoteControl.search = (searchTerm?: string) => {
                if (angular.isString(searchTerm)) {
                    this.value = searchTerm;
                }
                return this.search();
            };
        }
    };
}

export default SearchController;
