/// <reference path="../../ref.d.ts" />

import Inject from "../../decorators/di";
import {Constants} from "../../common/constants";

class TimeframepickerInlineController {

    public model:xui.ITimeframe;
    public presets:{};
    public onChange:Function;
    public onPresetSelected:Function;
    public hideOpenedPopups:Function;
    public minDate:Date;
    public maxDate:Date;

    public modelDefault:xui.ITimeframe; // used to restore the last valid value

    public distanceToEndDate:number; // to keep distance between start and end-date

    constructor(@Inject("$scope") private $scope:ng.IScope,
                @Inject("$locale") private $locale:ng.ILocaleService,
                @Inject("xuiConstants") private xuiConstants:Constants,
                @Inject("xuiTimeframeService") private xuiTimeframeService:xui.ITimeframeService,
                @Inject("$timeout") private $timeout:ng.ITimeoutService,
                @Inject("xuiToastService") private xuiToastService:xui.IToastService,
                @Inject("$translate") private $translate:angular.translate.ITranslateService) {
        // Load default quick picks if needed
        if (angular.isUndefined(this.presets)) {
            this.presets = this.xuiTimeframeService.getDefaultPresets();
        } else {
            this.xuiTimeframeService.extendCurrentPresets(this.presets);
        }

        // Load time frame preset if needed
        if (angular.isUndefined(this.model)) {
            const defaultKey:string = Object.keys(this.presets)[0];
            this.loadTimeframeIntoModel(defaultKey);
        } else {
            if (this.model.selectedPresetId) {
                this.loadTimeframeIntoModel(this.model.selectedPresetId);
            } else {
                if (!this.model.startDatetime || !this.model.endDatetime) {
                    const defaultKey:string = Object.keys(this.presets)[0];
                    this.loadTimeframeIntoModel(defaultKey);
                }
            }
        }
    }

    public getPresetTitle = (value:xui.ITimeframePreset) => {
        return value.name;
    };

    public selectPreset = (key:string, value:xui.ITimeframePreset) => {
        const timeFrame = this.xuiTimeframeService.getTimeframe(value.startDatetimePattern, value.endDatetimePattern);
        timeFrame.selectedPresetId = key;

        this.setModel(timeFrame);

        if (angular.isFunction(this.onPresetSelected)) {
            this.onPresetSelected();
        }
    };

    public isPresetSelected = (key:string) => {
        return this.model.selectedPresetId === key;
    };

    private isFocused:boolean = false;

    public onChangeInternal() {
        // We want to prevent any invalid state, so we use previous model if needed
        if (!this.isFocused) {
            this.validateCombination();
        }

        // clear 'selectedPresetId' value
        if (this.model.selectedPresetId) {
            // this is called also after some preset is selected, so we want to skip clearing 'selectedPresetId' value
            // at this situation
            const timeFrame = this.xuiTimeframeService.getTimeframeByPresetId(this.model.selectedPresetId);

            if (!this.model.startDatetime || !this.model.endDatetime ||
                this.xuiTimeframeService.isDifferent(this.model, timeFrame)) {
                this.model.selectedPresetId = null;
            }
        }

        if (angular.isFunction(this.onChange)) {
            this.onChange();
        }
    };

    public onBlurInternal() {
        this.validateCombination();

        if (!this.model.startDatetime || !this.model.endDatetime) {
            this.model = angular.copy(this.modelDefault);
            this.xuiToastService.info(this.$translate.instant("xui_timeframePicker_validation_empty"));
        } else {
            this.modelDefault = angular.copy(this.model);
        }
        this.isFocused = false;
    };

    public onFocusInternal() {
        this.hideOpenedPopups();

        // We want to prevent any invalid state, so we need to have current model available
        this.modelDefault = angular.copy(this.model);
        this.isFocused = true;
    };

    private validateCombination() {

        if (this.model.startDatetime && this.model.endDatetime) {
            if (this.model.startDatetime >= this.model.endDatetime) {
                let newdate = new Date();
                newdate.setTime(this.model.startDatetime.getTime() + this.distanceToEndDate);

                this.model.endDatetime = newdate;

                this.xuiToastService.info(this.$translate.instant("xui_timeframePicker_validation_interval"));
            } else {
                this.updateDistanceToEndDate(this.model.startDatetime, this.model.endDatetime);
            }
        }
    }

    private loadTimeframeIntoModel(key:string) {
        const timeFrame = this.xuiTimeframeService.getTimeframeByPresetId(key);

        this.setModel(timeFrame);
    };

    private setModel(timeFrame:xui.ITimeframe) {
        this.model = this.model || <xui.ITimeframe>{};
        this.model.startDatetime = timeFrame.startDatetime;
        this.model.endDatetime = timeFrame.endDatetime;
        this.model.selectedPresetId = timeFrame.selectedPresetId;

        this.updateDistanceToEndDate(timeFrame.startDatetime, timeFrame.endDatetime);
    };

    private updateDistanceToEndDate(newStartDatetime:Date, newEndDatetime:Date) {
        // console.log("Distance to EndDate in hours: " + this.distanceToEndDate/3600000);
        this.distanceToEndDate = newEndDatetime.getTime() - newStartDatetime.getTime();
    };
}
export default TimeframepickerInlineController;
