import SlidableController from "./slidable-controller";
import Inject from "../../decorators/di";
import {Constants} from "../../common/constants";
import IDraggingPosition = xui.IDraggingPosition;

/**
 * @ngdoc directive
 * @name xui.directive:xuiSlidable
 * @restrict A
 *
 * @description
 * XUI component for sliding elements with constraints based on mouse events. The boundary is automatically the parent
 * element. The slided element and its parent element must have relative or absolute position.
 *
 * @parameters
 * @param {Function(JQueryMouseEventObject): IDraggingPosition =} on-drag Callback what is triggered  when the target
 * is being dragged. If it returns the positions, the handler will use them, so this is a way to explicitly manage the
 * behavior of the dragged target.
 * @param {Function(JQueryMouseEventObject) =} on-drag-start Callback that is triggered when target is starting to
 * be dragged.
 * @param {Function(JQueryMouseEventObject) =} on-drag-stop Callback that is triggered when target is no longer
 * being dragged.
 * @param {Function(JQueryKeyEventObject) =} on-drag-cancel Callback that is triggered when drag is canceled by
 * pressing ESC key.
 * @param {Function(JQueryEventObject) =} on-resized Callback that is triggered when the slidable container
 * has been resized.
 * @param {boolean = false} is-drag-disabled The disable state of the slidability.
 * @param {number = null} horizontal-step The slider will be enforced only the n * step pixel X values where n is
 * integer and >= 0; If the value is not defined or not bigger than 0, it will be ignored.
 * @param {number = null} vertical-step The slider will be enforced only the n * step pixel Y values where n is integer
 * and >= 0; If the value is not defined or not bigger than 0, it will be ignored.
 * @param {number = null} vertical-step-shift A value which shifts the starting points of the vertical steps.
 * If negative or no value is given, it will be ignored.
 * @param {number = null} horizontal-step-shift A value which shifts the starting points of the horizontal steps.
 * If negative or no value is given, it will be ignored.
 * @example
 * <example module="xui">
 *   <file src="src/components/slidable/docs/slidable-examples.html" name="index.html"></file>
 *   <file src="src/components/slidable/docs/slidable-examples.js" name="app.js"></file>
 * </example>
 */

export default class Slidable implements ng.IDirective {

    constructor(@Inject("$document") private $document: ng.IDocumentService,
                @Inject("$window") private $window: ng.IWindowService,
                @Inject("xuiConstants") private xuiConstants: Constants) {
    }

    public restrict = "A";
    public controller = SlidableController;
    public controllerAs = "slidable";
    public bindToController = {
        onDrag: "&?",
        onDragStart: "&?",
        onDragStop: "&?",
        onDragCancel: "&?",
        isDragDisabled: "<?",
        onResized: "&?",
        horizontalStep: "<?",
        verticalStep: "<?",
        horizontalStepShift: "<?",
        verticalStepShift: "<?",
    };

    public link = (scope:ng.IScope, element:ng.IAugmentedJQuery,
                   attrs:ng.IAttributes, ctrl:SlidableController) => {

        const slidableClass = "xui-slidable--handler";

        let xOffset: number;
        let yOffset: number;
        let containerWidth: number;
        let containerHeight: number;
        let targetWidth: number;
        let targetHeight: number;

        element.css("outline", "none");
        element.attr("tabindex", "-1");

        let restrictPosition = (position: IDraggingPosition) => {
            if (
                angular.isNumber(ctrl.verticalStep) &&
                ctrl.verticalStep > 0 &&
                position.top % ctrl.verticalStep !== 0
            ) {
                position.top = Math.round(position.top / ctrl.verticalStep) * ctrl.verticalStep;
                if (angular.isNumber(ctrl.verticalStepShift)) {
                    position.top += ctrl.verticalStepShift;
                }
            }
            if (
                angular.isNumber(ctrl.horizontalStep) &&
                ctrl.horizontalStep > 0 &&
                position.left % ctrl.horizontalStep !== 0
            ) {
                position.left = Math.round(position.left / ctrl.horizontalStep) * ctrl.horizontalStep;
                if (angular.isNumber(ctrl.horizontalStepShift)) {
                    position.left += ctrl.horizontalStepShift;
                }
            }

            if (position.left < 0) {
                position.left = 0;
            }
            if (position.top < 0) {
                position.top = 0;
            }
            if (position.left + targetWidth > containerWidth) {
                position.left = containerWidth - targetWidth;
            }
            if (position.top + targetHeight > containerHeight) {
                position.top = containerHeight - targetHeight;
            }
        };
        let applyPosition = (position: IDraggingPosition, event: JQueryMouseEventObject) => {
            restrictPosition(position);
            let updatedPositions: IDraggingPosition;

            if (angular.isFunction(ctrl.onDrag)) {
                scope.$apply(() => {
                    updatedPositions = ctrl.onDrag({
                        event: event,
                        position
                    });
                });
            }

            if (updatedPositions && angular.isNumber(updatedPositions.left) && angular.isNumber(updatedPositions.top)) {
                position.top = updatedPositions.top;
                position.left = updatedPositions.left;
            }
            element.css("left", position.left);
            element.css("top", position.top);
        };

        let onMove = (event: JQueryMouseEventObject) => {
            let position: IDraggingPosition = {
                left: event.clientX - xOffset,
                top: event.clientY - yOffset
            };
            applyPosition(position, event);
            return false;
        };

        let onTouchmove = (event: any) => {
            if (element.hasClass(slidableClass)) {
                event.preventDefault();
                let position: IDraggingPosition = {
                    left: event.originalEvent.changedTouches[0].clientX - xOffset,
                    top: event.originalEvent.changedTouches[0].clientY - yOffset
                };
                applyPosition(position, event);
            }
        };

        let updateDimensions = () => {
            containerWidth = element.parent().innerWidth();
            containerHeight = element.parent().innerHeight();
            targetWidth = element.outerWidth();
            targetHeight = element.outerHeight();
        };

        element.mousedown((event: JQueryMouseEventObject) => {
            if (ctrl.isDragDisabled || element.hasClass(slidableClass)) {
                return false;
            }
            element.addClass(slidableClass);
            xOffset = event.clientX - element.position().left;
            yOffset = event.clientY - element.position().top;
            updateDimensions();

            this.$document.on("mousemove", onMove);
            if (angular.isFunction(ctrl.onDragStart)) {
                ctrl.onDragStart({event});
            }
        });

        element.bind("touchstart", (event: any) => {
            event.preventDefault();

            if (ctrl.isDragDisabled) {
                return false;
            }

            element.addClass(slidableClass);
            xOffset = event.originalEvent.changedTouches[0].clientX - element.position().left;
            yOffset = event.originalEvent.changedTouches[0].clientY - element.position().top;
            updateDimensions();

            this.$document.on("touchmove", onTouchmove);
            if (angular.isFunction(ctrl.onDragStart)) {
                ctrl.onDragStart({event});
            }
        });

        element.bind("touchend", (event: any) => {
            if (element.hasClass(slidableClass)) {
                element.removeClass(slidableClass);
                this.$document.off("touchmove", onTouchmove);
                if (angular.isFunction(ctrl.onDragStop)) {
                    ctrl.onDragStop({event});
                }
            }
        });

        element.parent().on("resize", (event: JQueryEventObject) => {
            // it's needed for working within popover, popover is closed on resize event
            event.stopPropagation();

            // get previous dimensions
            if (!angular.isNumber(element.parent().innerWidth()) || !angular.isNumber(element.parent().innerHeight())) {
                return;
            }

            const horizontalChangeRate = element.parent().innerWidth() / containerWidth;
            const verticalChangeRate = element.parent().innerHeight() / containerHeight;

            let position: IDraggingPosition = {
                left: element.position().left * horizontalChangeRate,
                top: element.position().top * verticalChangeRate
            };

            element.css("left", position.left);
            element.css("top", position.top);

            if (angular.isFunction(ctrl.onResized)) {
                ctrl.onResized({event});
            }
        });

        this.$document.mouseup((event: JQueryMouseEventObject) => {
            if (element.hasClass(slidableClass)) {
                element.removeClass(slidableClass);
                this.$document.off("mousemove", onMove);

                if (angular.isFunction(ctrl.onDragStop)) {
                    ctrl.onDragStop({event});
                }
            }
        });

        element.on("keydown", (event: JQueryKeyEventObject) => {
            if (event.which === this.xuiConstants.KEY_CODE.ESCAPE) {
                if (element.hasClass(slidableClass)) {
                    element.removeClass(slidableClass);
                    this.$document.off("mousemove", onMove);
                    scope.$apply(() => {
                        if (angular.isFunction(ctrl.onDragCancel)) {
                            ctrl.onDragCancel({event});
                        }
                    });
                }
            }
        });
    }
}
