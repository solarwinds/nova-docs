import IMap = xui.IMap;
import { PopoverController } from "./popover-controller";
import Inject from "../../decorators/di";
import SwUtil from "../../services/swUtil-service";

/**
 * @ngdoc directive
 * @name xui.directive:xuiPopover
 * @restrict A
 *
 * @description
 * XUI Popover component is a popup control which can contain any HTML markup and be applied to block or in-line
 * elements. It can also be understood as a rich tooltip. Note: popover will display inner content of the
 * element, instead, text from the xuiPopover attribute will be placed on the page.
 *
 * @parameters
 * @param {xui.IContentProvider} xuiPopoverContent Text or templateURL to be rendered as popover content.
 * @param {string=} xuiPopoverPlacement Preferred direction to show popover. Values: 'left' or 'right'.
 * @param {string=} xuiPopoverTitle Heading text.
 * @param {string=} xuiPopoverId Unique identifier for the popover.
 * @param {string=} [xuiPopoverTrigger='mouseenter'] Defines what event should trigger the popover. Supports a space
 * separated list of event names. Values: 'mouseenter', 'click', or 'focus'.
 * @param {string=} xuiPopoverIcon Icon decoration for the popover {application, database}. This parameter is passed
 * to the <code>xuiIcon</code> component.
 * @param {string=} xuiPopoverStatus Status decoration for the popover {warning, error}. This parameter is passed
 * to the <code>xuiIcon</code> component. This parameter can be combined with <code>xuiPopoverIcon</code> parameter to
 * dispaly icon with status together, the child status is supported as well.
 * @param {boolean=} xuiPopoverIsDisplayed This parameter provides programmatic access to opening/closing the popover.
 * @param {boolean=} xuiPopoverIsModal Display popover in a modal fashion (with a darkened backdrop on top of the page).
 * @param {function=} xuiPopoverOnShow Callback triggered when popover is being shown.
 * @param {function=} xuiPopoverOnHide Callback triggered when popover is being hidden.
 * @param {object=} xuiPopoverElement This is an advanced property. Use it only if you know what you're doing.
 * Allows you to bind the popover to an element provided through reference. Since Angular doesn't allow passing
 * elements directly, it needs to be passed as <code>{nestedElement: element}</code>.
 *
 * @example
 * <example module="xui">
 *     <file src="src/components/popover/docs/popover-examples.html" name="index.html"></file>
 *     <file src="src/components/popover/docs/popover-examples.js" name="app.js"></file>
 *     <file src="src/components/popover/docs/popover-examples.css" name="app.css"></file>
 * </example>
 */
class Popover implements ng.IDirective {

    private static ArrowMarginVertical = 15;
    private static ArrowSize = 5; // this value is linked to border-width of popover arrow
    private static MouseLeaveDelay = 300;

    public restrict = "EA";
    public replace = false;
    public controller = PopoverController;
    public controllerAs = "popoverCtrl";
    public scope = {};
    public bindToController = {
        xuiPopoverContent: "&?",
        xuiPopoverPlacement: "@?",
        xuiPopoverTitle: "@?",
        xuiPopoverId: "@?",
        xuiPopoverTrigger: "@?",
        xuiPopoverStatus: "@?",
        xuiPopoverIcon: "@?",
        isDisplayed: "=?xuiPopoverIsDisplayed",
        xuiPopoverIsModal: "@?",
        xuiPopoverOnShow: "&?",
        xuiPopoverOnHide: "&?"
    };

    private trigger = {
        click: "click",
        mouseEnter: "mouseenter",
        mouseLeave: "mouseleave",
        focus: "focus",
        blur: "blur",
    };

    private destroyHandlers: Function[] = [];
    private attachTo: ng.IAugmentedJQuery;

    constructor(
        @Inject("$rootScope") private $rootScope: ng.IRootScopeService,
        @Inject("$xuiPopover") private $xuiPopover: xui.IPopoverProvider,
        @Inject("$templateCache") private $templateCache: ng.ITemplateCacheService,
        @Inject("$compile") private $compile: ng.ICompileService,
        @Inject("$parse") private $parse: ng.IParseService,
        @Inject("$document") private $document: ng.IDocumentService,
        @Inject("$window") private $window: ng.IWindowService,
        @Inject("$uibPosition") private $position: any,
        @Inject("swUtil") private swUtil: SwUtil,
        @Inject("xuiScrollService") private scrollService: xui.IScrollService,
        @Inject("$timeout") private $timeout: ng.ITimeoutService
    ) {
    }

    private getXuiPopover(scope: ng.IScope, attrs: ng.IAttributes): ng.IAugmentedJQuery {
        const attrPopover = attrs["xuiPopoverElement"];
        return attrPopover && this.$parse(attrPopover)(scope.$parent).nestedElement;
    }

    public link = (
        scope: ng.IScope,
        element: ng.IAugmentedJQuery,
        attrs: ng.IAttributes,
        ctrl: PopoverController
    ) => {
        if (!this.attachTo) {
            const options = this.$xuiPopover.options;
            this.attachTo = options.attachTo
                ? angular.element(options.attachTo)
                : angular.element("body");
        }

        const popoverElement = this.getXuiPopover(scope, attrs) || element;

        // create the popover element using the template and scope
        const modalHtml = String(this.$templateCache.get("xui/components/popover/popover-modal.html")).trim();
        const modalTemplate = angular.element(modalHtml);

        // compile and prepare the popover
        const popupLinkFn = this.$compile(modalTemplate);
        const popover = this.preparePopover(scope, popoverElement, ctrl, popupLinkFn);

        // grab the template to be rendered in the popover, compile it with the parent scope
        // and append to the content wrapper
        const contentHtml = ctrl.getContent();
        const content = angular.element(contentHtml);
        this.$compile(content)(scope.$parent);

        const contentWrapper = modalTemplate.find(".xui-popover__content");
        contentWrapper.append(content);

        // generate unique identifier that will be added to both parent and popover elements and used to pair these
        // elements in protractor tests
        const popoverId = `xui-popover__${this.swUtil.nextUid()}`;
        popoverElement.attr("popover-uid", popoverId);
        popover.attr("popover-uid", popoverId);

        // add backdrop element when modal
        if (ctrl.isModal()) {
            const backdrop = angular.element("<div class='xui-popover__backdrop modal-backdrop in' \
                ng-if='popoverCtrl.isBackdropVisible()' \
                ng-click='popoverCtrl.hideModal($event)'></div>");
            this.$compile(backdrop)(scope);

            //if there is a place to attach to, do it.  Otherwise, append it to this element
            const attachTarget = angular.element("#xuiAttachTarget");
            if (attachTarget.length) {
                attachTarget.append(backdrop);
            } else {
                element.append(backdrop);
            }
        }
    };

    private apply = (func: Function) =>
        this.$rootScope.$apply.bind(this.$rootScope, func);

    private preparePopover = (
        scope: ng.IScope,
        element: ng.IAugmentedJQuery,
        ctrl: PopoverController,
        popupLinkFn: ng.ITemplateLinkingFunction
    ): ng.IAugmentedJQuery => {
        const popover = popupLinkFn(scope.$new(false));
        popover.hide().appendTo(this.attachTo);

        scope.$watch(() => ctrl.isDisplayed, (value: boolean) => this.onDisplayChanged(value, popover, element, ctrl));

        const scrollCallback = () => {
            if (ctrl.isDisplayed) {
                this.$timeout(() => {
                    this.position(popover, element, ctrl, true);
                }, 0);
            }
        };
        this.scrollService.bind(scrollCallback);

        // this callback have same scope as callback in ellipsis
        const resizeCallback = (e: JQueryEventObject) => {
            // Hiding popover on window.resize
            // Exclusion for orion-ui-components.swWorkflowTip component, that will be hidden only
            // if resize was triggered by window itself, but not by any of the children (user interaction)
            if (!(<any> e.target === <any> this.$window || !_.includes(ctrl.triggers, "none"))) {
                return;
            }
            // if ellipsis directive was used this callback cannot be executed
            if (angular.element("body").hasClass("resized-tooltip")) {
                return;
            }
            scope.$apply(ctrl.hide);
        };

        angular.element(this.$window).bind("resize", resizeCallback);

        this.registerTriggers(popover, element, ctrl);

        scope.$on("$destroy", () => {
            this.scrollService.unbind(scrollCallback);
            angular.element(this.$window).unbind("resize", resizeCallback);
            popover.remove();
            this.destroyHandlers.forEach(f => f());
            element.removeAttr("popover-uid");
        });
        return popover;
    };

    private onDisplayChanged = (
        displayPopover: boolean,
        popover: ng.IAugmentedJQuery,
        element: ng.IAugmentedJQuery,
        ctrl: PopoverController
    ) => {
        if (displayPopover === true) {
            // allows properly calculate width of popover before show to user
            popover.css("visibility", "hidden").show();
            this.$timeout(() => {
                this.position(popover, element, ctrl, true);
                popover.hide().css("visibility", "visible").stop().fadeIn(300);
            });

            if (angular.isFunction(ctrl.xuiPopoverOnShow)) {
                ctrl.xuiPopoverOnShow();
            }
        } else {
            popover.stop().fadeOut(100);

            if (angular.isFunction(ctrl.xuiPopoverOnHide)) {
                ctrl.xuiPopoverOnHide();
            }
        }
    };

    private registerTriggers = (
        popover: ng.IAugmentedJQuery,
        hostElement: ng.IAugmentedJQuery,
        ctrl: PopoverController
    ) => {
        type FixupDelegate = (
            popover: ng.IAugmentedJQuery,
            hostElement: ng.IAugmentedJQuery,
            ctrl: PopoverController
        ) => void;
        const triggerFixups: IMap<FixupDelegate> = {};
        triggerFixups[this.trigger.click] = this.handleClick;
        triggerFixups[this.trigger.mouseEnter] = this.handleMouseEnter;
        triggerFixups[this.trigger.focus] = this.handleFocus;
        let usePointerCursor = true;
        _.each(
            ctrl.triggers,
            (trigger: string) => {
                if (triggerFixups[trigger]) {
                    triggerFixups[trigger](popover, hostElement, ctrl);
                }
                if (trigger === this.trigger.mouseEnter) {
                    usePointerCursor = false;
                }
            }
        );

        if (usePointerCursor === true) {
            hostElement.addClass("xui-popover--click");
        }
    };

    private handleClick = (
        popover: ng.IAugmentedJQuery,
        hostElement: ng.IAugmentedJQuery,
        ctrl: PopoverController
    ): void => {
        hostElement.on(this.trigger.click, () => {
            this.$rootScope.$apply(ctrl.toggle);
        });

        if (!ctrl.xuiPopoverIsModal) {
            const handler = ($event: JQueryEventObject) => {
                if (!(popover[0]).contains(<HTMLElement> $event.target) && !(hostElement[0])
                        .contains(<HTMLElement> $event.target)) {
                    this.$rootScope.$apply(ctrl.hide);
                }
            };

            // set event listeners on document using $timeout service to handle ui-router transition bug between states,
            // which has popover components | UIF-2965
            this.$timeout(() => this.$document.on("click.xui-popover", handler));

            // register a destroy handler to remove the $document event handler
            this.destroyHandlers.push(() => {
                this.$document.off("click.xui-popover", handler);
            });
        }
    };

    private handleMouseEnter = (
        popover: ng.IAugmentedJQuery,
        hostElement: ng.IAugmentedJQuery,
        ctrl: PopoverController
    ): void => {
        let mouseLeaveTimeout: ng.IPromise<void>;

        const leave = () => {
            mouseLeaveTimeout = this.$timeout(
                () => { ctrl.hide(); mouseLeaveTimeout = null; },
                Popover.MouseLeaveDelay
            );
        };

        const enter = () => {
            if (mouseLeaveTimeout) {
                this.$timeout.cancel(mouseLeaveTimeout);
                mouseLeaveTimeout = null;
                return;
            }
            this.$timeout(ctrl.show);
        };

        hostElement.on(this.trigger.mouseEnter, enter);
        hostElement.on(this.trigger.mouseLeave, leave);

        popover.on(this.trigger.mouseEnter, enter);
        //popover.on(this.trigger.mouseLeave, () => { this.$timeout(ctrl.hide); });
        popover.on(this.trigger.mouseLeave, leave);
    };

    private handleFocus = (
        popover: ng.IAugmentedJQuery,
        hostElement: ng.IAugmentedJQuery,
        ctrl: PopoverController
    ): void => {
        hostElement.on(this.trigger.focus, this.apply(ctrl.show));
        hostElement.on(this.trigger.blur, this.apply(ctrl.hide));
    };

    private isPlacementPossible = (
        popover: ng.IAugmentedJQuery,
        dir: string,
        element: ng.IAugmentedJQuery
    ): boolean => {
        const visibleRect = (<Element> element[0]).getBoundingClientRect();
        const popupWidth = popover[0].offsetWidth + Popover.ArrowSize;
        switch (dir) {
            case "right":
                return jQuery(this.$window.window).width() - visibleRect.right - popupWidth >= 0;
            case "left":
                return visibleRect.left - popupWidth >= 0;
            case "top":
                return jQuery(this.$window.window).height() - visibleRect.top - popover[0].offsetHeight >= 0;
            case "bottom":
                return visibleRect.top + visibleRect.height - popover[0].offsetHeight >= 0;
            default:
                return false;
        }
    };

    private detectPlacement = (
        popover: ng.IAugmentedJQuery,
        element: ng.IAugmentedJQuery,
        placements: string[]
    ): string =>
        _.first(_.filter(placements, p => this.isPlacementPossible(popover, p, element))) || placements[0];

    private position = (
        popover: ng.IAugmentedJQuery,
        element: ng.IAugmentedJQuery,
        ctrl: PopoverController,
        appendToBody: boolean
    ) => {
        const placements = _.uniq([
            ...(ctrl.xuiPopoverPlacement ? [ctrl.xuiPopoverPlacement] : []),
            "right",
            "left"
        ]);
        const hPlacement = this.detectPlacement(popover, element, placements);
        ctrl.placement = hPlacement;
        const placement = hPlacement.concat("-top");
        const position = this.$position.positionElements(element, popover, placement, appendToBody);

        // at this point, the top of the popover is always aligned with the top of the target element.
        // we need to do 2 things:
        // 1.   adjust the y position of the arrow, based on vPlacement
        // 2.   adjust the top of the popover s/t the middle of the arrow is aligned with the middle
        //      of the target element
        // see popover anatomy specifics here: http://rd93uv.axshare.com/#p=ds-hovers

        const arrowTargetPosition = position.top + (<Element> element[0]).getBoundingClientRect().height / 2;
        let arrowMarginTop = 0;
        let yAdjustment = 0;
        if (this.detectPlacement(popover, element, ["top", "bottom"]) === "bottom") {
            // set arrow margin-top to be this.ArrowVMargin above the bottom border
            arrowMarginTop = popover[0].offsetHeight - Popover.ArrowMarginVertical - Popover.ArrowSize * 2 + 3;
            // calculate yAdjustment
            const arrowPosition = position.top + arrowMarginTop + 3;
            yAdjustment = -(arrowPosition - arrowTargetPosition + 2); // +2 for border adjustments
        } else {
            // set arrow margin-top
            arrowMarginTop = Popover.ArrowMarginVertical;
            // calculate yAdjustment
            const arrowPosition = position.top + 17; // 17 = distance from top of popover to middle of arrow
            yAdjustment = arrowTargetPosition - arrowPosition - 4; // -4 for border adjustments
        }
        position.top += yAdjustment;

        ctrl.arrowMarginTop = arrowMarginTop;
        ctrl.popoverPosition = position;
    };
}

export default Popover;
