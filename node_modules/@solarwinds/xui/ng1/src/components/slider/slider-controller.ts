import SliderType = xui.SliderType;
import IDraggingPosition = xui.IDraggingPosition;

export interface ISliderController {
    updateStartValue: (percent: number) => void;
    updateEndValue: (percent: number) => void;

    onFirstButtonDrag: (event: JQueryMouseEventObject, position: IDraggingPosition) => IDraggingPosition;
    onEndButtonDrag: (event: JQueryMouseEventObject, position: IDraggingPosition) => IDraggingPosition;
    onDragStopped: (event: JQueryMouseEventObject) => void;

    onRangeDrag: (event: JQueryMouseEventObject, position: IDraggingPosition) => IDraggingPosition;
    onRangeMouseOver: () => void;
    onRangeMouseLeave: () => void;
    onRangeDragStopped: (event: JQueryMouseEventObject) => void;
    isRangeDragActive: boolean;
    isRangeHovered: boolean;
    preventRangeClick: boolean;
    onDragStarted: (event: JQueryMouseEventObject) => void;
    onDragCanceled: (event: JQueryMouseEventObject) => void;

    onLineClicked: (event: JQueryMouseEventObject) => void;
    onRangeLineClicked: (event: JQueryMouseEventObject) => void;
    onTextInputChange: () => void;
    onResized: (event: JQueryEventObject) => void;
    step: number;

    fractionSize: number;

    startsideSteps: number[];
    endsideSteps: number[];

    isDisabled: boolean;
    isVertical: boolean;
    type: SliderType;
    isTextinputEnabled: boolean;
    updateOnDrag: boolean;
    alignLabelsAside: boolean;
    labelsConnectedByDash: boolean;

    value: number;
    endValue: number;
    startValue: number;
    rememberedValues: ISliderValueModel;
}
export interface ISliderValueModel {
    start: number;
    end: number;
}
export interface ISliderControlOptions {
    rangeLength?: number;
    movingSide?: string;
}
export class SliderController implements ISliderController {
    public static $inject = ["$scope", "$log"];
    public caption: string;
    public unit: string;

    public isDisabled: boolean;
    public isVertical: boolean;
    public updateOnDrag: boolean;
    public type: SliderType;
    public isTextinputEnabled: boolean;
    public alignLabelsAside: boolean;
    public labelsConnectedByDash: boolean;

    public internalValue: number;
    public internalStartValue: number;
    public internalEndValue: number;
    public textValue: any = {value: null};

    public value: number;
    public startValue: number;
    public endValue: number;

    public min: number;
    public max: number;
    public minRange: number;
    public step: number;
    public fractionSize: number;

    public startsideSteps: number[];
    public endsideSteps: number[];
    public rememberedValues: ISliderValueModel = {start: null, end: null};

    public isRangeDragActive: boolean = false;
    public isRangeHovered: boolean = false;
    public preventRangeClick: boolean = false;

    public onChange: (params: { startValue: number; endValue: number, value: number }) => void;

    constructor(private $scope: ng.IScope, private $log: ng.ILogService) {
        this.type = this.type || "range";

        this.internalValue = this.value;
        this.internalEndValue = this.endValue;
        this.internalStartValue = this.startValue;
        this.textValue = this.internalValue;

        this.rememberedValues.start = this.startValue;
        this.rememberedValues.end = this.endValue || this.value;

        $scope.$watch(() => this.internalValue, (newValue, oldValue) => {this.onValueChanged(newValue, oldValue);});

        this.minRange = this.minRange || this.step || 1;
        this.fractionSize = this.fractionSize || 0;
        this.validateValues();
    }
    public onTextInputChange: () => void;
    public onFirstButtonDrag:(event: JQueryMouseEventObject, position: IDraggingPosition) => IDraggingPosition;
    public onEndButtonDrag:(event: JQueryMouseEventObject, position: IDraggingPosition) => IDraggingPosition;

    public onRangeDrag:(event: JQueryMouseEventObject, position: IDraggingPosition) => IDraggingPosition;
    public onRangeDragStopped:(event: JQueryMouseEventObject) => void;
    public onRangeMouseOver: () => void;
    public onRangeMouseLeave: () => void;
    public onDragStarted: (event: JQueryMouseEventObject) => void;
    public onDragCanceled: (event: JQueryMouseEventObject) => void;

    public  onDragStopped:(event: JQueryMouseEventObject) => void;

    public  onLineClicked: (event: JQueryMouseEventObject) => void;
    public  onRangeLineClicked: (event: JQueryMouseEventObject) => void;
    public  onResized: (event: JQueryEventObject) => void;

    public updateStartValue(percent: number) {
        this.internalStartValue = Math.round(this.min + percent * (this.max - this.min));
    }

    public updateEndValue(percent: number) {
        this.internalEndValue = Math.round(this.min + percent * (this.max - this.min));

        if (this.type === "single") {
            this.internalValue = this.internalEndValue;
        }
    }

    private onValueChanged (newValue: number, oldValue: number) {
        if (newValue === oldValue) {
            return;
        }
        this.textValue = this.internalValue;
    }

    private validateValues() {
        if (this.min === undefined) {
            throw new Error("xui-slider 'min' property must be specified");
        }
        if (this.max === undefined) {
            throw new Error("xui-slider 'max' property must be specified");
        }

        if (
            !angular.isNumber(this.fractionSize) ||
            this.fractionSize  < 0 ||
            this.fractionSize !== parseInt(this.fractionSize.toString(), 10)
        ) {
            throw new Error("xui-slider 'fraction-size' property must be an integer positive value");
        }

        if (this.type === "single") {
            if (this.internalValue === undefined) {
                throw new Error("xui-slider in single mode must has 'value' property specified");
            }
            if (this.internalValue < this.min) {
                throw new Error("xui-slider 'value' property must be greater or equal to 'min' property");
            }
            if (this.internalValue > this.max) {
                throw new Error("xui-slider 'value' property must be less or equal to 'max' property");
            }

            this.internalEndValue = this.internalValue;
        }

        if (this.type === "range") {
            if (this.internalStartValue === undefined) {
                throw new Error("xui-slider in range mode must has 'start-value' property specified");
            } else if (this.internalStartValue < this.min) {
                throw new Error("xui-slider 'start-value' property must be greater or equal to 'min' property");
            }

            if (this.internalEndValue === undefined) {
                throw new Error("xui-slider in range mode must has 'end-value' property specified");
            } else if (this.internalEndValue > this.max) {
                throw new Error("xui-slider 'end-value' property must be less or equal to 'max' property");
            }

            if (this.internalStartValue > this.internalEndValue) {
                throw new Error("xui-slider 'start-value' property must be less or equal to 'end-value' property");
            }

            if ((this.endValue - this.startValue) < this.minRange) {
                throw new Error(`xui-slider 'start-value' and 'end-value' distance must be great or equal
                 to 'min-range' property`);
            }
        }
    }

    public controlValues(values: ISliderValueModel, options?: ISliderControlOptions): ISliderValueModel {
        // if not number => latest
        if (isNaN(values.end)) {
            values.end = this.endValue = this.value;
        }

        const fractualValue: number = Math.pow(10, this.fractionSize);
        values.start = Math.round(values.start * fractualValue) / fractualValue;
        values.end = Math.round(values.end * fractualValue) / fractualValue;

        // check min range IN THE DRAG
        if (
            this.type === "range" &&
            options &&
            options.movingSide === "end" &&
            values.end - values.start < this.minRange
        ) {
            values.end = values.start + this.minRange;
        }
        if (
            this.type === "range" &&
            options &&
            options.movingSide !== "end" &&
            values.end - values.start < this.minRange
        ) {
            values.start = values.end - this.minRange;
        }

        // fit to step =>
        if (angular.isNumber(this.step) && this.step > 0) {
            values.start = Math.round((values.start - this.min) / this.step) * this.step
                + this.min;
            const lastStepPosition = this.max - ((this.max - this.min) % this.step);

            if (this.max - values.end < (this.max - lastStepPosition) / 2) {
                values.end = this.max;
            } else {
                values.end = Math.round((values.end - this.min) / this.step) * this.step
                    + this.min;
            }
        }

        // if lower, higher, then min or max => min or max
        values.start = this.minMax(values.start, this.min, this.max);
        values.end = this.minMax(values.end, this.min, this.max);

        // if moving range as whole
        if (options && options.rangeLength && angular.isNumber(options.rangeLength) && options.rangeLength > 0) {
            if (values.end - options.rangeLength < this.min) {
                values.start = this.min;
                values.end = this.min + options.rangeLength;
            }
            if (values.start + options.rangeLength > this.max) {
                values.end = this.max;
                values.start = this.max - options.rangeLength;
            }
        }

        return values;
    }

    public flushChange(applyDigestLoop?: boolean) {
        this.startValue = this.internalStartValue;
        this.value = this.endValue = this.internalEndValue;

        if (applyDigestLoop) {
            this.$scope.$apply();
        }

        if (this.onChange) {
            this.onChange({
                startValue: this.startValue,
                endValue: this.endValue,
                value: this.value
            });
        }
    }

    public minMax(value: number, min: number, max: number): number {
        if (value < min)  {
            return min;
        }
        if (value > max) {
            return max;
        }
        return value;
    };
}

export default SliderController;
