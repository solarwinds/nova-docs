import {SliderController, ISliderValueModel} from "./slider-controller";
import SwUtil from "../../services/swUtil-service";

/**
 * @ngdoc directive
 * @name xui.directive:xuiSlider
 * @restrict E
 *
 * @description
 * Slider element provides solution for quick and easy selecting value or value-pair (range) between an interval.
 *
 * @parameters
 * @param {string=} caption Caption of the component.
 * @param {string=} unit The unit written after the caption.
 * @param {boolean} [is-disabled=false] Expression to disable the slider.
 * @param {string} [type='range'] Type of the slider. Values: 'range' or 'single'.
 * @param {number} value The value of the slider. Required if slider's type='single'.
 * @param {number} start-value The starting value for  the slider. Required if slider's type='range'.
 * @param {number} end-value The ending value for the slider. Required if slider's type='range'.
 * @param {number} min The minimum settable value of the slider.
 * @param {number} max The maximum settable value of the slider.
 * @param {number} min-range The minimum range if slider's type='range'.
 * @param {number} step The slider will be enforced to allow only the n * step values where n is integer and
 * greater than 0.
 * @param {Function} on-change Callback that is invoked on user initiated value change
 * @param {boolean} [is-textinput-enabled=false] If set to true and slider type is "single", the slider has text
 * field that accepts direct input. Will not display a value above the handler.
 * @param {boolean} [update-on-drag=false] If set to true, the value model will also change when dragging.
 * @param {number} [fraction-size=0] The number of decimal places to round the values to.
 * @example
 *    <example module="xui">
 *        <file src="src/components/slider/docs/slider-examples.html" name="index.html"></file>
 *        <file src="src/components/slider/docs/slider-examples.js" name="script.js"></file>
 *    </example>
 */

/* upcoming features */
/* @param {boolean=false} is-vertical Expression that set the slider to vertical */
/* @param {boolean=false} is-textinput-enabled Expression that enabling the text input for the
slider with type='single'
 */

interface IDraggingPosition {
    top: number;
    left: number;
}
interface IDraggingElements {
    firstButton: ng.IAugmentedJQuery;
    endButton: ng.IAugmentedJQuery;
    rangeLine: ng.IAugmentedJQuery;
};

export default class Slider implements ng.IDirective {
    public static $inject = ["swUtil", "$log", "$timeout"];
    constructor (private swUtil: SwUtil, private $log: ng.ILogService, private $timeout: ng.ITimeoutService) {
    }

    public restrict = "E";
    public require = ["xuiSlider"];
    public scope = {};
    public templateUrl = "xui/components/slider/slider-directive.html";
    public replace = true;
    public transclude = false;
    public controller = SliderController;
    private postLink = (scope: ng.IScope, element: ng.IAugmentedJQuery,
                        attrs: ng.IAttributes, controllers: any) => {

        let component: ng.IAugmentedJQuery = element;
        let firstButton: ng.IAugmentedJQuery = component.find(".xui-slider__button.xui-slider-first-button");
        let endButton: ng.IAugmentedJQuery = component.find(".xui-slider__button.xui-slider-end-button");
        let rangeLine: ng.IAugmentedJQuery = component.find(".xui-slider__lines-range");
        let startsideSteps: ng.IAugmentedJQuery = component.find(".xui-slider__lines-startside-steps");
        let firstButtonLabel: ng.IAugmentedJQuery = component.find(".xui-slider__lines-label.xui-slider-first-label");
        let endButtonLabel: ng.IAugmentedJQuery = component.find(".xui-slider__lines-label.xui-slider-end-label");
        let slidePaneDimension: number;
        let buttonRadius: number = endButton.width();
        let rangePosition: IDraggingPosition;

        let isIE11 = !$("html").hasClass("promises");
        if (isIE11) {
            // UIF-3892: Jquery doesn't get the width properly in IE11 so we set it proportionally to box-shadow
            const spreadRadius = endButton.css("box-shadow")
                .match(/(-?\d+px)|(rgb\(.+\))/g)[3]
                .replace(/[^-\d\.]/g, "");
            buttonRadius = 2 * (parseInt(spreadRadius, 10));
        }

        let ctrl: SliderController = controllers[0];

        let getDimension = ():number => {
            return component.find(".xui-slider__lines").width();
        };

        this.swUtil.initComponent(attrs, " slider");

        let setLabelAlignment = (dist: number) => {

            if (ctrl.type !== "range" || ctrl.isVertical) {
                return;
            }
            if (!endButtonLabel.length) {
               endButtonLabel = component.find(".xui-slider__lines-label.xui-slider-end-label");
            }
            const startLabelWidth:number = firstButtonLabel.width();
            const endLabelWidth:number = endButtonLabel.width();
            ctrl.alignLabelsAside = startLabelWidth / 2 + endLabelWidth / 2  + buttonRadius > dist;
            ctrl.labelsConnectedByDash = dist < 2 * buttonRadius + 1;

        };

        let updateRangeLine = (): boolean => {
            let startPosition: JQueryCoordinates = firstButton.position();
            let endPosition: JQueryCoordinates = endButton.position();
            if (!endButtonLabel.length) {
                endButtonLabel = component.find(".xui-slider__lines-label.xui-slider-end-label");
            }

            if (ctrl.type === "single") {
                startPosition = {
                    left: 0,
                    top: 0
                };
            }

            if (ctrl.isVertical) {
                this.$log.error("Vertical mode is not public and not implemented, please don't use it.");
                return false;
            }
            let length: number = endPosition.left - startPosition.left + buttonRadius;
            let from: number = 0;

            if (ctrl.type !== "single") {
                from = startPosition.left + buttonRadius;
                length = endPosition.left - startPosition.left;
            }

            rangeLine.width(length);
            rangeLine.css("left", from);
            setLabelAlignment(length);

            startsideSteps.css("width", from);
        };

        let singleSliderValueToPixel = (value: number): IDraggingPosition => {
            const pixel: number = (value - ctrl.min) /
                (ctrl.max - ctrl.min) *
                (slidePaneDimension - 2 * buttonRadius);
            return ctrl.isVertical ?
                {top: pixel, left: 0} :
                {top: 0, left: pixel};
        };
        let singleSliderPixelToValue = (position: IDraggingPosition): number => {
            const buttonPosition = ctrl.isVertical ? position.top : position.left;
            const percent:number = buttonPosition /
                (slidePaneDimension - 2 * buttonRadius);
            return ctrl.min + percent * (ctrl.max - ctrl.min);
        };

        let rangeSliderValueToPixel = (value: number, isEnd?: boolean) => {
            let pixel: number = (value - ctrl.min) /
                (ctrl.max - ctrl.min) *
                (slidePaneDimension - 4 * buttonRadius);
            if (isEnd) {
                pixel += 2 * buttonRadius;
            }
            return ctrl.isVertical ?
            {top: pixel, left: 0} :
            {top: 0, left: pixel};
        };

        let rangeSliderStartValueToPixel = (value: number): IDraggingPosition => {
            return rangeSliderValueToPixel(value);
        };
        let rangeSliderEndValueToPixel = (value: number): IDraggingPosition => {
            return rangeSliderValueToPixel(value, true);
        };

        let rangeSliderPixelToStartValue = (position: IDraggingPosition): number => {
            const buttonPosition = ctrl.isVertical ? position.top : position.left;
            let percent:number = buttonPosition /
                (slidePaneDimension - 4 * buttonRadius);
            return ctrl.min + percent * (ctrl.max - ctrl.min);
        };
        let rangeSliderPixelToEndValue = (position: IDraggingPosition): number => {
            const buttonPosition: number = ctrl.isVertical ? position.top : position.left;
            const percent: number = (buttonPosition - 2 * buttonRadius) /
                (slidePaneDimension - 4 * buttonRadius);
            return ctrl.min + percent * (ctrl.max - ctrl.min);
        };

        let drawStepPoints = () => {
            ctrl.startsideSteps = [];
            ctrl.endsideSteps = [];
            if (!angular.isNumber(ctrl.step) || ctrl.step <= 0) {
                return;
            }
            const stepsCount: number = Math.floor((ctrl.max - ctrl.min) / ctrl.step);

            for (let i = 0; i <= stepsCount; i++) {
                const stepPoint: number = rangeSliderStartValueToPixel(ctrl.min + i * ctrl.step).left
                    + buttonRadius;
                ctrl.startsideSteps.push(stepPoint);
            }

            if (ctrl.type === "single") {
                for (let i = 0; i <= stepsCount; i++) {
                    const stepPoint: number = singleSliderValueToPixel(ctrl.min + i * ctrl.step).left
                        + buttonRadius;
                    ctrl.endsideSteps.push(stepPoint);
                }
                if ((ctrl.max - ctrl.min) % ctrl.step !== 0) {
                    ctrl.endsideSteps.push(singleSliderValueToPixel(ctrl.max).left + buttonRadius);
                }
            }
            if (ctrl.type === "range") {
                for (let i = 0; i <= stepsCount; i++) {
                    const stepPoint: number = rangeSliderEndValueToPixel(ctrl.min + i * ctrl.step).left
                        + buttonRadius;
                    ctrl.endsideSteps.push(stepPoint);
                }
                if ((ctrl.max - ctrl.min) % ctrl.step !== 0) {
                    ctrl.endsideSteps.push(rangeSliderEndValueToPixel(ctrl.max).left + buttonRadius);
                }
            }
        };

        ctrl.onFirstButtonDrag = (event: JQueryMouseEventObject,
                                              position: IDraggingPosition): IDraggingPosition => {

            const startValue: number = rangeSliderPixelToStartValue(position);
            const endValue: number = rangeSliderPixelToEndValue(endButton.position());
            const controlledValues: ISliderValueModel =
                ctrl.controlValues({start: startValue, end: endValue}, {movingSide: "start"});
            if (startValue !== controlledValues.start) {
                position = rangeSliderStartValueToPixel(controlledValues.start);
            }
            ctrl.internalStartValue =
                controlledValues.start;

            updateRangeLine();
            if (ctrl.updateOnDrag) {
                ctrl.flushChange();
            }
            return position;
        };

        ctrl.onEndButtonDrag = (event: JQueryMouseEventObject,
                                            position: IDraggingPosition): IDraggingPosition => {
            const endValue: number = ctrl.type === "single" ?
                singleSliderPixelToValue(position) :
                rangeSliderPixelToEndValue(position);
            const startValue: number = ctrl.type === "single" ?
                ctrl.min :
                rangeSliderPixelToStartValue(firstButton.position());
            const controlledValues: ISliderValueModel =
                ctrl.controlValues({start: startValue, end: endValue}, {movingSide: "end"});
            if (endValue !== controlledValues.end) {
                position = ctrl.type === "single" ?
                    singleSliderValueToPixel(controlledValues.end) :
                    rangeSliderEndValueToPixel(controlledValues.end);
            }
            ctrl.textValue = ctrl.internalValue = ctrl.internalEndValue =
                controlledValues.end;
            updateRangeLine();
            if (ctrl.updateOnDrag) {
                ctrl.flushChange();
            }
            return position;
        };

        ctrl.onDragStopped = () => {
            ctrl.flushChange(true);
        };

        let setPositionsFromValues = () => {
            slidePaneDimension = getDimension();
            endButtonLabel = component.find(".xui-slider__lines-label.xui-slider-end-label");
            firstButtonLabel = component.find(".xui-slider__lines-label.xui-slider-first-label");
            rangePosition = component.find(".xui-slider__lines-range").position();

            let startPosition: IDraggingPosition = rangeSliderStartValueToPixel(ctrl.internalStartValue);
            let endPosition: IDraggingPosition = ctrl.type === "single" ?
                singleSliderValueToPixel(ctrl.internalValue) :
                rangeSliderEndValueToPixel(ctrl.internalEndValue);

            if (ctrl.isVertical) {
                firstButton.css("top", startPosition.top);
                endButton.css("top", endPosition.top);
            } else {
                firstButton.css("left", startPosition.left);
                endButton.css("left", endPosition.left);
            }
            drawStepPoints();
            updateRangeLine();

            this.$timeout(function() {
                scope.$digest(); // apply changes asap to the next digest to avoid delay UIF-5461
            });
        };

        ctrl.onDragCanceled = () => {
            ctrl.isRangeDragActive = false;
            ctrl.internalStartValue = ctrl.rememberedValues.start;
            ctrl.internalValue = ctrl.internalEndValue = ctrl.rememberedValues.end;
            setPositionsFromValues();
            ctrl.flushChange();
        };
        ctrl.onDragStarted = () => {
            ctrl.rememberedValues.start = ctrl.internalStartValue;
            ctrl.rememberedValues.end = ctrl.type === "single" ?
                ctrl.internalValue : ctrl.internalEndValue;
        };

        ctrl.onLineClicked = (event: JQueryMouseEventObject) => {
            const position: IDraggingPosition = {
                left: event.offsetX,
                top: event.offsetY
            };
            const clickedPosition: number = ctrl.isVertical ?
                position.top : position.left;

            const firstButtonPosition: number = ctrl.isVertical ?
                firstButton.position().top : firstButton.position().left;

            let clickedValue: number;
            let controlledValues: ISliderValueModel;

            if (ctrl.type !== "range") {
                clickedValue = singleSliderPixelToValue(position);
                controlledValues = ctrl.controlValues({
                    start:ctrl.min,
                    end: clickedValue
                });
                ctrl.internalEndValue = ctrl.internalValue = controlledValues.end;
            }

            if (ctrl.type === "range" && clickedPosition < firstButtonPosition) {
                clickedValue = rangeSliderPixelToStartValue(position);
                controlledValues = ctrl.controlValues({
                    start: clickedValue,
                    end: ctrl.max
                });
                ctrl.internalStartValue = controlledValues.start;
            }

            if (ctrl.type === "range" && clickedPosition > firstButtonPosition) {
                clickedValue = rangeSliderPixelToEndValue(position);
                controlledValues = ctrl.controlValues({
                    start:ctrl.min,
                    end: clickedValue
                });
                ctrl.internalEndValue = ctrl.internalValue = controlledValues.end;
            }

            setPositionsFromValues();
            ctrl.flushChange();
        };

        ctrl.onRangeLineClicked = (event: JQueryMouseEventObject) => {
            event.preventDefault();
            if (ctrl.preventRangeClick) {
                return;
            }
            const rangeLineLength: number = ctrl.isVertical ?
                rangeLine.height() : rangeLine.width();
            const clickedPosition: number = ctrl.isVertical ?
                event.offsetY : event.offsetX;
            const position: IDraggingPosition = {
                top: clickedPosition + rangeLine.position().top - buttonRadius,
                left: clickedPosition + rangeLine.position().left - buttonRadius
            };

            let clickedValue: number;
            let controlledValues: ISliderValueModel;

            if (ctrl.type !== "range") {
                clickedValue = singleSliderPixelToValue(position);
                controlledValues = ctrl.controlValues({
                        start: ctrl.min,
                        end: clickedValue
                });
                ctrl.internalEndValue = ctrl.internalValue = controlledValues.end;
            }
            if (ctrl.type === "range" && clickedPosition > rangeLineLength / 2) {
                const startValue: number = rangeSliderPixelToStartValue(firstButton.position());
                clickedValue = rangeSliderPixelToEndValue(position);
                controlledValues = ctrl.controlValues(
                    {
                        start: startValue,
                        end: clickedValue
                    },
                    {
                        movingSide: "end"
                    }
                );
                ctrl.internalEndValue = ctrl.internalValue = controlledValues.end;
            }
            if (ctrl.type === "range" && clickedPosition < rangeLineLength / 2) {
                const endValue: number = rangeSliderPixelToEndValue(endButton.position());
                clickedValue = rangeSliderPixelToStartValue(position);
                controlledValues = ctrl.controlValues(
                    {
                        start: clickedValue,
                        end: endValue
                    },
                    {
                        movingSide: "start"
                    }
                );
                ctrl.internalStartValue = controlledValues.start;
            }
            setPositionsFromValues();
            ctrl.flushChange();
        };

        ctrl.onTextInputChange = () => {
            const controlledValues = ctrl.controlValues({start: 0, end: Number(ctrl.textValue)});

            ctrl.internalEndValue = ctrl.internalValue = ctrl.textValue = controlledValues.end;
            setPositionsFromValues();
            ctrl.flushChange();
        };

        ctrl.onRangeDrag = (event: JQueryMouseEventObject,
            position: IDraggingPosition): IDraggingPosition => {
            //preconception: range slider would be never used in vertical way
            ctrl.isRangeDragActive = true;
            ctrl.preventRangeClick = true;
            position.top = rangePosition.top;

            const startButtonPosition: IDraggingPosition = {
                top: position.top,
                left: position.left - buttonRadius
            };

            const firsButtonValue: number = rangeSliderPixelToStartValue(startButtonPosition);
            const rangeLength: number = ctrl.internalEndValue - ctrl.internalStartValue;
            const controlledValues: ISliderValueModel = ctrl.controlValues(
                {
                    start: firsButtonValue,
                    end: firsButtonValue + rangeLength
                },
                {
                    rangeLength: rangeLength
                }
            );

            ctrl.internalStartValue = controlledValues.start;
            ctrl.internalEndValue = controlledValues.end;
            position.left = rangeSliderStartValueToPixel(controlledValues.start).left + buttonRadius;
            setPositionsFromValues();

            if (ctrl.updateOnDrag) {
                ctrl.flushChange();
            }
            return position;
        };

        ctrl.onRangeDragStopped = (event: JQueryMouseEventObject) => {
            ctrl.isRangeDragActive = false;
            ctrl.preventRangeClick = false;
            ctrl.flushChange(true);
        };

        ctrl.onRangeMouseOver = () => {
            if (ctrl.isDisabled) {
                return;
            }
            ctrl.isRangeHovered = true;
        };
        ctrl.onRangeMouseLeave = () => {
            ctrl.isRangeHovered = false;
            ctrl.isRangeDragActive = false;
        };

        ctrl.onResized = (event: JQueryEventObject) => {
            setPositionsFromValues();
        };
        scope.$watch(() => ctrl.step, (newValue, oldValue) => {
            if (oldValue !== newValue) {
                setPositionsFromValues();
            }
        });

        scope.$watch(() => ctrl.internalEndValue, (newValue, oldValue) => {
           if (newValue === oldValue) {
               return;
           }
        });
        scope.$watch(() => ctrl.internalStartValue, (newValue, oldValue) => {
            if (newValue === oldValue) {
                return;
            }
        });

        setPositionsFromValues();
    };

    public controllerAs = "vm";

    public bindToController = {
        name: "@?",
        caption: "@?",
        unit: "@?",
        type: "@?",
        step: "<?",

        isDisabled: "<?",
        isVertical: "<?",
        isTextinputEnabled: "<?",
        updateOnDrag: "<?",

        value: "=?",
        startValue: "=?",
        endValue: "=?",

        min: "<",
        max: "<",
        minRange: "<?",

        fractionSize: "<?",
        onChange: "&?"
    };

    public compile = (element: ng.IAugmentedJQuery, attrs: ng.IAttributes) => {
        return {post: this.postLink};
    };
}
