/**
 * @ngdoc directive
 * @name xui.directive:xuiRadio
 * @restrict E
 *
 * @description
 * XUI wrapper for HTML radio input. Like a standard input [type="radio"], this component
 * represents only a single option.
 *
 * @parameters
 * @param {string} name The name of the element.
 * @param {string} ng-model The model that the radio buttons are bound to.
 * @param {string} value String value of this radio button. It allows only one-time binding.
 * @param {string} title Value to be shown as a tooltip.
 * @param {boolean} is-disabled Expression to determine if the radio button should be disabled.
 * @param {boolean} is-required All radio buttons are required by default. If you want conditional validation then
 * supply a boolean expression to this attribute.
 * @param {string} title Title of the radio button.
 * @param {string} help-text Help text for the radio button.
 *
 * @example
 *    <example module="xui">
 *        <file src="src/components/radio/docs/radio-examples.html" name="index.html"></file>
 *        <file src="src/components/radio/docs/radio-examples.js" name="app.js"></file>
 *    </example>
 */

interface IRadioScope extends ng.IScope {
    name: string;
    uid: string;
    input: ng.INgModelController;
    touched(): void;
}

/**
 * Directive function for Radio component
 */
export default class Radio implements ng.IDirective {
    public static $inject = ["swUtil"];

    constructor(private swUtil: any) {
    }

    public restrict = "E";
    public templateUrl = "xui/components/radio/radio-directive.html";
    public replace = true;
    public transclude = true;
    public require = ["^form", "ngModel"];
    public scope = {
        name: "@?", // radio group name - generated if not provided
        value: "@?",
        ngValue: "<?",
        model: "=ngModel",
        isDisabled: "<?",
        isRequired: "<?",
        title: "@?",
        helpText: "@?"
    };

    /**
     * Compile function for radio
     *
     * It handles removing unnecessary attributes from/adding used attribute to component template.
     */
    public compile = (element: ng.IAugmentedJQuery, attrs: ng.IAttributes) => {
        const $input = element.find(".xui-radio-input");

        // value/ng-value are mutually exclusive
        if (attrs["ngValue"]) {
            $input.removeAttr("value");
        } else {
            $input.removeAttr("ng-value");
        }

        // add attributes "on demand" to avoid creation of unnecessary watches
        if (attrs["isDisabled"]) {
            $input.attr("ng-disabled", "isDisabled");
        }

        if (attrs["isRequired"]) {
            $input.attr("ng-required", "isRequired");
        }

        if (!attrs["name"]) {
            attrs["name"] = attrs["ngModel"];
        }

        return {post: this.postLink};
    };

    private postLink = (scope: IRadioScope,
                        element: ng.IAugmentedJQuery,
                        attrs: ng.IAttributes,
                        controllers: ng.IFormController,
                        transclude: ng.ITranscludeFunction) => {
        const TOUCHED_EVENT = "xui:radio:touched";
        const formCtrl = controllers[0];
        const $input = element.find(".xui-radio-input");
        const inputCtrl = formCtrl[scope.name];
        transclude(($clone: ng.IAugmentedJQuery) => {
            if (!$clone.length) {
                // If no content is provided then remove the transclude, validation, and help hint elements.
                element
                    .find(".xui-radio-transclude, .xui-validation, .xui-help-hint")
                    .remove();
            }
        });

        scope.input = inputCtrl;

        // A unique ID must be used for the input id attribute in order to link the label to
        // the input. This allows the label to be interacted with in the same way the input
        // is while hiding the native input.
        scope.uid = "radio_" + this.swUtil.nextUid();

        // IE doesn't respect the :hover pseudo selector in this scenario so we have to manually class
        // the elements.
        element.find(".xui-radio-label")
            .hover(() => {
                $input.toggleClass("xui-radio-hover");
            });

        // blur event must be distributed to all radio button of the same group
        scope.touched = () => {
            if (!inputCtrl.$touched) {
                scope.$root.$broadcast(TOUCHED_EVENT,
                    {form: formCtrl.$name, name: scope.name});
            }
        };

        scope.$on(TOUCHED_EVENT, (e, payload) => {
            if (!inputCtrl.$touched && payload.form === formCtrl.$name
                && payload.name === scope.name) {
                inputCtrl.$setTouched();
            }
        });

        element.bind("click", (event) => {
            if (scope.isDisabled) {
                event.stopImmediatePropagation();
            }
        });
    };
}
