import IWizardStep = xui.IWizardStep;
import WizardController from "./wizard-controller";
import WizardStepController from "./wizard-step-controller";

describe("components >", () => {
    describe("wizard >", () => {
        describe("wizard-controller >", () => {
            let _wizard:WizardController;
            let _$q:ng.IQService;
            let _$timeout:ng.ITimeoutService;
            let _$log:ng.ILogService;
            let _$rootScope:ng.IRootScopeService;
            let _$controller:ng.IControllerService;

            beforeEach(angular.mock.module("xui"));
            beforeEach(inject(($controller:ng.IControllerService, $q:ng.IQService,
                               $timeout:ng.ITimeoutService, $log:ng.ILogService,
                               $rootScope:ng.IRootScopeService) => {
                _$q = $q;
                _$timeout = $timeout;
                _$log = $log;
                _$rootScope = $rootScope;
                _$controller = $controller;

                _wizard = <WizardController>$controller("xuiWizardController", {
                    $q: $q,
                    $log: $log
                });

                const step1 = <IWizardStep>$controller("xuiWizardStepController");
                step1.label = "step1";
                _wizard.addStep(step1, 0);

                const step2 = <IWizardStep>$controller("xuiWizardStepController");
                step2.label = "step2";
                _wizard.addStep(step2, 1);

                const step3 = <IWizardStep>$controller("xuiWizardStepController");
                step3.label = "step3";
                _wizard.addStep(step3, 2);
            }));

            it("should automatically move to first step", () => {
                expect(_wizard.isFirstStep()).toBe(true);
                expect(_wizard.currentStep).toEqual(_wizard.steps[0]);
                expect(_wizard.currentStep.label).toBe("step1");
            });

            it("should have 3 steps", () => {
                expect(_wizard.steps.length).toBe(3);
            });

            it("should move to next step", () => {
                _wizard.next();
                expect(_wizard.currentStep.label).toBe("step2");
            });

            it("should move through all steps", () => {
                _wizard.next();
                _wizard.next();
                expect(_wizard.isLastStep()).toBe(true);
                expect(_wizard.currentStep).toEqual(_wizard.steps[_wizard.steps.length - 1]);
                expect(_wizard.currentStep.label).toBe("step3");
            });

            it("should log failure when attempting to go to current step", () => {
                spyOn(_$log, "warn");
                _wizard.goToStep(_wizard.currentStep);

                expect(_$log.warn).toHaveBeenCalled();
            });

            it("should log failure when passing null step", () => {
                spyOn(_$log, "warn");
                _wizard.goToStep(null);

                expect(_$log.warn).toHaveBeenCalled();
            });

            it("should go to first step", () => {
                _wizard.goToStep(_wizard.steps[0]);

                expect(_wizard.isFirstStep()).toBe(true);
                expect(_wizard.currentStep.label).toBe("step1");
            });

            it("should showNext when not on last step", () => {
                _wizard.goToStep(_wizard.steps[0]);
                expect(_wizard.showNext()).toBe(true);
            });

            it("should not showNext when on last step", () => {
                _wizard.goToStep(_wizard.steps[_wizard.steps.length - 1]);
                expect(_wizard.showNext()).toBe(false);
            });

            it("should not showBack when on first step", () => {
                _wizard.goToStep(_wizard.steps[0]);
                expect(_wizard.showBack()).toBe(false);
            });

            it("should showBack when not on first step", () => {
                _wizard.goToStep(_wizard.steps[1]);
                expect(_wizard.showBack()).toBe(true);
            });

            it("should allow onNextStep to be cancelled", () => {
                const currentStep = _wizard.currentStep;
                _wizard.onNextStep = () => _$q.when(false);
                _wizard.next();

                _$rootScope.$apply();
                expect(_wizard.currentStep).toEqual(currentStep);
            });

            it("should allow onNextStep to be cancelled externally", () => {
                let didCancel = false;
                _wizard.goToStep(_wizard.steps[0]);
                _wizard.onNextStep = (args:any):ng.IPromise<boolean> => {
                    const op = _$timeout(() => {
                        return true;
                    }, 1000);

                    args.cancellation.then(() => {
                        _$timeout.cancel(op);
                        didCancel = true;
                    });

                    return op;
                };
                _wizard.next();
                _$rootScope.$apply();

                _wizard.cancelStepAction();
                _$rootScope.$apply();

                expect(didCancel).toBe(true);
            });

            it("should evaluate onEnterStep,onExitStep,onNextStep expressions when changing steps", () => {
                _wizard.onNextStep = jasmine.createSpy("onNextStep", _wizard.onNextStep);
                _wizard.onEnterStep = jasmine.createSpy("onEnterStep", _wizard.onEnterStep);
                _wizard.onExitStep = jasmine.createSpy("onExitStep", _wizard.onExitStep);

                _wizard.next();

                expect(_wizard.onEnterStep).toHaveBeenCalled();
                expect(_wizard.onExitStep).toHaveBeenCalled();
                expect(_wizard.onNextStep).toHaveBeenCalled();
            });

            it("should evaluate step onEnter and onExit expressions when changing steps", () => {
                _wizard.onNextStep = jasmine.createSpy("onNextStep", _wizard.onNextStep);
                _wizard.onEnterStep = jasmine.createSpy("onEnterStep", _wizard.onEnterStep);
                _wizard.onExitStep = jasmine.createSpy("onExitStep", _wizard.onExitStep);

                const step1 = <WizardStepController>_wizard.steps[0];
                step1.onExit = jasmine.createSpy("onExit");
                const step2 = <WizardStepController>_wizard.steps[1];
                step2.onEnter = jasmine.createSpy("onEnter");

                _wizard.next();

                expect(_wizard.onEnterStep).toHaveBeenCalled();
                expect(_wizard.onExitStep).toHaveBeenCalled();
                expect(_wizard.onNextStep).toHaveBeenCalled();
                expect(step1.onExit).toHaveBeenCalled();
                expect(step2.onEnter).toHaveBeenCalled();
            });

            it("should update step properties when changing steps", () => {
                const step2 = <WizardStepController>_wizard.steps[1];
                expect(step2.active).toBe(false);
                expect(step2.complete).toBe(false);
                expect(step2.visited).toBe(false);
                expect(step2.icon).toBe("step");

                _wizard.next();
                expect(step2.active).toBe(true);
                expect(step2.complete).toBe(false);
                expect(step2.visited).toBe(true);
                expect(step2.icon).toBe("step-active");

                _wizard.next();
                expect(step2.active).toBe(false);
                expect(step2.complete).toBe(true);
                expect(step2.visited).toBe(true);
                expect(step2.icon).toBe("step-complete");
            });

            it("should set all steps to unvisited when summarize() called", () => {
                _wizard.summarize();

                for (let index = 0; index < _wizard.steps.length - 1; index++) {
                    expect(_wizard.steps[index].visited).toBe(false);
                }
            });

            it("should allow onFinish to be cancelled", () => {
                _wizard.goToStep(_wizard.steps[_wizard.steps.length - 1]);
                _wizard.onFinish = () => _$q.when(false);

                _wizard.finish().then((isFinished:boolean) => {
                    expect(isFinished).toBe(false);
                });
                _$rootScope.$apply();
            });

            it("should allow onFinish to be cancelled externally", () => {
                let didCancel = false;
                _wizard.goToStep(_wizard.steps[_wizard.steps.length - 1]);
                _wizard.onFinish = (args:any):ng.IPromise<boolean> => {
                    const op = _$timeout(() => {
                        return true;
                    }, 1000);

                    args.cancellation.then(() => {
                        _$timeout.cancel(op);
                        didCancel = true;
                    });

                    return op;
                };
                _wizard.finish();
                _$rootScope.$apply();

                _wizard.cancelStepAction();
                _$rootScope.$apply();

                expect(didCancel).toBe(true);
            });

            it("should evaluate onFinish expression when finished", () => {
                _wizard.onFinish = jasmine.createSpy("onFinish");

                _wizard.finish();
                _$rootScope.$apply();

                expect(_wizard.onFinish).toHaveBeenCalled();
            });

            it("should evaluate onCancel expression when cancelled", () => {
                _wizard.onCancel = () => true;
                spyOn(_wizard, "onCancel").and.callThrough();
                expect(_wizard.cancel()).toBe(true);
                expect(_wizard.onCancel).toHaveBeenCalled();
            });

            it("should allow onCancel to return false", () => {
                _wizard.onCancel = () => false;
                expect(_wizard.cancel()).toBe(false);
            });

            it("should update currentStepIndex", () => {
                expect(_wizard.currentStepIndex).toBe(0);
                _wizard.next();
                expect(_wizard.currentStepIndex).toBe(1);
                _wizard.next();
                expect(_wizard.currentStepIndex).toBe(2);
                _wizard.back();
                expect(_wizard.currentStepIndex).toBe(1);
            });

            it("should update currentStep when currentStepIndex changes", () => {
                const lastIndex = _wizard.steps.length - 1;
                _wizard.currentStepIndex = lastIndex;

                const lastStep = _wizard.steps[lastIndex];
                expect(_wizard.currentStep).toEqual(lastStep);
            });

            it("should allow inserting steps at specified index", () => {
                const step = <IWizardStep>_$controller("xuiWizardStepController");
                step.label = "inserted-step";

                _wizard.addStep(step, 1);
                _wizard.goToStep(step);

                expect(_wizard.currentStep).toEqual(step);
                expect(_wizard.steps[1]).toEqual(step);
            });

            it("should allow removing steps", () => {
                const stepCount = _wizard.steps.length;
                _wizard.removeStep(_wizard.steps[1]);

                expect(_wizard.steps.length).toBe(stepCount - 1);
            });

            it("should allow removing active step", (done:()=>any) => {
                _wizard.next().then(() => {
                    _wizard.removeStep(_wizard.steps[1]);
                    expect(_wizard.currentStep).toBe(_wizard.steps[0]);
                }).finally(done);

                _$rootScope.$apply();
            });

            it("should not fire events when destroyed", () => {
                _wizard.destroy();

                _wizard.onEnterStep = jasmine.createSpy("onEnterStep", _wizard.onEnterStep);
                _wizard.onExitStep = jasmine.createSpy("onExitStep", _wizard.onExitStep);

                const step1 = <WizardStepController>_wizard.steps[0];
                step1.onExit = jasmine.createSpy("onExit");
                const step2 = <WizardStepController>_wizard.steps[1];
                step2.onEnter = jasmine.createSpy("onEnter");

                _wizard.removeStep(step1);

                expect(_wizard.onEnterStep).not.toHaveBeenCalled();
                expect(_wizard.onExitStep).not.toHaveBeenCalled();
                expect(step1.onExit).not.toHaveBeenCalled();
                expect(step2.onEnter).not.toHaveBeenCalled();
            });
        });
    });
});
