import IWizard = xui.IWizard;
import IWizardStep = xui.IWizardStep;
import IDialogButton = xui.IDialogButton;

export interface IWizardInternal extends IWizard {
    destroy():void;
}

export default class WizardController implements IWizardInternal {
    public static $inject = ["$q", "$log"];

    constructor(private $q:ng.IQService, private $log:ng.ILogService) {
        // Provide defaults
        if (!angular.isDefined(this.canFinish)) {
            this.canFinish = () => false;
        }
        if (!angular.isDefined(this.canCancel)) {
            this.canCancel = () => true;
        }
        if (!angular.isDefined(this.canGoNext)) {
            this.canGoNext = () => true;
        }
        if (!angular.isDefined(this.canGoBack)) {
            this.canGoBack = () => true;
        }
        if (!angular.isNumber(this.currentStepIndex)) {
            this.currentStepIndex = 0;
        }
    }

    public name:string;
    public currentStep:IWizardStep;
    public steps:IWizardStep[] = [];
    public onCancel:() => boolean;
    public onEnterStep:(step:any) => void;
    public onExitStep:(step:any) => void;
    public onNextStep:(args:any) => ng.IPromise<boolean>;
    public onFinish:(args:any) => ng.IPromise<boolean>;
    public canGoNext:() => boolean;
    public canGoBack:() => boolean;
    public canFinish:() => boolean;
    public finishText:string;
    public nextBusyText:string;
    public hideHeader:boolean;
    public hideNext:boolean = false;
    public canCancel:() => boolean;
    public hasSummaryStep:boolean;
    public summaryTranscluded:ng.IAugmentedJQuery;
    public isBusy:boolean = true;
    public allowNavigation:boolean = true;
    public disableHeaderNav:boolean;
    public additionalButtons: IDialogButton[];

    public destroy = () => {
        this._isDestroyed = true;
    };

    /// We use a property accessor here to avoid having to setup a watch on the value. This
    /// approach allows us to respond to the value change as it is set.
    public get currentStepIndex():number {
        return this._currentStepIndex;
    }
    public set currentStepIndex(value:number) {
        if (this.steps && value >= 0 && value < this.steps.length) {
            const step = this.steps[value];
            if (step !== this.currentStep) {
                this.goToStep(step);
            }
        }

        this._currentStepIndex = value;
    }

    public setSummaryStep = (element:ng.IAugmentedJQuery):void => {
        this.summaryTranscluded = element;
        this.hasSummaryStep = !!this.summaryTranscluded;
    };

    public isCurrentStep = (step:IWizardStep):boolean => {
        return step === this.currentStep;
    };

    public cancel = ():boolean => {
        if (angular.isFunction(this.onCancel)) {
            return this.onCancel();
        }
        return true;
    };

    public next = ():ng.IPromise<boolean> => {
        const stepIndex = this.steps.indexOf(this.currentStep);

        if (stepIndex >= this.steps.length - 1) {
            throw new Error("No more steps.");
        }

        const nextStep = this.steps[stepIndex + 1];

        if (angular.isFunction(this.onNextStep)) {
            this._cancellation = this.$q.defer<void>();

            const onNextArgs = {
                from: this.currentStep,
                to: nextStep,
                cancellation: this._cancellation.promise
            };

            const onNextResult = this.onNextStep(onNextArgs);

            if (onNextResult && angular.isFunction(onNextResult.then)) {
                this.isBusy = true;

                onNextResult.then((canContinue:boolean) => {
                    this._cancellation = null;

                    if (canContinue) {
                        this.completeStep(this.currentStep, nextStep);
                    }

                    return canContinue;
                }).finally(() => {
                    this.isBusy = false;
                }).catch(angular.noop);;

                return onNextResult;
            }
        }

        this.completeStep(this.currentStep, nextStep);

        // Tell the caller we can continue.
        return this.$q.when(true);
    };

    public cancelStepAction = ():void => {
        if (this._cancellation) {
            this._cancellation.resolve();
        }
    };

    public back = ():void => {
        const stepIndex = this.steps.indexOf(this.currentStep);

        if (stepIndex > 0) {
            const previousStep = this.steps[stepIndex - 1];
            this.goToStep(previousStep);
        }
    };

    public finish = ():ng.IPromise<boolean> => {
        if (angular.isFunction(this.onFinish)) {
            this._cancellation = this.$q.defer<void>();

            const onFinishArgs = {
                cancellation: this._cancellation.promise
            };

            const onFinishResult = this.onFinish(onFinishArgs);

            if (onFinishResult && angular.isFunction(onFinishResult.then)) {
                this.isBusy = true;

                onFinishResult.then((canFinish:boolean) => {
                    this._cancellation = null;
                    return canFinish;
                }).finally(() => {
                    this.isBusy = false;
                });

                return onFinishResult;
            }
        }

        return this.$q.when(true);
    };

    public summarize = ():void => {
        _.each(this.steps, (step:IWizardStep) => {
            step.visited = false;
        });
    };

    public addStep = (step:IWizardStep, index:number):void => {
        this.steps.splice(index, 0, step);
        // If the step being added is the currentStepIndex let's go to it.
        if (index === this._currentStepIndex) {
            this.goToStep(step);
        }
    };

    public removeStep = (step:IWizardStep):void => {
        const index = this.steps.indexOf(step);
        if (index >= 0) {
            this.steps.splice(index, 1);
            if (!this._isDestroyed && index === this._currentStepIndex) {
                this.goToStep(this.steps[Math.max(index - 1, 0)]);
            }
        }
    };

    public showBack = ():boolean => {
        return this.allowNavigation && !this.isFirstStep() && !(this.isLastStep() && this.hasSummaryStep);
    };

    public showCancel = ():boolean => {
        return this.canCancel() && !(this.isLastStep() && this.hasSummaryStep);
    };

    public showNext = ():boolean => {
        return !this.isLastStep() && !this.hideNext;
    };

    public showFinish = ():boolean => {
        return this.canFinish() || this.isLastStep();
    };

    public goToStep = (newStep:IWizardStep):void => {
        // Invalid step.
        if (!newStep) {
            this.$log.warn("No step provided.");
            return;
        }
        // We're already on the provided step.
        if (this.currentStep === newStep) {
            this.$log.warn("Already on step: " + newStep.label);
            return;
        }
        // We're on the summary step.
        if (this.isLastStep() && this.hasSummaryStep) {
            this.$log.warn("Changing steps is not allowed once the summary step has been reached.");
            return;
        }

        if (!this.canGoBack() && this.currentStepIndex > this.getStepIndex(newStep)) {
            this.$log.info("Cannot go back while canGoBack is disabled.");
            return;
        }

        if (this.currentStep) {
            if (angular.isFunction(this.onExitStep)) {
                this.onExitStep({step: this.currentStep});
            }

            this.currentStep.exit();
        }

        this.currentStep = newStep;
        this.currentStep.enter();

        if (angular.isFunction(this.onEnterStep)) {
            this.onEnterStep({step: this.currentStep});
        }

        const stepIndex = this.steps.indexOf(this.currentStep);
        for (let index = 0; index < stepIndex; index++) {
            const step = this.steps[index];
            if (!step.complete) {
                step.visited = step.complete = true;
            }
        }

        this._currentStepIndex = stepIndex;
        this.isBusy = false;
    };

    public getStepIndex = (step:IWizardStep)=> {
        return this.steps.indexOf(step);
    };

    public completeStep = (currentStep:IWizardStep, nextStep:IWizardStep):void => {
        currentStep.complete = true;
        this.goToStep(nextStep);
    };

    public isFirstStep = () => {
        return (this.currentStep === this.steps[0]);
    };

    public isLastStep = () => {
        return (this.currentStep === this.steps[this.steps.length - 1]);
    };

    private _currentStepIndex:number;
    private _cancellation:ng.IDeferred<void>;
    private _isDestroyed:boolean = false;
}
