/// <reference path="../../ref.d.ts" />

import IPromise = restangular.IPromise;
import IGridSelector = xui.IGridSelector;
import IGridSelection = xui.IGridSelection;
import IGridPagination = xui.IGridPagination;
import IGridSorting = xui.IGridSorting;
import IGridOptions = xui.IGridOptions;
import GridService from "./grid-service";
import IEmptyData = xui.IEmptyData;

export default class GridController {

    public static $inject = ["$scope", "$log", "xuiSortingService", "$timeout",
        "xuiGridService", "xuiSearchingService", "$q", "$translate"];

    // directive parameters
    public itemsSource:any[];

    public pagination:IGridPagination;
    public sorting:IGridSorting;
    public selectionMode:xui.ListSelectionModeEnum;
    public selection:IGridSelection;
    public selectionProperty:string;
    public smartMode:boolean;
    public onPaginationChange:(params:any)=>void;
    public onSortingChange:(params:any)=>void;
    public toolbarTranscluded:ng.IAugmentedJQuery;
    public hideToolbar:boolean;
    public showSelector:boolean;
    public allowSelectAllPages:boolean;
    public searchModel:string;
    public trackBy:string;
    public options:IGridOptions;
    public emptyData: IEmptyData;
    public showEmpty: boolean;
    public onSearch:(params:{item:any,cancellation:ng.IPromise<void>}) => ng.IPromise<void>;
    public onClear:() => ng.IPromise<void>;
    public onSearchChange:(params:{item:any}) => ng.IPromise<void>;
    public layout: string;

    // internal variables
    public selector:IGridSelector;

    // paginated/sorted items for smart-mode
    public smartItemsSource:any[];
    // filtered items for smart-mode
    public smartFilteredItemsSourceCount:number;

    private DEFAULT_SEARCH_DEBOUNCE:number = 300;

    constructor(private $scope:ng.IScope, private $log:ng.ILogService, private sortingService:any,
                private $timeout:ng.ITimeoutService, private xuiGridService:GridService,
                private xuiSearchingService: xui.ISearchingService, private $q:ng.IQService,
                private $translate:angular.translate.ITranslateService) {
        if (!this.itemsSource) {
            throw new Error("Parameter items-source must be set!");
        }

        if (!this.smartMode && !this.selectionProperty && this.itemsSource.length > 0 &&
            angular.isObject(this.itemsSource[0])) {
            throw new Error("'selection-property' must be set with objects when not using smart-mode!");
        }

        if (angular.isUndefined(this.showSelector)) {
            this.showSelector = true;
        }

        if (angular.isUndefined(this.allowSelectAllPages)) {
            this.allowSelectAllPages = true;
        }

        if (!angular.isUndefined(this.options) && !angular.isUndefined(this.options.searchTerm)) {
            this.searchModel = this.options.searchTerm;
        }

        this.selection = this.selection || <IGridSelection>{};
        this.selector = this.selector || this.getSelectorConfig();

        this.layout = this.layout || "default";

        // refresh items when sorting, pagination, search or items source have been changed
        $scope.$watch(()=>this.sorting, this.refreshItems, true);
        $scope.$watch(()=>this.pagination, this.refreshItems, true);
        $scope.$watch(()=>this.itemsSource, this.refreshItems, true);

        $scope.$watch(()=>this.selection.items, this.updateSelector, true);
        $scope.$watch(()=>this.selection.blacklist, this.updateSelector);

        this.setDefaultOptions();
    }

    public setToolbar = (element:ng.IAugmentedJQuery) => {
        this.toolbarTranscluded = element;
    };

    /*
     Components visibility
     */
    public isToolbarPanelVisible = () => {
        return !this.hideToolbar;
    };

    public isListViewPanelVisible = () => {
        return !this.options.hideSearch || this.isSelectorVisible() || this.isSorterVisible();
    };

    public isSorterVisible = () => {
        return this.sorting && this.sorting.sortableColumns && this.getTotal() > 0;
    };

    public isPagerVisible = () => {
        return this.pagination;
    };

    public isSelectorVisible = () => {
        return this.showSelector && this.selectionMode === "multi" && this.getTotal() > 0;
    };

    /**
     * Returns items displayed in the listview. Used by xui-listview.
     */
    public getItemsSource = ():any[] => {
        return this.smartMode ? this.smartItemsSource : this.itemsSource;
    };

    /**
     * Returns total number of items displayed by the listview. Used by xui-pager.
     */
    public getTotal = ():number => {
        return this.smartMode
            ? (this.smartFilteredItemsSourceCount ? this.smartFilteredItemsSourceCount : 0)
            : (this.pagination ? this.pagination.total : 0);
    };

    /**
     * Executes callback for sorting changes. Note: Items are refreshed by a watch defined in the constructor.
     */
    public onSortingChangeInternal(newValue:IGridSorting, oldValue:IGridSorting) {
        // propagate event up
        if (angular.isFunction(this.onSortingChange)) {
            this.onSortingChange({
                newValue: newValue, oldValue: oldValue
            });
        }
    };

    /**
     * Executes callback for pagination changes. Note: Items are refreshed by a watch defined in the constructor.
     */
    public onPaginationChangeInternal = (page:number, pageSize:number, total:number):void => {
        if (pageSize !== this.pagination.pageSize) {
            this.goToFirstPage();
        }

        // propagate event up
        if (angular.isFunction(this.onPaginationChange)) {
            this.onPaginationChange({
                page: page, pageSize: pageSize, total: total
            });
        }
    };

    /**
     * Executes callback for search model changes. Note: Items are refreshed by a watch defined in the constructor.
     */
    public onSearchChangeInternal = () => {
        // propagate event up
        if (angular.isFunction(this.onSearchChange)) {
            this.$log.warn("on-search-change event is now deprecated.");

            // $timeout is used to wait for next digest cycle to have all data updated
            this.$timeout(() => {
                this.onSearchChange({item: this.searchModel});
            });
        }
    };

    /**
     * Executes callback for search execution and refresh grid items.
     */
    public onSearchInternal = (value:any, cancellation:ng.IPromise<void>) => {
        // do the search
        this.searchModel = value;
        this.goToFirstPage();
        this.refreshItems();

        // propagate event up
        if (angular.isFunction(this.onSearch)) {
            return this.onSearch({item: value, cancellation: cancellation});
        }

        return this.$q.when();
    };

    public onClearInternal = () => {
        this.searchModel = undefined;
        this.goToFirstPage();
        this.refreshItems();

        if (angular.isFunction(this.onClear)) {
            return this.onClear();
        }

        return this.$q.when();
    };

    /*
     * Selection related
     */

    public hasSelectedItems = () => {
        if (this.selection.blacklist) {
            return (this.selection.items || []).length < this.getTotal();
        } else {
            return !_.isEmpty(this.selection.items);
        }
    };

    public isEverythingOnPageSelected = () => {
        return this.selector.checked && !this.selector.indeterminate;
    };

    public isEverythingSelected = () => {
        return (this.selection.blacklist) ? _.isEmpty(this.selection.items) :
        (this.selection.items || []).length >= this.getTotal();
    };

    public getSelectedItemCount = () => {
        const selectionLength = (this.selection.items || []).length;
        return this.selection.blacklist ? this.getTotal() - selectionLength :
            this.selection.items.length;
    };

    /**
     * Click handler for selector dropdown items
     */
    public onSelectorItemClick = (item:any) => {
        switch (item.name) {
            case "all":
                this.selectPage();
                break;
            case "none":
                this.unselectAll();
                break;
            case "all pages":
                this.selectAll();
                break;
            default:
                throw new Error("Unknown selector item: " + JSON.stringify(item));
        }
    };

    /**
     * Click handler for selector checkbox
     */
    public onCheckboxClick = () => {
        this.$timeout(()=> {
            if (this.selector.checked) {
                this.selectPage();
            } else {
                if (this.selection.blacklist) {
                    this.unselectAll();
                } else {
                    this.unselectPage();
                }
            }
        });
    };

    public getSelectorState = (selection:IGridSelection):{indeterminate:boolean, checked:boolean} => {
        let pageItems = this.getItemsSource().map(this.getSelectionItemModel);

        const inItemsFn = (needle:any)=> {
            return angular.isObject(needle) ?
                _.some(pageItems, needle) :
                _.includes(pageItems, needle);
        };

        const selectedOnPage = selection.blacklist ?
            _.without(pageItems, ...selection.items) :
            (selection.items || []).filter(inItemsFn);
        // no item from selection is contained on the current page
        if (selectedOnPage.length === 0) {
            return {indeterminate: false, checked: false};
        } else if (selectedOnPage.length === this.getItemsSource().length) {
            return {indeterminate: false, checked: true};
        } else {
            return {indeterminate: true, checked: true};
        }
    };

    public selectAll = () => {
        if (this.smartMode) {
            this.selection.items = this.itemsSource.map(this.getSelectionItemModel);
            this.selection.blacklist = false;
        } else {
            this.selection.items = [];
            this.selection.blacklist = true;
        }
    };

    /*
     Private methods
     */

    private selectPage = () => {
        this.selection.items = this.xuiGridService.select(this.selection.items,
            this.getItemsSource(), this.selectionProperty);
    };

    private unselectPage = () => {
        this.selection.items = this.xuiGridService.unselect(this.selection.items,
            this.getItemsSource(), this.selectionProperty);
    };

    private unselectAll = () => {
        this.selection.items = [];
        this.selection.blacklist = false;
    };

    /**
     * Creates selector configuration
     *
     * @returns IGridSelector
     */
    private getSelectorConfig = ():IGridSelector=> {
        return {
            indeterminate: false,
            checked: false,
            allowSelectAllPages: this.allowSelectAllPages,
            onItemsClick: this.onSelectorItemClick.bind(this),
            onCheckboxClick: this.onCheckboxClick.bind(this)
        };
    };

    private updateSelector = ()=> {
        if (this.isSelectorVisible()) {
            angular.extend(this.selector, this.getSelectorState(this.selection));
        }
    };

    private getSelectionItemModel = (item:any)=> {
        return this.xuiGridService.getSelectionItemModel(item, this.selectionProperty);
    };

    private refreshItems = () => {
        let items = this.itemsSource;

        if (this.smartMode) {
            this.smartItemsSource = this.getSmartItems();
            items = this.smartItemsSource;
        }
        if (_.isObject(this.pagination) && this.pagination.page > 1 && _.isEmpty(items)) {
            this.pagination.page -= 1;
        }

        this.updateSelector();
    };

    private setDefaultOptions = () => {
        if (!this.options) {
            this.options = {};
        }
        if (!_.isString(this.options.searchPlaceholder)) {
            this.options.searchPlaceholder = this.$translate.instant("xui_grid_search") + "...";
        }
        if (!angular.isNumber(this.options.searchDebounce)
            || this.options.searchDebounce < 0) {
            this.options.searchDebounce = this.DEFAULT_SEARCH_DEBOUNCE;
        }
    };

    private goToFirstPage = () => {
        if (this.pagination) {
            this.pagination.page = 1;
        }
    };

    /**
     * Calculates items to be displayed in smart mode, source items are used as base ite
     */
    private getSmartItems = () => {
        const baseIdx = Math.max(0, this.pagination.page - 1) * this.pagination.pageSize;

        let smartItems = angular.copy(this.itemsSource || []);

        // filter items
        if (this.searchModel) {
            smartItems = this.filterItems(smartItems, this.searchModel);
        }

        // store filtered items to get correct total count in pager
        this.smartFilteredItemsSourceCount = smartItems.length;

        // sort items
        if (this.sorting && this.sorting.sortBy && this.sorting.direction !== "original" ) {
            const direction = this.sorting.direction ? this.sorting.direction : "asc";
            smartItems = this.sortingService.sortBy(smartItems, this.sorting.sortBy.id, direction);
        }

        return smartItems.slice(baseIdx, baseIdx + this.pagination.pageSize);
    };

    private filterItems = (items:any[], searchModel:any):any[] => {
        const columns = this.options.searchableColumns || [];
        return this.xuiSearchingService.search(items, columns, searchModel);
    };
}
