/// <reference path="../../ref.d.ts" />

import GridController from "./grid-controller";

/**
 * @ngdoc directive
 * @name xui.directive:xuiGrid
 * @restrict E
 *
 * @description
 * Apollo implementation of grid with sorting, paging, and searching controls. The grid supports two modes:
 * <p>
 * 1. In default mode, it acts as a simple UI control that exposes API of underlying UI controls, that is - pager,
 * sorter, and listview. It displays data in the listview and executes related callbacks on data change invoked by
 * respective controls, but it doesn't apply any changes to displayed data depending on pagination and sorter.
 * </p>
 * <p>
 * 2. With `smart-mode="true"`, it works as a smart control that actually applies sorting and pagination to given data
 * depending on contained sorter and pager controls. In such case, the <code>IGridPagination.total</code> is derived
 * from the length of given data and ignores the supplied value for total.
 * </p>
 * These two can be simply understood as server (default) and client (smart-mode="true") modes.
 *
 * Inner directive <xui-grid-toolbar-container> can be used to define toolbar displayed above the grid.
 *
 * @parameters
 * @param {array} items-source Array of items to be displayed in the table.
 * @param {IGridPagination} pagination-data Data used by pager.
 * @param {IGridSorting} sorting-data Interface data used by sorter.
 * @param {function} on-pagination-change Callback for pagination change.
 * @param {function} on-sorting-change Callback for sorting change.
 * @param {string} header-template-url Template to be used as a header row.
 * @param {string} template-url Template to be used as a fallback for all rows without their own templateURL.
 * @param {function} template-fn Function returning template ID for given row.
 * @param {string} [track-by] The property name that would be used for track by in ngRepeat. If no value is specified,
 * or the property does not exist on the item, the auto-generated by angular hash will be used for key.
 * @param {ListSelectionModeEnum} [selection-mode] Can be "single" or "multi".
 * Use "multi" to display checkboxes on every row. If this value is not set, selection will be disabled.
 * @param {string} selection-property Property of item that will be used for selection model. <i>Attention!</i> It is
 * necessary to use selection-property when smart-mode is not enabled and anytime the items can be dynamic. Storing
 * whole object into selection array (i.e. not using selection-property) could lead to sychronization fail between the
 * selection and items-source.
 * @param {IGridSelection} selection Array of selected items when "multi" selection mode is used.
 * @param {boolean=} [stripe=true] Whether the rows should be striped.
 * @param {boolean} [smart-mode=false] Whether client side processing of pagination/sorting should be used.
 * @param {boolean} [hide-toolbar=false] Whether the toolbar should be visible.
 * @param {boolean} [show-selector=false] Whether the selector should be visible.
 * It works only for selection-mode="multi".
 * @param {boolean} [allow-select-all-pages=true] False to hide "All Pages" item in selector default item list
 * (passed to Selector component).
 * @param {any} [controller] Controller used in listview template.
 * @param {IEmptyData} empty-data Empty data parameters object
 * @param {boolean=} show-empty Show empty state or not(Hiding empty state before data is loaded for example)
 * @param {function} on-search The callback function that is called when the search is applied.
 * @param {function} on-clear The callback function that is called when the search field is cleared.
 * @param {IGridOptions} options Configuration of grid list. Currently available
 * options are:
 * @param {boolean} [options.hidePagination=true] Whether the pagination is displayed or not.
 * @param {boolean} [options.hideSearch = false] Whether the search field is displayed or not.
 * @param {number} options.searchDebounce The debounce time in milliseconds of calling the onSearchChange function.
 * @param {boolean} options.triggerSearchOnChange Whether the search is triggered after each change in search text.
 * @param {string[]} options.searchableColumns Columns which will be checked during search.
 * @param {string} options.searchTerm The initial search term used in the searchbox.
 * @param {string} options.searchPlaceholder The placeholder displayed in search input when no search text
 * is defined.
 * @param {number=} [options.pagerAdjacent="1"] It determines the adjacent for pagination layout. Options are:
 * '1' (extended layout), '0' (minified layout).
 * @param {array} smart-items-source Array of items visible to the user in the current. moment when pagination is
 * applied and smart-mode="true".
 * @param {string} [row-padding="regular"] determines the padding of the row around the content. Options are:
 * 'regular' (15px), 'narrow' (15px; 7px), 'compact' ( 5px; 7px) or 'none' (0px).
 * @param {String=} [layout="default"] If attribute equals to "fill", layout of <strong>xuiGrid</strong> will be
 * changed from default to fill, so <strong>xuiGrid</strong> height will be equal to parent element height. Parent
 * element should have specified height. In case you need to use default layout, set "layout" attribute to "default"
 * or do not specify the attribute at all
 *
 * @example
 *   <example module="xui">
 *       <file name="config.js">
 *            Xui.translations = {
 *                  xui_grid_clear_selection: "Clear selection",
 *                  xui_grid_items_selected: "item(s) selected.",
 *                  xui_grid_select_all: "Select all",
 *                  xui_grid_objects: "objects",
 *                  xui_pager_displaying: "Displaying",
 *                  xui_pager_items_per_page: "Items per Page:",
 *                  xui_pager_next_page: "Next Page",
 *                  xui_pager_of: "of",
 *                  xui_pager_page: "Page",
 *                  xui_pager_pages: "Pages",
 *                  xui_pager_previous_page: "Previous Page",
 *                  xui_progress_cancel: "Cancel",
 *                  xui_selector_all: "All",
 *                  xui_selector_all_pages: "All Pages",
 *                  xui_selector_none: "None"
 *            };
 *       </file>
 *       <file src="src/components/grid/docs/grid-examples.html" name="index.html"></file>
 *       <file src="src/components/grid/docs/grid-examples.js" name="script.js"></file>
 *   </example>
 **/

export default class Grid implements ng.IDirective {
    public restrict = "E";
    public template = require<string>("./grid-directive.html");
    public replace = true;
    public transclude = true;

    public scope = {};
    public bindToController = {
        itemsSource: "=",
        // just "pagination" wasn't possible because it conflicted with Bootstrap `pagination` directive
        pagination: "=paginationData",
        sorting: "=sortingData",
        onPaginationChange: "&",
        onSortingChange: "&",
        headerTemplateUrl: "@",
        templateUrl: "@",
        templateFn: "&",
        selectionMode: "@?",
        selection: "=?",
        selectionProperty: "@",
        stripe: "<?",
        smartMode: "=",
        hideToolbar: "=?",
        showSelector: "=?",
        allowSelectAllPages: "=?",
        controller: "=",
        emptyText: "@?", // [DEPRECATED]
        emptyTemplateUrl: "@?", // [DEPRECATED]
        emptyData: "=?",
        showEmpty: "<?",
        options: "=?",
        onSearch: "&?",
        onClear: "&?",
        onSearchChange: "&?", // [DEPRECATED]
        busy: "<?",
        busyMessage: "@?",
        smartItemsSource: "=?",
        trackBy: "@?",
        rowPadding: "<?",
        busyShowCancelButton:"=?",
        busyOnCancel: "&?",
        layout: "@?"
    };
    public controller = GridController;
    public controllerAs = "vm";
    private fillLayoutClass = "xui-grid--fill";

    public link: ng.IDirectiveLinkFn = (scope: ng.IScope,
                                        element: ng.IAugmentedJQuery,
                                        attrs: ng.IAttributes,
                                        ctrl: GridController) => {
        if (ctrl.layout === "fill") {
           element.addClass(this.fillLayoutClass);
        } else {
            element.css("overflow", "");
            element.removeClass(this.fillLayoutClass);
        }
    };
}
