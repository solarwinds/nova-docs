import DraggableController from "./draggable-controller";
import Inject from "../../decorators/di";
import IDragScrollConstants = xui.IDragScrollConstants;
import xuiDragEvent = xui.xuiDragEvent;
import SwUtil from "../../services/swUtil-service";

/**
 * @ngdoc directive
 * @name xui.directive:xuiDraggable
 * @restrict A
 *
 * @description
 * XUI component for HTML 5 drag.  Will autoscroll window during drag.
 *
 * @parameters
 * @param {object} xuiDraggableObject An object that will be in the drag payload.  Must be serializable.
 * @param {function(event) =} onDragStart Event called when drag is initiated.
 * @param {function(event) =} onDragEnd Event called when dragging ends (either drop or cancel).
 * @param {boolean=} adorner-drag-class Class to attach to dragged copy.
 * @example
 * <example module="xui">
 *   <file src="src/components/dragdrop/docs/dragDrop-examples.html" name="index.html"></file>
 *   <file src="src/components/dragdrop/docs/dragDrop-examples.js" name="app.js"></file>
 * </example>
 */

export default class Draggable implements ng.IDirective {

    constructor(@Inject("$document") private $document: ng.IDocumentService,
                @Inject("$window") private $window: ng.IWindowService,
                @Inject("$timeout") private $timeout: ng.ITimeoutService,
                @Inject("xuiDragScrollConstants") private dragScrollConstants: IDragScrollConstants,
                @Inject("swUtil") private swUtil:SwUtil) {
    }

    public restrict = "A";
    public controller = DraggableController;
    public controllerAs = "draggable";
    public bindToController = {
        onDragStart: "&?",
        onDragEnd: "&?",
        adornerDragClass: "@?"
    };

    private static draggableClass = "xui-drag__draggable";
    private static draggingClass = "xui-drag--dragging";
    private static dragSourceClass = "xui-drag__drag-source";
    private static adornerClass = "xui-drag__drag-container";
    private static adornerHaloClass = "xui-drag__drag-halo";
    private static dragsourceOverlayClass = "xui-drag__drag-source--overlay";

    public link = (scope: ng.IScope, element: ng.IAugmentedJQuery,
                   attrs: ng.IAttributes, ctrl: DraggableController) => {
        //holds the interval ID that checks if a scroll is needed (based off mouse position)
        let autoScrollCheckIntervalId: number;
        let clientX: number, clientY: number;

        let adorner: JQuery, dragsourceOverlay: JQuery;

        const moveDragAdorner = _.throttle((event: JQueryMouseEventObject) => {
            requestAnimationFrame(() => {
                if (adorner) {
                    adorner[0].style.left = event.clientX + "px";
                    adorner[0].style.top = event.clientY + "px";
                }
            });
        }, this.dragScrollConstants.adornerUpdateThrottleInMs, {trailing: false});

        const mouseHook = (event: JQueryMouseEventObject) => {
            clientX = event.clientX;
            clientY = event.clientY;
            moveDragAdorner(event);
        };

        const events: any = {
            "dragstart": (event: xuiDragEvent) => {
                //text selections will be ignored, only element with xui-draggable attribute will be dragged
                this.$window.getSelection().removeAllRanges();

                event = <DragEvent>(<JQueryEventObject>event).originalEvent || event;

                const draggedObject = _.get(scope, attrs["xuiDraggableObject"]);
                let payload: string;
                if (angular.isObject(draggedObject)) {
                    payload = angular.toJson(draggedObject);
                } else {
                    payload = <string>draggedObject;
                }

                const createdNodes = this.createDragVisuals(event, element, ctrl.adornerDragClass);
                adorner = createdNodes.adorner;
                dragsourceOverlay = createdNodes.dragSourceOverlay;

                this.setImageAndData(event, element, payload);

                this.$document.on("dragover", mouseHook);

                scope.$applyAsync(() => ctrl.dragStart(event));
                event.stopPropagation();

                //use native to avoid digests while dragging
                autoScrollCheckIntervalId = setInterval(() => this.autoScroll(clientX, clientY),
                    this.dragScrollConstants.checkIntervalInMs);
            },
            "dragend": (event: xuiDragEvent) => {
                element.removeClass(Draggable.dragSourceClass);
                adorner.remove();
                adorner = null;

                dragsourceOverlay.remove();
                dragsourceOverlay = null;
                scope.$applyAsync(() => ctrl.dragEnd(event));
                event.stopPropagation();

                clearInterval(autoScrollCheckIntervalId);
                this.$document.off("dragover", mouseHook);
            },
        };

        element.addClass(Draggable.draggableClass);
        element.attr("draggable", "true");
        for (let event in events) {
            if (events.hasOwnProperty(event)) {
                element.on(event, events[event]);
            }
        }

        scope.$on("$destroy", () => {
            element.off(Object.keys(events));
        });
    };

    private setImageAndData(event: xuiDragEvent, element: ng.IAugmentedJQuery, payload: string) {
        const anyEvent: any = event;

        if ((typeof DragEvent !== "undefined" && event instanceof DragEvent) || anyEvent.dataTransfer) {
            try {
                if (anyEvent.dataTransfer.setDragImage) {
                    if (this.swUtil.isSafari()) {
                        // Safari supports dragImage in a usable way
                        anyEvent.dataTransfer.setDragImage(element[0], 0, -10);
                    } else {
                        // but other browsers don't so we have to disable it
                        const emptyItem = angular.element("<div>");
                        anyEvent.dataTransfer.setDragImage(emptyItem[0], 0, 0);
                    }
                } else {
                    //IE hack, to ensure there is no drag ghost (it does not support setDragImage)
                    element.hide(0, () => {
                        element.show(1);
                    });
                }
                anyEvent.dataTransfer.dropEffect = "copy";

                //IE only allows text and url in setData, NOTHING ELSE
                anyEvent.dataTransfer.setData("Text", payload);
                anyEvent.dataTransfer.setData("text/plain", payload);
            } catch (e) {
                //silently fail in IE
            }
        }
    }

    private createDragVisuals = (event: xuiDragEvent, element: ng.IAugmentedJQuery, adornerClass: string) => {
        //copy the node being dragged, and add effects
        const adorner = angular.element("<div>");
        adorner.addClass(Draggable.adornerClass);
        if (adornerClass) {
            adorner.addClass(adornerClass);
        }
        const adornerHalo = angular.element("<div>");
        adornerHalo.addClass(Draggable.adornerHaloClass);
        adorner.append(adornerHalo);

        // Safari shows the dragImage natively, so we don't have to fake it
        if (!this.swUtil.isSafari()) {
            const copiedNode = (<any>event.currentTarget).cloneNode(true);
            copiedNode.style.width = element.innerWidth() + "px";
            copiedNode.style.height = element.innerHeight() + "px";
            copiedNode.classList.add(Draggable.draggingClass);
            copiedNode.removeAttribute("draggable");
            adorner.append(copiedNode);
        }

        //if there is a place to attach to, do it.  Otherwise, place it after the copied node
        const attachTarget = angular.element("#xuiAttachTarget");
        if (attachTarget.length) {
            attachTarget.append(adorner);
        } else {
            element.after(adorner);
        }

        //this should be the overlay that fades out the existing node
        const dragSourceOverlay = angular.element("<div>");
        dragSourceOverlay.addClass(Draggable.dragsourceOverlayClass);

        //Fix for Google Chrome, appending of overlay in regular way cause unreasonable dispatch of "dragend" event
        this.$timeout(() => {
            element.append(dragSourceOverlay);
        }, 0);

        element.addClass(Draggable.dragSourceClass);

        return {adorner, dragSourceOverlay};
    };

    private autoScroll = (clientX: number, clientY: number) => {
        if (!clientX || !clientY) {
            return;
        }

        const verticalDistPercentage = (clientY / this.$window.innerHeight) * 100;
        const horizontalDistPercentage = (clientX / this.$window.innerWidth) * 100;
        const topScrollBoundary = this.dragScrollConstants.verticalScrollPercentage;
        const bottomScrollBoundary = 100 - this.dragScrollConstants.verticalScrollPercentage;
        const leftScrollBoundary = this.dragScrollConstants.horizontalScrollPercentage;
        const rightScrollBoundary = 100 - this.dragScrollConstants.horizontalScrollPercentage;

        let newX = this.$window.pageXOffset;
        let newY = this.$window.pageYOffset;

        let scrollNeeded = false;
        if (verticalDistPercentage < topScrollBoundary) {
            let throttle =
                (topScrollBoundary - verticalDistPercentage) * this.dragScrollConstants.accelerationFactor;
            newY = newY - throttle;
            scrollNeeded = true;
        }
        if (verticalDistPercentage > bottomScrollBoundary) {
            let throttle =
                (verticalDistPercentage - bottomScrollBoundary) * this.dragScrollConstants.accelerationFactor;
            newY = newY + throttle;
            scrollNeeded = true;
        }
        if (horizontalDistPercentage < leftScrollBoundary) {
            let throttle =
                (leftScrollBoundary - horizontalDistPercentage) * this.dragScrollConstants.accelerationFactor;
            newX = newX - throttle;
            scrollNeeded = true;
        }
        if (horizontalDistPercentage > rightScrollBoundary) {
            let throttle =
                (horizontalDistPercentage - rightScrollBoundary) * this.dragScrollConstants.accelerationFactor;
            newX = newX + throttle;
            scrollNeeded = true;
        }
        if (scrollNeeded) {
            this.$window.scrollTo(newX, newY);
        }
    };
}
