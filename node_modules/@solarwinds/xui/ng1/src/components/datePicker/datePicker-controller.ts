import Inject from "../../decorators/di";
import {Constants} from "../../common/constants";

export default class DatePickerController {
    public datetime: Date;
    public minDate: Date;
    public maxDate: Date;
    public formats = [
        "MM/dd/yyyy",

        "M!/d!/yy",
        "M!/d!/yyyy",
        "yyyy/MMM/d!",
        "yyyy/M!/d!",
        "yy/M!/d!",
        "yy/MMM/d!",
        "d!/M!/yyyy",
        "d!/MMM/yyyy",
        "d!/M!/yy",
        "d!/MMM/yy",

        "M!-d!-yy",
        "M!-d!-yyyy",
        "yyyy-MMM-d!",
        "yyyy-M!-d!",
        "yy-M!-d!",
        "yy-MMM-d!",
        "d!-M!-yyyy",
        "d!-MMM-yyyy",
        "d!-M!-yy",
        "d!-MMM-yy",

        "M! d! yy",
        "M! d! yyyy",
        "yyyy MMM d!",
        "yyyy M! d!",
        "yy M! d!",
        "yy MMM d!",
        "d! M! yyyy",
        "d! MMM yyyy",
        "d! M! yy",
        "d! MMM yy",

        "M!.d!.yy",
        "M!.d!.yyyy",
        "yyyy.MMM.d!",
        "yyyy.M!.d!",
        "yy.M!.d!",
        "yy.MMM.d!",
        "d!.M!.yyyy",
        "d!.MMM.yyyy",
        "d!.M!.yy",
        "d!.MMM.yy"
    ];

    public format: string;
    public dateOptions: angular.ui.bootstrap.IDatepickerConfig = {
        formatYear: "yyyy",
        formatMonth: "MMM",
        startingDay: 1,
        showWeeks: false
    };
    public opened = false;
    public isDisabled: boolean;
    public preserveInsignificant: boolean;
    public iconOnly: boolean;
    public onChange: Function;
    public ngModel: ng.INgModelController;
    public ngModelOptions: ng.INgModelOptions = {
        updateOn: "default blur",
        debounce: { "default": 500, "blur": 0 }
    };
    private lastClosed = 0;

    private _model: Date;
    public get model(): Date {
        return this._model;
    }

    public set model(value: Date) {
        // do this here because the model is bound and set before the ctor is called
        if (angular.isUndefined(this.preserveInsignificant)) {
            this.preserveInsignificant = false;
        }

        if (value instanceof Date && !this.preserveInsignificant) {
            value.setHours(0, 0, 0, 0);
        }
        
        this._model = value;

        if (_.isFunction(this.onChange)) {
            this.onChange();
        }
    }

    constructor(@Inject("$scope") private $scope: ng.IScope,
                @Inject("xuiConstants") private xuiConstants: Constants,
                @Inject("$locale") private $locale: ng.ILocaleService,
                @Inject("xuiToastService") private xuiToastService: xui.IToastService,
                @Inject("$translate") private $translate: angular.translate.ITranslateService,
                @Inject("swUtil") private swUtil: xui.IUtility) {
    }

    public $onInit = (): void => {
        this.format = this.getDateFormat();

        this.$scope.$watch(() => this.opened, (newValue: boolean, oldValue: boolean)=> {
            if (!newValue && oldValue) {
                this.lastClosed = new Date().getTime();
            }
        });
    }

    public $onChanges = (changesObj: any): void => {
        // we need to ensure that min/max date is written to options object

        if (changesObj.minDate) {
            this.dateOptions.minDate = this.removeInsignificantParts(changesObj.minDate.currentValue);
        }

        if (changesObj.maxDate) {
            this.dateOptions.maxDate = this.removeInsignificantParts(changesObj.maxDate.currentValue);
        }
    };

    public open() {
        this.dateOptions.datepickerMode = "day";
        const now = new Date().getTime();
        // this is because the datepicker modal was not closing properly in IE11
        if (now - this.lastClosed > 100) {
            this.opened = true;
        }
    }

    public checkEnter($event: JQueryEventObject) {
        if ($event.keyCode === this.xuiConstants.KEY_CODE.ENTER) {
            this.opened = false;
        }
    }

    public isInErrorState = (): boolean => {
        return this.ngModel && this.ngModel.$touched && !this.isDisabled && this.ngModel.$invalid && !this.opened;
    }

    public validateDate = (): void => {
        if (!(this._model instanceof Date)) {
            return;
        }

        // keep value with only date part for comparison
        const valueDateOnly = this.removeInsignificantParts(this._model);

        let callOnChange = false;

        // min/max date
        if (this.dateOptions.minDate && valueDateOnly < this.dateOptions.minDate) {
            callOnChange = true;
            this._model = this.dateOptions.minDate;
            this.xuiToastService.info(this.$translate.instant("xui_datepicker_minDate"));
        } else if (this.dateOptions.maxDate && valueDateOnly > this.dateOptions.maxDate) {
            callOnChange = true;
            this._model = this.dateOptions.maxDate;
            this.xuiToastService.info(this.$translate.instant("xui_datepicker_maxDate"));
        }

        if (callOnChange && _.isFunction(this.onChange)) {
            this.onChange();
        }
    }

    private getDateFormat() {
        // locate short date is used but modified to show 4 digit year
        let format = this.$locale.DATETIME_FORMATS.shortDate;
        return format.replace(/\byy\b/, "yyyy");
    }

    private removeInsignificantParts = (value?: Date): Date => {
        if (!value) {
            return undefined;
        }

        // create clone because setHours() changes inner state
        const clone = new Date(value.valueOf());
        clone.setHours(0, 0, 0, 0);
        return clone;
    }
}
