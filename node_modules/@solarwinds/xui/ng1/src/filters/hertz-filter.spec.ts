describe("filters >", () => {
    describe("hertz filter >", () => {

        let filter: Function;

        beforeEach(angular.mock.module("xui"));
        beforeEach(angular.mock.module("xui.filters"));
        beforeEach(angular.mock.module("xui.services"));

        beforeEach(inject(($filter: ng.IFilterService) => {
            filter = $filter<Function>("xuiHertz");
        }));

        it("should be 0 MHz", () => {
            expect(filter(0)).toBe("0 MHz");
        });

        it("should be 1 Hz", () => {
            expect(filter(1)).toBe("1 Hz");
        });

        it("should be 1 kHz", () => {
            expect(filter(1000)).toBe("1 kHz");
        });

        it("should be 1 MHz", () => {
            expect(filter(1000 * 1000)).toBe("1 MHz");
        });

        it("should be 1 GHz", () => {
            expect(filter(1000 * 1000 * 1000)).toBe("1 GHz");
        });

        it("should be 1 THz", () => {
            expect(filter(1000 * 1000 * 1000 * 1000)).toBe("1 THz");
        });

        it("should be 1 PHz", () => {
            expect(filter(1000 * 1000 * 1000 * 1000 * 1000)).toBe("1 PHz");
        });

        it("precision works correctly", () => {
            expect(filter(1568, 2)).toBe("1.57 kHz");
        });

        it("precision works correctly #2", () => {
            expect(filter(1568, 4)).toBe("1.5680 kHz");
        });

        it("removing trailing zeros works correctly", () => {
            expect(filter(1000, 4)).toBe("1 kHz");
        });

        it("plus sign works correctly", () => {
            expect(filter(1000, 0, true)).toBe("+1 kHz");
        });

        it("negative sign works correctly", () => {
            expect(filter(-1000)).toBe("-1 kHz");
        });

        it("invalid value should be handled correctly", () => {
            expect(filter(null)).toBe("---");
        });
    });
});
