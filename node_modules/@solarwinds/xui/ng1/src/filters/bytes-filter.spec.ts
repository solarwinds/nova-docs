describe("filters >", () => {
    describe("bytes filter >", () => {

        let filter: Function;

        beforeEach(angular.mock.module("xui"));
        beforeEach(angular.mock.module("xui.filters"));
        beforeEach(angular.mock.module("xui.services"));

        beforeEach(inject(($filter: ng.IFilterService) => {
            filter = $filter<Function>("xuiBytes");
        }));

        it("should be 0 GB", () => {
            expect(filter(0)).toBe("0 GB");
        });

        it("should be 1 B", () => {
            expect(filter(1)).toBe("1 B");
        });

        it("should be 1 kB", () => {
            expect(filter(1024)).toBe("1 KB");
        });

        it("should be 1 MB", () => {
            expect(filter(1024 * 1024)).toBe("1 MB");
        });

        it("should be 1 GB", () => {
            expect(filter(1024 * 1024 * 1024)).toBe("1 GB");
        });

        it("should be 1 TB", () => {
            expect(filter(1024 * 1024 * 1024 * 1024)).toBe("1 TB");
        });

        it("should be 1 PB", () => {
            expect(filter(1024 * 1024 * 1024 * 1024 * 1024)).toBe("1 PB");
        });

        it("precision works correctly", () => {
            expect(filter(1568, 2)).toBe("1.53 KB");
        });

        it("precision works correctly #2", () => {
            expect(filter(1568, 4)).toBe("1.5313 KB");
        });

        it("removing trailing zeros works correctly", () => {
            expect(filter(1024, 4)).toBe("1 KB");
        });

        it("plus sign works correctly", () => {
            expect(filter(1024, 0, true)).toBe("+1 KB");
        });

        it("negative sign works correctly", () => {
            expect(filter(-1024)).toBe("-1 KB");
        });

        it("invalid value should be handled correctly", () => {
            expect(filter(null)).toBe("---");
        });
    });
});
