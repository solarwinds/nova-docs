///<reference path="../ref.d.ts"/>

enum ByteCount {
    str = 2,
    bool = 4,
    num = 8
}

class SwUtil implements xui.IUtility {

    public static $inject = ["$rootScope", "$log", "promiseCache"];

    public defaultPromiseCacheOptions = {
        ttl: 1000 * 900, // 15 minute default
        bustCache: false,
        key: <any>null,
        args: <any>null,
        expireOnFailure: this.cachePromiseFailure,
        localStorageEnabled: false,
        localStorageKey: <any>null
    };

    private nextUniqueId = ["0", "0", "0"];
    private SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
    private MOZ_HACK_REGEXP = /^moz([A-Z])/;

    constructor(private $rootScope:xui.IRootScope, private $log:ng.ILogService, private promiseCache:any) {
    }

    public initComponent(attrs:ng.IAttributes, type:string) {
        if (!attrs["name"]) {
            attrs["name"] = `${type}_${this.nextUid()}`;
        }
    }

    public cachePromise(fn:Function, key:any, options:any) {
        options = angular.extend(this.defaultPromiseCacheOptions, options);
        options.promise = fn;
        options.key = key;
        return this.promiseCache(options);
    }

    public cachePromiseFailure(error:any) {
        this.$log.error(error);

        // Returning true will forcefully expire the cache for this promise.
        return true;
    }

    public countAngularWatchers($element?:ng.IAugmentedJQuery) {
        const watchers = [String];
        const countWatches =  (element:ng.IAugmentedJQuery) => {
            if (element.data()) {
                angular.forEach(["$scope", "$isolatedScope"], (scopeProperty) => {
                    if (element.data().hasOwnProperty(scopeProperty)) {
                        angular.forEach(element.data()[scopeProperty].$$watchers, (watcher) => {
                            watchers.push(watcher);
                        });
                    }
                });
                angular.forEach(element.children(), (childElement) => {
                    countWatches(angular.element(childElement));
                });
            }
        };

        countWatches($element);

        // Remove duplicate watcher
        let watchersWithoutDuplicates = [String];
        angular.forEach(watchers, (item) => {
            if (watchersWithoutDuplicates.indexOf(item) < 0) {
                watchersWithoutDuplicates.push(item);
            }
        });

        return watchersWithoutDuplicates.length;
    }

    public fakeNgModel() {
        return <ng.INgModelController>{
            $fake: true,
            $setTouched: angular.noop,
            $setViewValue: function (value:any) {
                this.$viewValue = value;
                this.$render(value);
                this.$viewChangeListeners.forEach(function (cb:Function) {
                    cb();
                });
            },
            $isEmpty: function (value:any) {
                return ("" + value).length === 0;
            },
            $parsers: <any[]>[],
            $formatters: <any[]>[],
            $viewChangeListeners: <any[]>[],
            $render: angular.noop,
            $setValidity: angular.noop,
            $setPristine: angular.noop,
            $setDirty: angular.noop,
            $validate: angular.noop,
            $setUntouched: angular.noop,
            $rollbackViewValue: angular.noop,
            $commitViewValue: angular.noop,
            $viewValue: angular.noop,
            $modelValue: angular.noop,
            $error: angular.noop,
            $name: "",
            $touched: false,
            $untouched: false,
            $validators: <any[string]>[],
            $asyncValidators: <any[string]>[],
            $pending: false,
            $pristine: false,
            $dirty: false,
            $valid: false,
            $invalid: false
        };
    }

    /**
     * nextUid, from angular.js.
     * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric
     * characters such as "012ABC". The reason why we are not using simply a number counter is that
     * the number string gets longer over time, and it can also overflow, where as the nextId
     * will grow much slower, it is a string, and it will never overflow.
     *
     * @returns an unique alpha-numeric string
     */
    public nextUid() {
        let index = this.nextUniqueId.length;
        let digit:any;
        while (index) {
            index--;
            digit = this.nextUniqueId[index].charCodeAt(0);
            if (digit === 57 /*"9"*/) {
                this.nextUniqueId[index] = "A";
                return this.nextUniqueId.join("");
            }
            if (digit === 90 /*"Z"*/) {
                this.nextUniqueId[index] = "0";
            } else {
                this.nextUniqueId[index] = String.fromCharCode(digit + 1);
                return this.nextUniqueId.join("");
            }
        }
        this.nextUniqueId.unshift("0");
        return this.nextUniqueId.join("");
    }

    public watchBoolean(attrs:ng.IAttributes,
                        property:string,
                        controller?:any,
                        onChanged?:(newValue:boolean) => void) {
        if (property in attrs) {
            const setBool = function (newValue:string) {
                const value = newValue.toLowerCase() === "true";

                if (controller) {
                    controller[property] = value;
                }

                if (angular.isFunction(onChanged)) {
                    onChanged(value);
                }
            };
            setBool(attrs[property]);
            attrs.$observe(property, setBool);
        }
    }

    /**
     * Converts camelCase to dash-case
     * @param camel
     * @returns {string}
     */
    public dashCase(camel:string):string {
        return camel.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    }

    /**
     * Converts snake_case and dash-case to camelCase. Taken from internal angular jqLite implementation
     *
     * Also there is special case for Moz prefix starting with upper case letter.
     * @param name Name to normalize
     */
    public camelCase(name:string):string {
        return name.replace(this.SPECIAL_CHARS_REGEXP, (_, separator, letter, offset)=> {
            return offset ? letter.toUpperCase() : letter;
        }).replace(this.MOZ_HACK_REGEXP, "Moz$1");
    }

    /**
     * Returns the approximate memory footprint (byte count) of the object specified
     * @param {any} object
     * @returns {number} byte count
     */
    public sizeof = (object:any):number => {
        const visitedObjects:any[] = [];
        return this.calculateSizeof(object, visitedObjects);
    };

    /**
     * Indicates whether a given string equals to value of "true"
     */
    public isTrueString = (s: string): boolean => {
        return !!s && s.toLowerCase() === "true";
    };

    /**
     * Formats the target string in the same way as .NET's String.format
     * @param {string} the target string
     * @param {Array<any>} one or more numbers, booleans, or strings to insert
     *              into the target string at the specified location(s)
     * @returns {string} the formatted string
     */
    public formatString(target: string, ...params: Array<any>): string {
        let toString = function (obj: any, format: any) {
            let ctor = function (o) {
                if (typeof o === "number") {
                    return Number;
                } else if (typeof o === "boolean") {
                    return Boolean;
                } else if (typeof o === "string") {
                    return String;
                } else {
                    return o.constructor;
                }
            }(obj);
            let proto = ctor.prototype;
            let formatter = typeof obj !== "string" ?
                (proto ? proto.format || proto.toString : obj.format || obj.toString) :
                obj.toString;
            if (formatter) {
                if (typeof format === "undefined" || format === "") {
                    return formatter.call(obj);
                } else {
                    return formatter.call(obj, format);
                }
            } else {
                return "";
            }
        };

        target = target.replace(/\{\{|\}\}|\{([^}: ]+?)(?::([^}]*?))?\}/g, function (match, num, format) {
            if (match === "{{") {
                return "{";
            }
            if (match === "}}") {
                return "}";
            }
            if (typeof params[num] !== "undefined" && params[num] !== null) {
                return toString(params[num], format);
            } else {
                return match;
            }
        });
        return target;
    }

    private calculateSizeof = (object:any, visitedObjects:any[]):number => {
       if (_.isString(object)) {
            return object.length * ByteCount.str;
        } else if (_.isBoolean(object)) {
            return ByteCount.bool;
        } else if (_.isNumber(object)) {
            return ByteCount.num;
        } else if (_.isObject(object)) {
            if (_.isBuffer(object)) {
                return object.length;
            } else {
                visitedObjects.push(object);
                let bytes = 0;
                _.forOwn(object, (value:any, key:any) => {
                    bytes += this.calculateSizeof(key, visitedObjects);
                    // short-circuit circular refs
                    if (!_.includes(visitedObjects, value)) {
                        bytes += this.calculateSizeof(value, visitedObjects);
                    }
                });
                return bytes;
            }
        } else {
            return 0;
        }
    };

    public isSafari():boolean {
        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    }

    public dateEquals = (date1?: Date, date2?: Date): boolean => {
        if (_.isUndefined(date1) && _.isUndefined(date2)) {
            return true;
        }

        if (_.isNull(date1) && _.isNull(date2)) {
            return true;
        }

        const isDate1 = _.isDate(date1);
        const isDate2 = _.isDate(date2);

        if (isDate1 && !isDate2) {
            return false;
        }

        if (!isDate1 && isDate2) {
            return false;
        }

        if (!isDate1 && !isDate2) {
            return false;
        }

        return date1.valueOf() === date2.valueOf();
    };
}

export default SwUtil;
