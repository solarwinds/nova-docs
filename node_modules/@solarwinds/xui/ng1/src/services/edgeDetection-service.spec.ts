/// <reference path="../ref.d.ts" />
import {default as SpecHelper, ITestScope} from "../specHelper";
import IEdgeDetectionResult = xui.IEdgeDetectionResult;

describe("services >", () => {
    describe("edge detection >", () => {

        let $edgeDetectionService: xui.IEdgeDetectionService;
        let element: ng.IAugmentedJQuery;
        let $window: ng.IWindowService;
        let $scope: ITestScope;
        let $compile: ng.ICompileService;
        const basePointDimensions = {
                x: 50,
                y: 50,
                width: 20,
                height: 10
            },
            parentComponentDimension = {
                width: 100,
                height: 100
            };

        let createHtml = (depositWidth: number, depositHeight: number) => {
            return `<div id="edge-detection">
                  <div id="base-point" style="
                    position: absolute;
                    left: ${basePointDimensions.x}px;
                    top: ${basePointDimensions.y}px;
                    height: ${basePointDimensions.height}px;
                    width:  ${basePointDimensions.width}px;
                  "></div>
                  <div id="deposit" style="
                    width: ${depositWidth}px;
                    height: ${depositHeight}px;
                    display: none;
                  "></div>
                </div>`;
        };

        beforeEach(angular.mock.module("xui.services"));

        beforeEach(inject(($injector: any) => {
            $edgeDetectionService = $injector.get("xuiEdgeDetectionService");
            $window = $injector.get("$window");
            $scope = $injector.get("$rootScope");
            $compile = $injector.get("$compile");
        }));

        describe("placing >", () => {
            let testLeftRightPlacement = (thereIsPlace: boolean, toBeTested: string) => {
                return () => {
                    const adjust: number = thereIsPlace ? -1 : 1;
                    let depositWidth: number = toBeTested === "left" ?
                        basePointDimensions.x :
                    $window.innerWidth - basePointDimensions.x - basePointDimensions.width;
                    depositWidth += adjust;
                    const html = createHtml(depositWidth, 10);
                    element = SpecHelper.getCompiledElement($compile, $scope, html);
                    angular.element(document.body).append(element);

                    let toBePlaced = element.find("#deposit");
                    let basePoint = element.find("#base-point");

                    const result: any = $edgeDetectionService.canBe(basePoint, toBePlaced);

                    element.remove();
                    expect(result.placed[toBeTested]).toBe(thereIsPlace);
                };
            };

            let testTopBottomPlacement = (thereIsPlace: boolean, toBeTested: string) => {
                return () => {
                    const adjust: number = thereIsPlace ? -1 : 1;
                    let depositHeight: number = toBeTested === "bottom" ?
                    $window.innerHeight - basePointDimensions.y - basePointDimensions.height :
                        basePointDimensions.y;
                    depositHeight += adjust;
                    const html = createHtml(10, depositHeight);
                    element = SpecHelper.getCompiledElement($compile, $scope, html);
                    angular.element(document.body).append(element);

                    let toBePlaced = element.find("#deposit");
                    let basePoint = element.find("#base-point");

                    const result: any = $edgeDetectionService.canBe(basePoint, toBePlaced);

                    element.remove();
                    expect(result.placed[toBeTested]).toBe(thereIsPlace);
                };
            };

            it("should give expected result when no right direction is available",
                testLeftRightPlacement(false, "right"));
            it("should give expected result when right direction is available",
                testLeftRightPlacement(true, "right"));

            it("should give expected result when no top direction is available",
                testTopBottomPlacement(false, "top"));
            it("should give expected result when top direction is available",
                testTopBottomPlacement(true, "top"));

            it("should give expected result when no bottom direction is available",
                testTopBottomPlacement(false, "bottom"));
            it("should give expected result when bottom direction is available",
                testTopBottomPlacement(true, "bottom"));

            it("should give expected result when no left direction is available",
                testLeftRightPlacement(false, "left"));
            it("should give expected result when left direction is available",
                testLeftRightPlacement(true, "left"));
        });
        describe("aligning >", () => {
            let testLeftRightAlignment = (thereIsPlace: boolean, toBeTested: string) => {
                return () => {
                    const adjust: number = thereIsPlace ? -10 : 10;
                    let depositWidth: number = toBeTested === "left" ?
                    $window.innerWidth - basePointDimensions.x :
                    basePointDimensions.x + basePointDimensions.width;
                    depositWidth += adjust;
                    const html = createHtml(depositWidth, 10);
                    element = SpecHelper.getCompiledElement($compile, $scope, html);
                    angular.element(document.body).append(element);

                    let toBePlaced = element.find("#deposit");
                    let basePoint = element.find("#base-point");

                    const result: any = $edgeDetectionService.canBe(basePoint, toBePlaced);

                    element.remove();
                    expect(result.aligned[toBeTested]).toBe(thereIsPlace);
                };
            };

            let testTopBottomAlignment = (thereIsPlace: boolean, toBeTested: string) => {
                return () => {
                    const adjust: number = thereIsPlace ? -10 : 10;
                    let depositHeight: number = toBeTested === "bottom" ?
                    basePointDimensions.y + basePointDimensions.height :
                    $window.innerHeight - basePointDimensions.y;
                    depositHeight += adjust;
                    const html = createHtml(10, depositHeight);
                    element = SpecHelper.getCompiledElement($compile, $scope, html);
                    angular.element(document.body).append(element);

                    let toBePlaced = element.find("#deposit");
                    let basePoint = element.find("#base-point");

                    const result: any = $edgeDetectionService.canBe(basePoint, toBePlaced);

                    element.remove();
                    expect(result.aligned[toBeTested]).toBe(thereIsPlace);
                };
            };

            it("should give expected result when no right direction is available",
                testLeftRightAlignment(false, "right"));
            it("should give expected result when right direction is available",
                testLeftRightAlignment(true, "right"));

            it("should give expected result when no top direction is available",
                testTopBottomAlignment(false, "top"));
            it("should give expected result when top direction is available",
                testTopBottomAlignment(true, "top"));

            it("should give expected result when no bottom direction is available",
                testTopBottomAlignment(false, "bottom"));
            it("should give expected result when bottom direction is available",
                testTopBottomAlignment(true, "bottom"));

            it("should give expected result when no left direction is available",
                testLeftRightAlignment(false, "left"));
            it("should give expected result when left direction is available",
                testLeftRightAlignment(true, "left"));
        });

        describe("placing in edge-definer >", () => {
            let testLeftRightPlacementInComponent = (thereIsPlace: boolean, toBeTested: string) => {
                return () => {
                    const adjust: number = thereIsPlace ? -1 : 1;
                    let depositWidth: number = toBeTested === "left" ?
                        basePointDimensions.x :
                    parentComponentDimension.width - basePointDimensions.x - basePointDimensions.width;
                    depositWidth += adjust;
                    const html = createHtml(depositWidth, 10);
                    element = SpecHelper.getCompiledElement($compile, $scope, html);
                    element.addClass("xui-edge-definer");
                    angular.element(document.body).append(element);

                    let toBePlaced = element.find("#deposit"),
                        basePoint = element.find("#base-point");

                    //setting the size  of parent component
                    element.css({
                        width: parentComponentDimension.width,
                        height: parentComponentDimension.height,
                        position: "relative"
                    });

                    const result: any = $edgeDetectionService.canBe(basePoint, toBePlaced);

                    element.remove();
                    expect(result.placed[toBeTested]).toBe(thereIsPlace);
                };
            };

            let testTopBottomPlacementInComponent = (thereIsPlace: boolean, toBeTested: string) => {
                return () => {
                    const adjust: number = thereIsPlace ? -1 : 1;
                    let   depositHeight: number = (toBeTested === "bottom") ?
                        (parentComponentDimension.height - basePointDimensions.y - basePointDimensions.height) :
                        basePointDimensions.y;
                    depositHeight += adjust;
                    const html = createHtml(10, depositHeight);
                    element = SpecHelper.getCompiledElement($compile, $scope, html);
                    element.addClass("xui-edge-definer");
                    angular.element(document.body).append(element);

                    let toBePlaced = element.find("#deposit"),
                        basePoint = element.find("#base-point");

                    //setting the size  of parent component
                    element.css({
                        width: parentComponentDimension.width + "px",
                        height: parentComponentDimension.height + "px",
                        position: "relative"
                    });

                    const result: any = $edgeDetectionService.canBe(basePoint, toBePlaced);

                    element.remove();
                    expect(result.placed[toBeTested]).toBe(thereIsPlace);
                };
            };

            it("should give expected result when no right direction is available",
                testLeftRightPlacementInComponent(false, "right"));
            it("should give expected result when right direction is available",
                testLeftRightPlacementInComponent(true, "right"));

            it("should give expected result when no top direction is available",
                testTopBottomPlacementInComponent(false, "top"));
            it("should give expected result when top direction is available",
                testTopBottomPlacementInComponent(true, "top"));

            it("should give expected result when no bottom direction is available",
                testTopBottomPlacementInComponent(false, "bottom"));
            it("should give expected result when bottom direction is available",
                testTopBottomPlacementInComponent(true, "bottom"));

            it("should give expected result when no left direction is available",
                testLeftRightPlacementInComponent(false, "left"));
            it("should give expected result when left direction is available",
                testLeftRightPlacementInComponent(true, "left"));
        });

        describe("aligning in edge-definer >", () => {
            let testLeftRightAlignmentInComponent = (thereIsPlace: boolean, toBeTested: string) => {
                return () => {
                    const adjust: number = thereIsPlace ? -10 : 10;
                    let depositWidth: number = toBeTested === "left" ?
                    parentComponentDimension.width - basePointDimensions.x :
                    basePointDimensions.x + basePointDimensions.width;
                    depositWidth += adjust;
                    const html = createHtml(depositWidth, 10);
                    element = SpecHelper.getCompiledElement($compile, $scope, html);
                    element.addClass("xui-edge-definer");
                    angular.element(document.body).append(element);

                    let toBePlaced = element.find("#deposit"),
                        basePoint = element.find("#base-point");

                    //setting the size  of parent component
                    element.css({
                        width: parentComponentDimension.width,
                        height: parentComponentDimension.height,
                        position: "relative"
                    });

                    const result: any = $edgeDetectionService.canBe(basePoint, toBePlaced);
                    element.remove();
                    expect(result.aligned[toBeTested]).toBe(thereIsPlace);
                };
            };

            let testTopBottomAlignmentInComponent = (thereIsPlace: boolean, toBeTested: string) => {
                return () => {
                    const adjust: number = thereIsPlace ? -10 : 10;
                    let depositHeight: number = toBeTested === "bottom" ?
                    basePointDimensions.y + basePointDimensions.height :
                    parentComponentDimension.height - basePointDimensions.y;
                    depositHeight += adjust;
                    const html = createHtml(10, depositHeight);
                    element = SpecHelper.getCompiledElement($compile, $scope, html);
                    element.addClass("xui-edge-definer");
                    angular.element(document.body).append(element);

                    let toBePlaced = element.find("#deposit"),
                        basePoint = element.find("#base-point");

                    //setting the size  of parent component
                    element.css({
                        width: parentComponentDimension.width,
                        height: parentComponentDimension.height,
                        position: "relative"
                    });

                    const result: any = $edgeDetectionService.canBe(basePoint, toBePlaced);
                    element.remove();
                    expect(result.aligned[toBeTested]).toBe(thereIsPlace);
                };
            };

            it("should give expected result when no right direction is available",
                testLeftRightAlignmentInComponent(false, "right"));
            it("should give expected result when right direction is available",
                testLeftRightAlignmentInComponent(true, "right"));

            it("should give expected result when no top direction is available",
                testTopBottomAlignmentInComponent(false, "top"));
            it("should give expected result when top direction is available",
                testTopBottomAlignmentInComponent(true, "top"));

            it("should give expected result when no bottom direction is available",
                testTopBottomAlignmentInComponent(false, "bottom"));
            it("should give expected result when bottom direction is available",
                testTopBottomAlignmentInComponent(true, "bottom"));

            it("should give expected result when no left direction is available",
                testLeftRightAlignmentInComponent(false, "left"));
            it("should give expected result when left direction is available",
                testLeftRightAlignmentInComponent(true, "left"));
        });
    });
});
