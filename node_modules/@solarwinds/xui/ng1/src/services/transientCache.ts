/// <reference path="../ref.d.ts" />
import IMap = xui.IMap;
import IPromise = angular.IPromise;
import SwUtil from "./swUtil-service";
import ITransientCache = xui.ITransientCache;

export default class TransientCache implements ITransientCache {

    private promiseCache:IMap<IPromise<void>> = {};

    constructor(private cache:ng.ICacheObject,
                private $timeout:ng.ITimeoutService,
                private swUtil:SwUtil) {
    }

    public put = (key:string, value:any, lifetime:number):IPromise<void> => {
        this.cache.put(key, value);
        const promise = this.$timeout(() => {
            delete this.promiseCache[key];
            this.cache.remove(key);
        }, lifetime);
        this.promiseCache[key] = promise;
        return promise;
    };

    public get = (key:string):any => {
        return this.cache.get(key);
    };

    public remove = (key:string):void => {
        const promise = this.promiseCache[key];
        if (angular.isDefined(promise)) {
            this.$timeout.cancel(promise);
            delete this.promiseCache[key];
        }
        this.cache.remove(key);
    };

    public removeAll = ():void => {
        for (let key in this.promiseCache) {
            if (this.promiseCache.hasOwnProperty(key)) {
                this.remove(key);
            }
        }

        this.cache.removeAll();
    };

    public destroy = ():void => {
        this.removeAll();
        this.cache.destroy();
    };

    public entryCount = ():number => {
        return this.cache.info().size;
    };

    public size = ():number => {
        let byteCount = 0;
        for (let key in this.promiseCache) {
            if (this.promiseCache.hasOwnProperty(key)) {
                byteCount += this.swUtil.sizeof(this.get(key));
            }
        }

        return byteCount;
    };
}
