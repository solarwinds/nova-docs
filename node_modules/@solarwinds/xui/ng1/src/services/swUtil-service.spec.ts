/// <reference path="../ref.d.ts" />

import ByteCount from "./swUtil-service";
import SwUtil from "./swUtil-service";
describe("services >", () => {
    describe("swUtil >", () => {
        let swUtil:SwUtil;

        beforeEach(angular.mock.module("xui.services"));

        beforeEach(inject(($injector:any) => {
            swUtil = $injector.get("swUtil");
        }));

        it("can create nextUid", () => {
            expect(swUtil.nextUid().length).toBe(3);
        });

        it("properly calculates sizeof", () => {
            const boolBytes = 4;
            const isBool = true;
            expect(swUtil.sizeof(isBool)).toBe(boolBytes);

            const numBytes = 8;
            const myNum = 98666;
            expect(swUtil.sizeof(myNum)).toBe(numBytes);

            const myStr = "this here is my nifty string";
            const myStrBytes = myStr.length * 2;
            expect(swUtil.sizeof(myStr)).toBe(myStrBytes);

            const myObj = {field1:isBool, field2:myNum, field3:myStr};
            const myObjKeyBytes = "fieldx".length * 2 * 3;
            const myObjBytes = boolBytes + numBytes + myStrBytes + myObjKeyBytes;
            expect(swUtil.sizeof(myObj)).toBe(myObjBytes);

            const myComplexObj = {field1:"someKey", field2:myObj};
            const myComplexObjKeyBytes = "fieldx".length * 2 * 2;
            const myComplexObjBytes = myComplexObj.field1.length*2 + myObjBytes + myComplexObjKeyBytes;
            expect(swUtil.sizeof(myComplexObj)).toBe(myComplexObjBytes);
        });

        it("returns 0 for circular references", () => {
            let objA = {};
            const objB = {field1:123456, field2:objA};
            const objBKeyBytes = "field1".length*2 +  "field2".length*2;
            const objBValueBytes = 8 + 0; // 0 should be returned for value of objA
            objA = {field:objB};
            const objAKeyBytes = "field".length*2;
            const objAValueBytes = objBKeyBytes + objBValueBytes;
            const objABytes = objAKeyBytes + objAValueBytes;
            expect(swUtil.sizeof(objA)).toBe(objABytes);
        });

        describe("isTrueString() > ", function () {

            it("returns true for 'true'", () => {
                expect(swUtil.isTrueString("true")).toBeTruthy();
            });

            it("returns true for 'True'", () => {
                expect(swUtil.isTrueString("True")).toBeTruthy();
            });

            it("returns false for 'false'", () => {
                expect(swUtil.isTrueString("false")).toBeFalsy();
            });

            it("returns false for 'False'", () => {
                expect(swUtil.isTrueString("False")).toBeFalsy();
            });
        });

        describe("formatString() > ", function () {

            it("formats a string with one string argument", () => {
                expect(swUtil.formatString("Formatted {0}", "string")).toEqual("Formatted string");
            });

            it("formats a string with two string arguments in reverse order", () => {
                expect(swUtil.formatString("Double-{1} formatted {0}", "string", "argument"))
                    .toEqual("Double-argument formatted string");
            });

            it("formats a string with three string arguments", () => {
                expect(swUtil.formatString("{0}-{1} formatted {2}", "Triple", "argument", "string"))
                    .toEqual("Triple-argument formatted string");
            });

            it("formats a string with three string arguments in reverse order", () => {
                expect(swUtil.formatString("{2}-{1} formatted {0}", "string", "argument", "Triple"))
                    .toEqual("Triple-argument formatted string");
            });

            it("formats a string with one single-digit decimal argument", () => {
                expect(swUtil.formatString("Formatted decimal: {0}", 0)).toEqual("Formatted decimal: 0");
            });

            it("formats a string with one multiple-digit decimal argument", () => {
                expect(swUtil.formatString("Formatted triple-digit decimal: {0}", 123))
                    .toEqual("Formatted triple-digit decimal: 123");
            });

            it("formats a string with multiple decimal arguments", () => {
                expect(swUtil.formatString("First decimal: {0}, Second decimal: {1}", 123, 456))
                    .toEqual("First decimal: 123, Second decimal: 456");
            });

            it("formats a string with a single floating point argument", () => {
                expect(swUtil.formatString("Floating point: {0}", 1.23))
                    .toEqual("Floating point: 1.23");
            });

            it("formats a string with a multiple floating point arguments", () => {
                expect(swUtil.formatString("First floating point: {0}, Second floating point: {1}", 1.23, 4.56))
                    .toEqual("First floating point: 1.23, Second floating point: 4.56");
            });

            it("formats a string with one false boolean argument", () => {
                expect(swUtil.formatString("Formatted boolean: {0}", false)).toEqual("Formatted boolean: false");
            });

            it("formats a string with one true boolean argument", () => {
                expect(swUtil.formatString("Formatted boolean: {0}", true)).toEqual("Formatted boolean: true");
            });

            it("formats a string with all possible argument types", () => {
                expect(swUtil.formatString(`Formatted boolean: {0},
                                            Formatted decimal: {1},
                                            Formatted string: {2},
                                            Formatted floating point: {3}`, true, 123, "test", 1.23))
                                  .toEqual(`Formatted boolean: true,
                                            Formatted decimal: 123,
                                            Formatted string: test,
                                            Formatted floating point: 1.23`);
            });

            it("allows for escaping open and close braces", () => {
                expect(swUtil.formatString("{0} and {1} braces: {{ property: value }}", "Open", "close"))
                    .toEqual("Open and close braces: { property: value }");
            });

            it("allows for escaping open and close braces with an embedded insertion point", () => {
                expect(swUtil.formatString("{0} and {1} braces: {{property: {2}}}", "Open", "close", "value"))
                    .toEqual("Open and close braces: {property: value}");
            });
            it("does not replace null arguments", () => {
                expect(swUtil.formatString("Undefined value: {0}", null))
                    .toEqual("Undefined value: {0}");
            });

            it("does not replace undefined arguments", () => {
                expect(swUtil.formatString("Undefined value: {0}", undefined))
                    .toEqual("Undefined value: {0}");
            });

            it("does replace empty string argument", () => {
                expect(swUtil.formatString("Undefined value: {0}", ""))
                    .toEqual("Undefined value: ");
            });

             it("does not remove curly braces when content does not match no provided parameters", () => {
                 expect(swUtil.formatString("{5343-name-2} whatever {0}","word"))
                     .toEqual("{5343-name-2} whatever word");
             });
        });

        describe("dateEquals() > ", () => {
            it("returns true for both undefined", () => {
                expect(swUtil.dateEquals(undefined, undefined)).toBe(true);
            });

            it("returns true for both null", () => {
                expect(swUtil.dateEquals(null, null)).toBe(true);
            });

            it("returns false for undefined and null", () => {
                expect(swUtil.dateEquals(undefined, null)).toBe(false);
            });

            it("returns false for null and undefined", () => {
                expect(swUtil.dateEquals(null, undefined)).toBe(false);
            });

            it("returns true for same instance", () => {
                const d = new Date();
                expect(swUtil.dateEquals(d, d)).toBe(true);
            });

            it("returns false for different values", () => {
                const d1 = new Date();
                const d2 = new Date();
                d2.setHours(0,0,0,0);
                expect(swUtil.dateEquals(d1, d2)).toBe(false);
            });
        });
    });
});
