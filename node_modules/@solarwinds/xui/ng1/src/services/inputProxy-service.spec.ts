/// <reference path="../ref.d.ts" />

import InputProxyService from "./inputProxy-service";
import {default as SpecHelper, ITestScope} from "../specHelper";

describe("services >", () => {

    describe("inputProxy-service >", () => {
        /** @ngInject */
        function testDirective(xuiInputProxyService:InputProxyService):ng.IDirective {
            return {
                restrict: "E",
                require: ["testInternalModel", "ngModel"],
                replace: true,
                template: `<div><input type="text" id="internal" ng-model="internalValue"
                                       ng-blur="exposedOnBlur()" /></div>`,
                scope: {
                    externalValue: "=ngModel",
                    exposedOnBlur: "&"
                },
                controller: () => {/*noop*/},
                controllerAs: "vm",
                compile: (tElement:ng.IAugmentedJQuery, tAttrs:ng.IAttributes) => {
                    const $input = tElement.find("input");
                    const handlers = xuiInputProxyService.proxyAttributesCompile(tAttrs, $input);
                    return {
                        post: ($scope: ng.IScope, element: ng.IAugmentedJQuery,
                               attrs: ng.IAttributes, ctrls: any[]) => {
                            xuiInputProxyService.proxyAttributesLink(handlers, ctrls[0], $scope);
                        }
                    };
                }
            };
        }

        angular.module("xui").directive("testInternalModel", testDirective);

        let inputProxyService:InputProxyService;
        let $scope:ITestScope;
        let $internalScope:ITestScope;
        let internalModel:ng.INgModelController;
        let externalModel:ng.INgModelController;
        let input:ng.IAugmentedJQuery;
        let element:ng.IAugmentedJQuery;

        beforeEach(angular.mock.module("xui"));
        beforeEach(inject(($injector:any) => {
            inputProxyService = $injector.get("xuiInputProxyService");

            $scope = $injector.get("$rootScope");

            const html = `<div>
                                <test-internal-model ng-model="externalValue" id="external"
                                    ng-blur="onBlur()" ng-focus="onFocus()"
                                    exposed-on-blur="exposedOnBlur()"></test-internal-model>
                            </div>`;
            const $compile:ng.ICompileService = $injector.get("$compile");
            element = SpecHelper.getCompiledElement($compile, $scope, html);

            const $controller:ng.IControllerService = $injector.get("$controller");

            const directive = element.find("#external");
            externalModel = directive.controller("ngModel");
            input = element.find("#internal");
            internalModel = input.controller("ngModel");
            $internalScope = directive.isolateScope();

            $scope["onFocus"] = angular.noop;
            $scope["onBlur"] = angular.noop;
            $scope["exposedOnBlur"] = angular.noop;
        }));

        describe("when models are bound using proxyModel() >", ()=> {
            beforeEach(()=> {
                inputProxyService.proxyModel(internalModel, externalModel, $scope);
            });

            it("propagates $viewValue from internal to external", ()=> {
                expect(externalModel.$viewValue).toBeUndefined();

                internalModel.$setViewValue("testValue");

                expect(internalModel.$viewValue).toEqual("testValue");
                expect(externalModel.$viewValue).toEqual("testValue");
            });

            it("propagates $touched and $untouched from internal to external", ()=> {
                expect(externalModel.$touched).toBe(false);
                expect(externalModel.$untouched).toBe(true);

                internalModel.$setTouched();

                expect(externalModel.$touched).toBe(true);
                expect(externalModel.$untouched).toBe(false);

                internalModel.$setUntouched();

                expect(externalModel.$touched).toBe(false);
                expect(externalModel.$untouched).toBe(true);
            });

            it("propagates $dirty and $pristine from internal to external", ()=> {
                expect(externalModel.$dirty).toBe(false);
                expect(externalModel.$pristine).toBe(true);

                internalModel.$setDirty();

                expect(externalModel.$dirty).toBe(true);
                expect(externalModel.$pristine).toBe(false);

                internalModel.$setPristine();

                expect(externalModel.$dirty).toBe(false);
                expect(externalModel.$pristine).toBe(true);
            });

            it("propagates $viewValue from external to internal", ()=> {
                const value = "I'm here";
                externalModel.$viewValue = value;

                $scope.$apply();

                expect(internalModel.$viewValue).toBe(value);
                expect(internalModel.$modelValue).toBe(value);
                expect(input.val()).toBe(value);
            });

            describe("when $formatters and $parsers are used >", ()=> {
                beforeEach(()=> {
                    // model is lowercase, view is uppercase
                    externalModel.$formatters.unshift((modelValue:any)=> {
                        return modelValue.toUpperCase();
                    });
                    externalModel.$parsers.unshift((viewValue:any)=> {
                        return viewValue.toLowerCase();
                    });
                });

                it("applies the $formatter (just to make sure)", ()=> {
                    $scope["externalValue"] = "some-string";

                    $scope.$apply();

                    expect(externalModel.$viewValue).toBe("SOME-STRING");
                });

                it("propagates the model change to the internal model", ()=> {
                    $scope["externalValue"] = "some-string";

                    $scope.$apply();

                    expect(internalModel.$viewValue).toBe("SOME-STRING");
                    expect($internalScope["internalValue"]).toBe("SOME-STRING");
                });

                it("propagates the internal view change to the external model", ()=> {
                    internalModel.$setViewValue("SOME-INTERNAL-STUFF");

                    $scope.$apply();

                    expect($scope["externalValue"]).toBe("some-internal-stuff");
                });
            });

            describe("when $validators are used >", ()=> {
                beforeEach(()=> {
                    // model is lowercase, view is uppercase
                    externalModel.$validators["validator"] = (modelValue:any, viewValue:any)=> {
                        return viewValue !== "fail";
                    };
                });

                it("propagates error state from external to internal", ()=> {
                    // initial setup
                    $scope["externalValue"] = "ok";
                    $scope.$apply();
                    expect(internalModel.$viewValue).toBe("ok");

                    // expect the validation to fail on external model
                    expect(externalModel.$error.validator).toBeUndefined();
                    // expect the validation error to be propagated to internal model
                    expect(internalModel.$error.validator).toBeUndefined();

                    // set view value
                    internalModel.$setViewValue("fail");
                    // expect the validation to fail on external model
                    expect(externalModel.$error.validator).toBe(true);
                    // expect the validation error to be propagated to internal model
                    expect(internalModel.$error.validator).toBe(true);
                });
            });

            describe("when event handlers are proxied >", ()=> {
                let onBlur:Function;
                let exposedOnBlur:Function;
                let onFocus:Function;
                let $input:ng.IAugmentedJQuery;
                beforeEach(()=> {
                    $input = element.find("input");

                    onBlur = spyOn($scope, "onBlur").and.callThrough();
                    onFocus = spyOn($scope, "onFocus").and.callThrough();
                    exposedOnBlur = spyOn($scope, "exposedOnBlur").and.callThrough();
                });

                it("calls an event handler that was not overriden internally", ()=> {
                    expect(onFocus).not.toHaveBeenCalled();

                    $input.triggerHandler("focus");

                    expect(onFocus).toHaveBeenCalled();
                });

                it("calls an external event handler that was overriden internally", ()=> {
                    expect(onBlur).not.toHaveBeenCalled();

                    $input.triggerHandler("blur");

                    expect(onBlur).toHaveBeenCalled();
                });

                it("calls an internal event handler that was overriden internally", ()=> {
                    expect(exposedOnBlur).not.toHaveBeenCalled();

                    $input.triggerHandler("blur");

                    expect(exposedOnBlur).toHaveBeenCalled();
                });
            });

        });
    });
});
