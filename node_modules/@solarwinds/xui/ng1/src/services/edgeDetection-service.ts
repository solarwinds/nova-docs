import IEdgeDetectionResult = xui.IEdgeDetectionResult;
import Inject from "../decorators/di";
import {Constants} from "../common/constants";

/**
 * @ngdoc service
 * @name xui.services:xuiEdgeDetectionService
 * @description
 * Service that helps to calculate free space for dynamic elements (popover, dropdown, etc.) and define the best
 * direction to show them. There are two ways how detection can be made:
 * 1) default one - detection is made within view port area.
 * 2) custom container can be used for detection. Identify such container using 'xui-edge-detection' CSS-class.
 * @example
 *<example module="xui">
 *     <file src="src/services/docs/edgeDetection-example.html" name="index.html"></file>
 *     <file src="src/services/docs/edgeDetection-example.js" name="app.js"></file>
 *</example>
 */

export class EdgeDetectionService implements xui.IEdgeDetectionService {

    constructor(@Inject("$window") private $window: ng.IWindowService,
                @Inject("xuiConstants") private xuiConstants: Constants) {
    }

    /** @ngdoc method
     *  @name xui.services:xuiEdgeDetection#canBe
     *  @methodOf xui.services:xuiEdgeDetectionService
     *  @description Detects if there's an available place for a component within window or component with class
     *  'xui-edge-definer'.
     *  @param {ng.IAugmentedJQuery} basePoint The element from where the place is to be checked.
     *  @param {ng.IAugmentedJQuery} placed The element which is going to be placed around the basePoint.
     *  @returns {xui.IEdgeDetectionResult} The availability of placing and aligning the provided element to the four
     *  directions.
     **/

    public canBe = (basePoint: ng.IAugmentedJQuery,
                    placed: ng.IAugmentedJQuery): xui.IEdgeDetectionResult => {
        let result: IEdgeDetectionResult = {
                placed: {
                    top: false,
                    right: false,
                    bottom: false,
                    left: false
                },
                aligned: {
                    top: false,
                    right: false,
                    bottom: false,
                    left: false
                }
            },
            edgeDefiner = angular.element(this.xuiConstants.edgeDefinerSelector),
            basePosition: JQueryCoordinates = basePoint.offset(),
            baseWidth: number = basePoint.outerWidth(),
            baseHeight: number = basePoint.outerHeight(),
            depositWidth: number = placed.outerWidth(),
            depositHeight: number = placed.outerHeight(),
            edgeDefinerPosition: JQueryCoordinates,
            containerWidth: number,
            containerHeight: number,
            scrollY: number,
            scrollX: number;

        if (edgeDefiner.length !== 0) {
            edgeDefinerPosition = edgeDefiner.offset();
            containerWidth = edgeDefiner.width();
            containerHeight = edgeDefiner.height();
            scrollY = edgeDefiner.scrollTop();
            scrollX = edgeDefiner.scrollLeft();
        } else {
            edgeDefinerPosition = {top: 0, left: 0};
            containerWidth = this.$window.innerWidth;
            containerHeight = this.$window.innerHeight;
            scrollY = this.$window.scrollY || this.$window.pageYOffset;
            scrollX = this.$window.scrollX || this.$window.pageXOffset;
        }

        result.placed.top = basePosition.top - edgeDefinerPosition.top - depositHeight > scrollY;
        result.placed.right = basePosition.left - edgeDefinerPosition.left + baseWidth + depositWidth
            < containerWidth + scrollX;
        result.placed.bottom = basePosition.top - edgeDefinerPosition.top + baseHeight + depositHeight
            < containerHeight + scrollY;
        result.placed.left = basePosition.left - edgeDefinerPosition.left - depositWidth > scrollX;

        result.aligned.top = basePosition.top - edgeDefinerPosition.top + depositHeight < scrollY + containerHeight;
        result.aligned.right = basePosition.left - edgeDefinerPosition.left + baseWidth - depositWidth > scrollX;
        result.aligned.bottom = basePosition.top - edgeDefinerPosition.top + baseHeight - depositHeight > scrollY;
        result.aligned.left = basePosition.left - edgeDefinerPosition.left + depositWidth < scrollX + containerWidth;
        return result;
    };
}
export default EdgeDetectionService;
