/// <reference path="../ref.d.ts" />

import SwUtil from "./swUtil-service";
import Inject from "../decorators/di";
/**
 * This service is intended for tasks related with creating ui components that wrap input elements. There are
 * several problems with this approach like proxying ng-model behavior, validations and input event handlers. This
 * service solves those problems.
 */
class InputProxyService {

    public static NG_MODEL_INITIALIZED_EVENT = "xui:proxy-input:ng-model";

    private eventMap:{[key:string]:boolean} = {};

    private bottom2Top = ["$setViewValue", "$setDirty",
        "$setPristine", "$setTouched", "$setUntouched"];
    private top2Bottom = ["$setValidity", "$render"];

    constructor(@Inject("$parse") private $parse:ng.IParseService,
                @Inject("swUtil") private swUtil:SwUtil) {
        const events = (
            "click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter " +
            "mouseleave keydown keyup keypress submit focus blur copy cut paste"
        ).split(" ");

        this.eventMap = events.reduce((result:{[key:string]:boolean}, next:string)=> {
            result["ng" + this.capitalizeFirstLetter(next)] = true;
            return result;
        }, <{[key:string]:boolean}>{});
    }

    /**
     * This is the compile phase part of proxying event handlers
     *
     * @param attr
     * @param input
     * @returns {IAttributeProxies}
     */
    public proxyAttributesCompile(attr:ng.IAttributes, input:ng.IAugmentedJQuery):IAttributeProxies {
        const proxies = <IAttributeProxies>{};

        // ng-event handlers
        for (let ngAttr of Object.keys(attr)) {
            if (this.eventMap[ngAttr]) {
                let originalFn:Function;
                const originalAttribute = input.attr(this.swUtil.dashCase(ngAttr));
                if (originalAttribute) {
                    originalFn = this.$parse(originalAttribute);
                }
                input.attr(this.swUtil.dashCase(ngAttr),
                    `vm.${this.getInternalProxyName(ngAttr)}($event)`);

                const fn = this.$parse(attr[ngAttr]);
                proxies[ngAttr] = {original: originalFn, provided: fn};
            }
        }

        if (attr["inputAttributes"]) {
            const proxyAttrs = attr["inputAttributes"].split(" *, *");
            for (let pa of proxyAttrs) {
                const paCamelCase = this.swUtil.camelCase(pa);

                input.attr(pa, `vm.${this.getInternalProxyName(paCamelCase)}()`);

                const fn = this.$parse(attr[paCamelCase]);
                proxies[paCamelCase] = {original: null, provided: fn};
            }
        }
        return proxies;
    }

    /**
     * This is the link phase part of proxying event handlers
     *
     * @param proxies
     * @param ctrl
     * @param $scope
     */
    public proxyAttributesLink(proxies:IAttributeProxies, ctrl:any, $scope:ng.IScope) {
        const proxyNames = Object.keys(proxies);
        for (let proxyName of proxyNames) {
            const proxyFns = proxies[proxyName];

            ctrl[this.getInternalProxyName(proxyName)] = ($event:JQueryEventObject)=> {
                //console.log("Calling proxy:", proxyName);
                if (proxyFns.original) {
                    proxyFns.original({$event: $event}, $scope);
                }
                return proxyFns.provided({$event: $event}, $scope.$parent);
            };
        }
    }

    /**
     * This is used to proxy some of the method calls from one ng-model controller to another. It's used for custom UI
     * components that have ng-model support but also contain a ng-model on a nested input element. It allows the
     * validators to be declared on the root instead of passing them to the nested input element.
     *
     * @param internalModel
     * @param externalModel
     * @param $scope
     */
    public proxyModel(internalModel:ng.INgModelController, externalModel:ng.INgModelController, $scope:ng.IScope,
        internalModelId?:string, externalModelId?:string) {
        this.bottom2Top.forEach((m)=> {
            this.proxyMethod(internalModel, externalModel, m, internalModelId, externalModelId);
        });
        this.top2Bottom.forEach((m)=> {
            this.proxyMethod(externalModel, internalModel, m, externalModelId, internalModelId);
        });
        $scope.$watch(()=>externalModel.$viewValue, (newValue)=> {
            const $dirty = internalModel.$dirty;
            internalModel.$setViewValue(newValue);

            if (!$dirty && internalModel.$dirty) {
                internalModel.$setPristine();
            }

            internalModel.$render();
        });
        $scope.$emit(InputProxyService.NG_MODEL_INITIALIZED_EVENT, externalModel);
    }

    /**
     * Decorate a `method` on source so that it calls also the same method on `target`
     *
     * @param source
     * @param target
     * @param method
     */
    private proxyMethod(source:any, target:any, method:string, sourceModelId:string, targetModelId:string):void {
        const originalMethod = source[method];
        source[method] = (...args:any[])=> {
            // console.log(sourceModelId, "triggered", method, "on", targetModelId, "with", args);
            originalMethod.apply(source, args);
            target[method].apply(target, args);
        };
    }

    private getInternalProxyName(ngEvent:string):string {
        return `proxy_${ngEvent}`;
    }

    private capitalizeFirstLetter(s:string):string {
        return s.charAt(0).toUpperCase() + s.slice(1);
    }

}

export interface IAttributeProxies {
    [key:string]:{
        original:Function;
        provided:Function;
    };
}

export default InputProxyService;
