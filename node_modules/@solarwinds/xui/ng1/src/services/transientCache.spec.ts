/// <reference path="../ref.d.ts" />

import SwUtil from "./swUtil-service";
import ITransientCache = xui.ITransientCache;
import TransientCache from "./transientCache";

describe("services >", () => {
    describe("transientCache >", () => {
        let cache:ITransientCache;
        let $timeout:ng.ITimeoutService;
        let swUtil:SwUtil;
        let getTestObj = ():any => {
            return {key:"obj", msg:"hello world", someNumber:9};
        };

        beforeEach(angular.mock.module("xui.services"));
        beforeEach(inject(($injector:any) => {
            const $cacheFactory = $injector.get("$cacheFactory");
            $timeout = $injector.get("$timeout");
            swUtil = $injector.get("swUtil");
            cache = new TransientCache($cacheFactory("test"), $timeout, swUtil);
        }));

        it("should add object to the cache", () => {
            const obj = getTestObj();
            expect(cache.entryCount()).toBe(0);
            cache.put(obj.key, obj, 30000);
            expect(cache.entryCount()).toBe(1);
            const myObj = cache.get(obj.key);
            expect(myObj).toBe(obj);
        });

        it("should remove object from the cache", () => {
            const obj = getTestObj();
            expect(cache.entryCount()).toBe(0);
            cache.put(obj.key, obj, 30000);
            expect(cache.entryCount()).toBe(1);
            cache.remove(obj.key);
            expect(cache.entryCount()).toBe(0);
            const myObj = cache.get(obj.key);
            expect(myObj).toBeUndefined();
        });

        it("should remove all objects from the cache", () => {
            const obj1 = getTestObj();
            const obj2 = {key:"obj2", msg:"grumble", someNumber:99};
            const obj3 = {key:"obj3", msg:"grumble grumble", someNumber:999};
            expect(cache.entryCount()).toBe(0);
            cache.put(obj1.key, obj1, 30000);
            cache.put(obj2.key, obj2, 30000);
            cache.put(obj3.key, obj3, 30000);
            expect(cache.entryCount()).toBe(3);
            let objRetrieved = cache.get(obj2.key);
            expect(objRetrieved).toBe(obj2);
            cache.removeAll();
            expect(cache.entryCount()).toBe(0);
            objRetrieved = cache.get(obj2.key);
            expect(objRetrieved).toBeUndefined();
        });

        it("should be removed from the cache on timeout interval provided", () => {
            const obj = getTestObj();
            expect(cache.entryCount()).toBe(0);
            let notifiedOnExpiration = false;
            cache.put(obj.key, obj, 3000).then(() => {
                notifiedOnExpiration = true;
            });
            expect(cache.entryCount()).toBe(1);
            $timeout.flush(1000);
            expect(cache.entryCount()).toBe(1);
            expect(notifiedOnExpiration).toBe(false);
            $timeout.flush(2000);
            expect(cache.entryCount()).toBe(0);
            expect(notifiedOnExpiration).toBe(true);
        });

        it("should properly calculate cache size", () => {
            const obj = getTestObj();
            const keyBytes = "key".length*2 + "msg".length*2 + "someNumber".length*2;
            const valueBytes = obj.key.length*2 + obj.msg.length*2 + 8;
            const objBytes = keyBytes + valueBytes;
            cache.put(obj.key, obj, 30000);
            expect(cache.size()).toBe(objBytes);

            const childObj = {key:"key", field1:false, field2:798542, field3:"some string"};
            const childObjKeyBytes =  "key".length*2 + "fieldx".length*2*3;
            const childValueKeyBytes = childObj.key.length*2 + 4 + 8 + childObj.field3.length*2;
            const childObjBytes = childObjKeyBytes + childValueKeyBytes;
            const parentObj = {key:"obj2", msg:"grumble", someNumber:99, child:childObj};
            const parentObjKeyBytes = keyBytes + "child".length*2;
            const parentObjValueBytes = parentObj.key.length*2 + parentObj.msg.length*2 + 8 + childObjBytes;
            const parentObjBytes = parentObjKeyBytes + parentObjValueBytes;
            cache.put(parentObj.key, parentObj, 30000);
            expect(cache.size()).toBe(objBytes + parentObjBytes);
        });
    });
});
