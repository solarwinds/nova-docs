<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>@nova-ui/bits documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">@nova-ui/bits documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>ITableState</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">API</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/lib/table/table-state-handler.service.ts</code>
        </p>



        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#columnAlignments">columnAlignments</a>
                                </li>
                                <li>
                                        <a href="#columns">columns</a>
                                </li>
                                <li>
                                        <a href="#columnsTypes">columnsTypes</a>
                                </li>
                                <li>
                                        <a href="#columnsWidths">columnsWidths</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#sortedColumn">sortedColumn</a>
                                </li>
                                <li>
                                        <a href="#widthCalculationPerformed">widthCalculationPerformed</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="columnAlignments"></a>
                                        <span class="name"><b>columnAlignments</b><a href="#columnAlignments"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>columnAlignments:     <code>literal type</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>literal type</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="columns"></a>
                                        <span class="name"><b>columns</b><a href="#columns"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>columns:     <code>string[]</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>string[]</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="columnsTypes"></a>
                                        <span class="name"><b>columnsTypes</b><a href="#columnsTypes"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>columnsTypes:     <code>string[]</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>string[]</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="columnsWidths"></a>
                                        <span class="name"><b>columnsWidths</b><a href="#columnsWidths"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>columnsWidths:     <code>literal type</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>literal type</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="sortedColumn"></a>
                                        <span class="name"><b>sortedColumn</b><a href="#sortedColumn"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>sortedColumn:     <code><a href="../interfaces/ISortedItem.html" target="_self" >ISortedItem</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code><a href="../interfaces/ISortedItem.html" target="_self" >ISortedItem</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="widthCalculationPerformed"></a>
                                        <span class="name"><b>widthCalculationPerformed</b><a href="#widthCalculationPerformed"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>widthCalculationPerformed:     <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { forwardRef, Inject, Injectable, NgZone, TrackByFunction } from &quot;@angular/core&quot;;
import _includes from &quot;lodash/includes&quot;;
import _isNil from &quot;lodash/isNil&quot;;
import _isNumber from &quot;lodash/isNumber&quot;;
import { Subject } from &quot;rxjs&quot;;

import { ISelection, ISelectorState } from &quot;../../services/public-api&quot;;
import { SelectionType } from &quot;../selector/public-api&quot;;
import { SelectorService } from &quot;../selector/selector.service&quot;;
import { ISortedItem, SorterDirection } from &quot;../sorter/public-api&quot;;

import { TableResizePhase } from &quot;./table-resizer/table-resizer.directive&quot;;

export const enum AlignmentClasses {
    RIGHT &#x3D; &quot;align-right&quot;,
    LEFT &#x3D; &quot;align-left&quot;,
    CENTER &#x3D; &quot;align-center&quot;,
}

export const enum DropAlignment {
    left &#x3D; &quot;left&quot;,
    right &#x3D; &quot;right&quot;,
}

export interface ITableState {
    columnAlignments: { [key: string]: string };
    columnsWidths: { [key: string]: { width: number, autoCalculated?: boolean } };
    columns: string[];
    sortedColumn?: ISortedItem;
    widthCalculationPerformed: boolean;
    columnsTypes: string[];
}

export interface DraggedOverCell {
    cellIndex: number;
    dropAlignment: DropAlignment;
}

export interface TableCellEdgeHighlight {
    columnIndex: number;
    side: DropAlignment;
    eventPhase: TableResizePhase;
}

export interface ColumnType {
    columnName: string;
    columnType: string;
}

export interface ITableSortingState {
    sortingIcon?: string;
    isColumnSorted: boolean;
}

/**@ignore*/
const MIN_COLUMN_WIDTH_PX &#x3D; 46;
/**@ignore*/
const ICON_CELL_WIDTH_PX &#x3D; 40;
/**@ignore*/
const SELECTABLE_CELL_WIDTH_PX &#x3D; 75;

/**@ignore*/
const DEFAULT_TRACK_BY: TrackByFunction&lt;any&gt; &#x3D; ((i, d) &#x3D;&gt; d);

@Injectable()
export class TableStateHandlerService {
    public tableParentWidth: number;
    public columnsState &#x3D; new Subject&lt;string[]&gt;();
    public sortingState &#x3D; new Subject&lt;ISortedItem&gt;();
    public draggedOverCell &#x3D; new Subject&lt;DraggedOverCell&gt;();
    public shouldHighlightEdge &#x3D; new Subject&lt;TableCellEdgeHighlight&gt;();
    public dataSourceChanged &#x3D; new Subject&lt;Array&lt;any&gt;&gt;();
    public selectionChanged &#x3D; new Subject&lt;ISelection&gt;();
    public columnWidthSubject &#x3D; new Subject&lt;void&gt;();
    public stickyHeaderChangedSubject &#x3D; new Subject&lt;void&gt;();

    private _reorderable: boolean;
    private _sortable: boolean;
    private _resizable: boolean;
    private _dragCellIndex: number;
    private _draggedOverCellIndex: number;
    private _newCellIndex: number;
    private _dropCellOffsetX: number;
    private _dropCellWidth: number;
    private _dragOverDirection: string;
    private _selectable: boolean;
    // Note: Used to tell to the SelectorService to skip pagination logic
    private _hasVirtualScroll: boolean;
    private _totalItems: number;
    private _dataSource: any[];
    private _selection: ISelection &#x3D; {
        isAllPages: false,
        include: [],
        exclude: [],
    };
    public _trackBy: TrackByFunction&lt;any&gt;;

    protected state: ITableState &#x3D; {
        columnAlignments: {},
        columns: [],
        columnsWidths: {},
        widthCalculationPerformed: false,
        columnsTypes: [],
    };

    protected sortIcons: { [key: string]: string } &#x3D; {
        &quot;asc&quot;: &quot;triangle-up&quot;,
        &quot;desc&quot;: &quot;triangle-down&quot;,
    };

    constructor(protected zone: NgZone, @Inject(forwardRef(() &#x3D;&gt; SelectorService)) protected selectorService: SelectorService) {
    }

    /**
     * Used to sync directives and components in table to apply additional styles and logic
     */
    set sortable(isSortable: boolean) {
        this._sortable &#x3D; isSortable;
    }

    get sortable() {
        return this._sortable;
    }

    set dragCellIndex(cellIndex: number) {
        this._dragCellIndex &#x3D; cellIndex;
    }

    get dragCellIndex() {
        return this._dragCellIndex;
    }

    set draggedOverCellIndex(cellIndex: number) {
        this._draggedOverCellIndex &#x3D; cellIndex;
    }

    get draggedOverCellIndex() {
        return this._draggedOverCellIndex;
    }

    set newCellIndex(cellIndex: number) {
        this._newCellIndex &#x3D; cellIndex;
    }

    get newCellIndex() {
        return this._newCellIndex;
    }

    set dropCellOffsetX(cellIndex: number) {
        this._dropCellOffsetX &#x3D; cellIndex;
    }

    get dropCellOffsetX() {
        return this._dropCellOffsetX;
    }

    set dropCellWidth(cellIndex: number) {
        this._dropCellWidth &#x3D; cellIndex;
    }

    get dropCellWidth() {
        return this._dropCellWidth;
    }

    set dragOverDirection(cellIndex: string) {
        this._dragOverDirection &#x3D; cellIndex;
    }

    get dragOverDirection() {
        return this._dragOverDirection;
    }

    set reorderable(isDraggable: boolean) {
        this._reorderable &#x3D; isDraggable;
    }

    get reorderable() {
        return this._reorderable;
    }

    set resizable(isResizable: boolean) {
        this._resizable &#x3D; isResizable;
    }

    get resizable() {
        return this._resizable;
    }

    set tableColumns(columns: string[]) {
        this.state.columns &#x3D; columns;
    }

    get tableColumns() {
        return this.state.columns;
    }

    set columnType(column: ColumnType) {
        const columnIndex &#x3D; this.state.columns.indexOf(column.columnName);
        this.state.columnsTypes[columnIndex] &#x3D; column.columnType;
    }

    get columnsTypes() {
        return this.state.columnsTypes;
    }

    set sortedColumn(columnToSort: ISortedItem) {
        this.state.sortedColumn &#x3D; columnToSort;
    }

    set selectable(isSelectable: boolean) {
        this._selectable &#x3D; isSelectable;
    }

    get selectable() {
        return this._selectable;
    }

    get hasVirtualScroll(): boolean {
        return this._hasVirtualScroll;
    }

    set hasVirtualScroll(value: boolean) {
        this._hasVirtualScroll &#x3D; value;
    }

    set totalItems(paginationTotal: number) {
        this._totalItems &#x3D; paginationTotal;
    }

    get totalItems() {
        return this._totalItems;
    }

    set dataSource(dataSource: any[]) {
        this._dataSource &#x3D; dataSource;
    }

    get dataSource() {
        return this._dataSource;
    }

    set selection(selection: ISelection) {
        this._selection &#x3D; selection;
    }

    get selection() {
        return this._selection;
    }

    get trackBy(): TrackByFunction&lt;any&gt; {
        return this._trackBy || DEFAULT_TRACK_BY;
    }

    set trackBy(value) {
        this._trackBy &#x3D; value;
    }

    /**
     * Gets the width of the specified column
     *
     * @param column The id for the column being queried
     *
     * @returns The state&#x27;s column width
     */
    public getColumnWidth(column: string): number {
        if (!this.state.widthCalculationPerformed) {
            this.calculateWidthsOfColumns();
        }
        return this.state.columnsWidths[column].width;
    }
    
    /**
     * Updates the width of the specified column,
     * then broadcasts that a width change has occurred to all listeners of columnWidthSubject
     *
     * @param column The id for the column
     * @param width The new width of the column
     *
     */
    public setColumnWidth(column: string, width: number): void {
        this.state.columnsWidths[column] &#x3D; { width };
        this.columnWidthSubject.next();
    }

    /**
     * Returns the current alignment direction for the queried column
     *
     * @param column The id of the column
     *
     * @returns The current alignment direction
     */
    public getAlignment(column: string): string {
        return this.state.columnAlignments[column];
    }

    /**
     * Updates the specified column&#x27;s alignment with the given alignment direction
     *
     * @param column the id for the column that is being updated
     * @param alignment the new alignment direction
     *
     */
    public setAlignment(column: string, alignment: string &#x3D; AlignmentClasses.LEFT): void {
        this.state.columnAlignments[column] &#x3D; alignment || this.state.columnAlignments[column];
    }

    /**
     * Determines the alignment for a column based on the type of the provided value.
     * Returns AlignmentClasses.RIGHT if the value given is a number; otherwise, returns &#x27;undefined&#x27;.
     *
     * @param value The data for a given column
     *
     * @returns The alignment direction for that column
     */
    public defineAlignment(value: any): string | undefined {
        if (_isNumber(value)) {
            return AlignmentClasses.RIGHT;
        }
    }

    /**
     * Updates the state&#x27;s columnWidths for each column and sets the state&#x27;s widthCalculationPerformed property
     * to true once the calculation is complete
     */
    public calculateWidthsOfColumns() {
        // Apply width of 40px for non-resizable columns of type &quot;icon&quot;
        this.state.columns
            .filter(columnName &#x3D;&gt; {
                const columnIndex &#x3D; this.state.columns.indexOf(columnName);
                return this.state.columnsTypes[columnIndex] &#x3D;&#x3D;&#x3D; &quot;icon&quot;;
            })
            .forEach(column &#x3D;&gt; {
                this.state.columnsWidths[column] &#x3D; { width: ICON_CELL_WIDTH_PX };
            });

        // &quot;selectable&quot; adding one more column with 75px width which is not in the &quot;this.state.columns&quot;, so we need take it to the consideration
        const accumulator &#x3D; (this.resizable &amp;&amp; this.selectable) ? SELECTABLE_CELL_WIDTH_PX : 0;
        const userColumnsWidths &#x3D; this.state.columns
            .filter(columnName &#x3D;&gt; this.state.columnsWidths[columnName])
            .reduce((total, curr) &#x3D;&gt;
                total + this.state.columnsWidths[curr].width, accumulator);
        const widthConsideringUserInputs &#x3D; userColumnsWidths &gt; this.tableParentWidth ? 0 : this.tableParentWidth - userColumnsWidths - 1;
        const columnsToCalculateWidth &#x3D; this.state.columns
            .filter(columnName &#x3D;&gt; !this.state.columnsWidths[columnName])
            .length;
        const calculatedWidth &#x3D; Math.floor(widthConsideringUserInputs / columnsToCalculateWidth);
        const widthOfColumn &#x3D; calculatedWidth &gt; MIN_COLUMN_WIDTH_PX ? calculatedWidth : MIN_COLUMN_WIDTH_PX;

        this.state.columns
            .filter(columnName &#x3D;&gt; !this.state.columnsWidths[columnName])
            .forEach(column &#x3D;&gt; {
                // There is a case when sum of columns can exceed width of parent
                // Then width of other columns should be set to min width
                this.state.columnsWidths[column] &#x3D; { width: widthOfColumn };
            });

        this.state.widthCalculationPerformed &#x3D; true;
    }
    
    /**
     * Updates the state&#x27;s sortedColumn and sortedColumn.direction properties and then broadcasts the
     *  state object to all listeners of sortingState
     *
    * @param sortCellIndex the index of the column to sort by
     */
    public sortColumn(sortCellIndex: number) {
        const newSortedColumn &#x3D; this.state.columns[sortCellIndex];
        const prevSortedColumn &#x3D; this.state.sortedColumn &amp;&amp; this.state.sortedColumn.sortBy;
        const prevSortDirection &#x3D; this.state.sortedColumn &amp;&amp; this.state.sortedColumn.direction;

        let newSortDirection &#x3D; SorterDirection.original;

        if (newSortedColumn &#x3D;&#x3D;&#x3D; prevSortedColumn) {
            newSortDirection &#x3D; (prevSortDirection &#x3D;&#x3D;&#x3D; SorterDirection.ascending) ?
                SorterDirection.descending : SorterDirection.ascending;
        } else {
            newSortDirection &#x3D; SorterDirection.ascending;
        }

        this.state.sortedColumn &#x3D; {
            sortBy: newSortedColumn,
            direction: newSortDirection,
        };

        this.sortingState.next(this.state.sortedColumn);
    }

    /**
     * Updates the state&#x27;s column order and broadcasts the state&#x27;s columns to all listeners of columnsState
     *
     * @param dragCellIndex
     * @param newCellIndex
     */
    public reorderColumns(dragCellIndex: number, newCellIndex: number): void {
        const dragCellValue &#x3D; this.state.columns[dragCellIndex];
        this.state.columns.splice(dragCellIndex, 1);
        this.state.columns.splice(newCellIndex, 0, dragCellValue);
        this.columnsState.next(this.state.columns);
    }

    /**
     * Checks to see if there has been any change in the column&#x27;s order
     * If there was it calls reorderColumns to update the state&#x27;s column order
     */
    public reorderColumnsOnDrop(): void {
        this.getNewCellIndex();

        if (!_isNil(this.newCellIndex) &amp;&amp; (this.newCellIndex !&#x3D;&#x3D; this.dragCellIndex) &amp;&amp; (this.dragCellIndex !&#x3D;&#x3D; this.draggedOverCellIndex)) {
            this.reorderColumns(this.dragCellIndex, this.newCellIndex);
        }
    }

    /**
     * Updates the newCellIndex property if the current value is different from draggedOverCellIndex
     */
    public getNewCellIndex(): void {
        if (this.dragCellIndex !&#x3D;&#x3D; this.draggedOverCellIndex) {
            this.newCellIndex &#x3D; (this.dragCellIndex &lt; this.draggedOverCellIndex)
                ? ((this.dropCellOffsetX &lt; this.dropCellWidth / 2) ? (this.draggedOverCellIndex - 1) : this.draggedOverCellIndex)
                : ((this.dropCellOffsetX &lt; this.dropCellWidth / 2) ? this.draggedOverCellIndex : (this.draggedOverCellIndex + 1));
        }
    }

    /**
     * Finds the index for the column that the event happened to
     *
     * @param event
     *
     * @returns The column index
     */
    public getTargetElementCellIndex(event: DragEvent): number {
        // When we have selectable table we need to decrease index of event.target.id by one because we added new column to html but not adding column to
        // this.state.columns. Because of that cellIndex in event will be greater than index in this.state.columns by one.
        const cellIndex &#x3D; parseInt((event.target as any).cellIndex, 10);
        return this.selectable ? cellIndex - 1 : cellIndex;
    }

    /**
     * Returns the DropAlignment direction for the recently dragged column
     *
     * @returns The drop alignment direction
     */
    public getDropCellAlignment(): DropAlignment {
        return ((this.dragCellIndex &lt; this.draggedOverCellIndex)
            ? ((this.newCellIndex &lt; this.draggedOverCellIndex) ? DropAlignment.left : DropAlignment.right)
            : ((this.newCellIndex &gt; this.draggedOverCellIndex) ? DropAlignment.right : DropAlignment.left));
    }

    /**
     * Checks to see if the recent drag event changed the order of the columns
     * then broadcasts the results to all listeners of draggedOverCell
     */
    public emitDraggedOverCell(): void {
        this.zone.run(() &#x3D;&gt; {
            if ((this.dragCellIndex !&#x3D;&#x3D; this.draggedOverCellIndex) &amp;&amp; (this.dragCellIndex !&#x3D;&#x3D; this.newCellIndex)) {
                this.draggedOverCell.next(&lt;DraggedOverCell&gt;{
                    cellIndex: this.draggedOverCellIndex,
                    dropAlignment: this.getDropCellAlignment(),
                });
            } else {
                this.draggedOverCell.next(undefined);
            }
        });
    }

    /**
     * Broadcasts the given resize information to all listeners of shouldHighlightEdge
     *
     * @param columnIndex
     * @param eventPhase
     */
    public emitResizeEvent(columnIndex: number, eventPhase: TableResizePhase): void {
        this.shouldHighlightEdge.next({ columnIndex, side: DropAlignment.right, eventPhase });
    }

    /**
     * Updates the draggedOverCellIndex
     *
     * @param event
     */
    public setDraggedOverCell(event: DragEvent): void {
        const dropCellOffsetX: number &#x3D; event.offsetX;
        const dropCellWidth: number &#x3D; (event.target as HTMLElement).clientWidth;
        const dragOverDirection: string &#x3D; (dropCellOffsetX &lt; dropCellWidth / 2) ? &quot;left-right&quot; : &quot;right-left&quot;;
        const draggedOverCellIndex: number &#x3D; this.getTargetElementCellIndex(event);

        const draggedOverCellChanged: boolean &#x3D;
            _isNil(this.dragOverDirection) ||
            _isNil(this.draggedOverCellIndex) ||
            draggedOverCellIndex !&#x3D;&#x3D; this.draggedOverCellIndex ||
            dragOverDirection !&#x3D;&#x3D; this.dragOverDirection;

        if (draggedOverCellChanged) {
            this.dropCellOffsetX &#x3D; dropCellOffsetX;
            this.dropCellWidth &#x3D; dropCellWidth;
            this.dragOverDirection &#x3D; dragOverDirection;
            this.draggedOverCellIndex &#x3D; draggedOverCellIndex;
            this.getNewCellIndex();
            this.emitDraggedOverCell();
        }
    }

    /**
     * Updates the dataSource property and broadcasts the change to all listeners of dataSourceChanged
     *
     * @param dataSource
     */
    public changeDataSource(dataSource: any[]) {
        this.dataSource &#x3D; dataSource;
        this.dataSourceChanged.next(dataSource);
    }

    /**
     * Returns an array of the selected items
     *
     * @returns An array of all currently selected items
     */
    public getSelectedItems() {
        const trackedItems &#x3D; this.dataSource.map(d &#x3D;&gt; this.trackBy(d?.id, d));
        return this.selectorService.getSelectedItems(this.selection, trackedItems);
    }

    /**
     * Returns the current state of the selector
     *
     * @returns
     */
    public getSelectorState(): ISelectorState {
        return this.selectorService.getSelectorState(
            this.selection,
            this.dataSource.length,
            this.getSelectedItems().length,
            this.totalItems,
            this.selection.include.length,
            this.hasVirtualScroll
        );
    }

    /**
     * Updates the selection type and returns a new selection object based on that new selection type
     *
     * @param selectorValue
     *
     * @returns The newly applied selection
     */
    public applySelector(selectorValue: SelectionType): ISelection {
        return this.selectorService.applySelector(
            this.selection,
            this.dataSource,
            selectorValue,
            this.totalItems,
            this.trackBy,
            this.hasVirtualScroll
        );
    }

    /**
     * Updates the selection object to either include or exclude the row based on the current selection
     *  type and the row&#x27;s current selection state
     * Then the selection object is broadcasted to all listeners of selectionChanged
     *
     * @param rowObject
     */
    public handleRowCheckbox(rowObject: Object) {
        const excludedRows &#x3D; this.selection.exclude;
        const includedRows &#x3D; this.selection.include;

        const rowObjectTrackBy &#x3D; this.trackBy((&lt;{id: number}&gt;rowObject)?.id, rowObject);

        if (this.selection.isAllPages) {
            if (!_includes(excludedRows, rowObjectTrackBy)) {
                excludedRows.push(rowObjectTrackBy);
            } else {
                excludedRows.splice(excludedRows.indexOf(rowObjectTrackBy), 1);
            }
        } else {
            if (!_includes(includedRows, rowObjectTrackBy)) {
                includedRows.push(rowObjectTrackBy);
            } else {
                includedRows.splice(includedRows.indexOf(rowObjectTrackBy), 1);
            }
        }

        this.selectionChanged.next(this.selection);
    }

    /**
     * Returns the current sorting state of the specified cell index
     *
     * @param cellIndex
     *
     * @returns The current sorting state
     */
    public getSortingState(cellIndex: number): ITableSortingState {
        if (this.state.sortedColumn) {
            return {
                sortingIcon: this.sortIcons[this.state.sortedColumn.direction],
                // comparing column index with index of sorted column
                isColumnSorted: cellIndex &#x3D;&#x3D;&#x3D; this.state.columns.indexOf(this.state.sortedColumn.sortBy) &amp;&amp; this.sortable,
            };
        }
        return {
            sortingIcon: undefined,
            isColumnSorted: false,
        };
    }

    /**
     * Broadcasts to all listeners of stickyHeaderChangedSubject that a change has occurred
     */
    public applyStickyStyles(): void {
        this.stickyHeaderChangedSubject.next();
    }
}
</code></pre>
    </div>
</div>






                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'ITableState.html';
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
