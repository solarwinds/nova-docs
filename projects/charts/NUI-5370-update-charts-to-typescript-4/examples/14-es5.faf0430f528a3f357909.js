!function(){function t(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function e(e){for(var a=1;a<arguments.length;a++){var s=null!=arguments[a]?arguments[a]:{};a%2?t(Object(s),!0).forEach((function(t){n(e,t,s[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):t(Object(s)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(s,t))}))}return e}function n(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function a(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t,e){for(var n=0;n<e.length;n++){var a=e[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(t,a.key,a)}}(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{E2It:function(t,e,n){"use strict";n.r(e),e.default='import { Component, OnInit, ViewEncapsulation } from "@angular/core";\nimport {\n    BandScale,\n    barAccessors,\n    BarGridConfig,\n    BarHighlightStrategy,\n    BarRenderer,\n    barScales,\n    BarStatusGridConfig,\n    BorderConfig,\n    Chart,\n    CHART_PALETTE_CS1,\n    CHART_PALETTE_CS_S,\n    convert,\n    DataAccessor,\n    DATA_POINT_NOT_FOUND,\n    IAccessors,\n    IBarRendererConfig,\n    IChartEvent,\n    IDataPoint,\n    IDataSeries,\n    IInteractionDataPointsEvent,\n    IInteractionValues,\n    IInteractionValuesPayload,\n    InteractionLabelPlugin,\n    InteractionLinePlugin,\n    InteractionType,\n    INTERACTION_DATA_POINTS_EVENT,\n    INTERACTION_VALUES_EVENT,\n    IXYScales,\n    MappedValueProvider,\n    MOUSE_ACTIVE_EVENT,\n    SelectedDatPointIdxFn,\n    StatusAccessors,\n    statusAccessors,\n    TimeIntervalScale,\n    UtilityService,\n    XYGrid\n} from "@nova-ui/charts";\nimport isEmpty from "lodash/isEmpty";\nimport isUndefined from "lodash/isUndefined";\nimport moment, { duration } from "moment/moment";\n\nconst format = "YYYY-MM-DDTHH:mm:ssZ";\nconst baseDate = "2016-12-25T15:05:00Z";\n\nenum Status {\n    Up = "up",\n    Warning = "warning",\n    Critical = "critical",\n}\n\n@Component({\n    templateUrl: "./data-point-selection-prototype.component.html",\n    styleUrls: ["./data-point-selection-prototype.component.less"],\n    encapsulation: ViewEncapsulation.None,\n})\nexport class DataPointSelectionPrototypeComponent implements OnInit {\n    public barChart: Chart;\n    public statusChart: Chart;\n\n    // Use the same \'x\' scale id for both charts to ensure that interaction events such as hover are shared between the charts\n    private xScaleId = "xScale";\n\n    private selectedDataPoints: Record<string, IDataPoint> = {};\n    private labelPlugin = new InteractionLabelPlugin();\n    private renderer: BarRenderer;\n    private selectedLabelPosition?: IInteractionValues;\n\n    private colorProvider = {\n        // sets the bars used to visualize the selection box to \'transparent\'. All other bars just use the first color in the CS1 palette.\n        get: (seriesId: string) => seriesId === "selection-box" ? "transparent" : CHART_PALETTE_CS1[0],\n        reset: () => { },\n    };\n\n    public ngOnInit() {\n        this.setUpBarChart();\n        this.setUpStatusChart();\n    }\n\n    public onReset() {\n        // Reset the stored selection\n        this.selectedDataPoints = {};\n        this.selectedLabelPosition = undefined;\n\n        // Redraw the charts\n        this.redrawCharts();\n\n        // Re-enable interaction label updates and hide the label by emitting a mouse move \'INTERACTION_VALUES_EVENT\' with empty values.\n        this.labelPlugin.areLabelUpdatesEnabled = true;\n        this.barChart.getEventBus().getStream(INTERACTION_VALUES_EVENT).next({ data: { interactionType: InteractionType.MouseMove, values: {} } });\n    }\n\n    private setUpBarChart() {\n        this.barChart = new Chart(this.configureBarGrid());\n        this.barChart.addPlugin(new InteractionLinePlugin());\n        this.barChart.addPlugin(this.labelPlugin);\n\n        // Setting up data point click handling\n        this.barChart.getEventBus().getStream(INTERACTION_DATA_POINTS_EVENT).subscribe(this.handleDataPointsInteraction);\n        // Setting up interaction label update handling\n        this.barChart.getEventBus().getStream(INTERACTION_VALUES_EVENT).subscribe(this.handleInteractionLabelUpdates);\n        // Setting up what happens on chart mouseenter and mouseleave\n        this.barChart.getEventBus().getStream(MOUSE_ACTIVE_EVENT).subscribe(this.handleMouseActive);\n\n        // The color provider sets the selection boxes to \'transparent\'\n        const accessors = barAccessors({}, this.colorProvider);\n        // The \'cssClassAccessor\' updates the stroke color of the selection box when a time interval is selected\n        accessors.data.cssClass = this.cssClassAccessor;\n\n        const scales = barScales();\n        // Use the same \'x\' scale id as the status chart to ensure that interaction events such as hover are shared between the charts\n        scales.x = new TimeIntervalScale(duration(5, "minutes"), this.xScaleId);\n\n        // The \'barThickness\' method sets the selection box width to be larger than the standard bars\n        accessors.data.thickness = this.barThickness(scales);\n\n        const rendererConfig: IBarRendererConfig = {\n            // Supply a \'selectedDataPointIdxFn\' to the \'BarHighlightStrategy\' to prevent the selected bar\n            // from being deemphasized/grayed out as the chart is hovered.\n            highlightStrategy: new BarHighlightStrategy("x", 1, this.selectedDataPointIdxFn),\n            cursor: "pointer",\n        };\n        this.renderer = new BarRenderer(rendererConfig);\n\n        // Initialize the bar chart\n        this.barChart.update(getData().map(s => ({\n            ...s,\n            accessors,\n            renderer: this.renderer,\n            scales,\n        })));\n    }\n\n    private setUpStatusChart() {\n        this.statusChart = new Chart(this.configureStatusGrid());\n        this.statusChart.addPlugin(new InteractionLinePlugin());\n\n        // Setting up the status chart scales\n        const statusYScale = new BandScale();\n        statusYScale.fixDomain(StatusAccessors.STATUS_DOMAIN);\n        // Use the same \'x\' scale id as the bar chart to ensure that interaction events such as hover are shared between the charts\n        const statusXScale = new TimeIntervalScale(duration(5, "minutes"), this.xScaleId);\n        statusXScale.fixDomain([moment(baseDate, format).toDate(), moment(baseDate, format).add(25, "minutes").toDate()]);\n        const statusScales = {\n            x: statusXScale,\n            y: statusYScale,\n        };\n\n        // Setting up the status chart accessors\n        const myStatusAccessors = statusAccessors(new MappedValueProvider<string>(getStatusValueMap()));\n        myStatusAccessors.data.thickness = (data: any) => data.status === Status.Up ? BarRenderer.THIN : BarRenderer.THICK;\n\n        // The \'cssClassAccessor\' updates the stroke color of the selection box when a time interval is selected\n        // TODO: Implement \'selection-box\' series for displaying the selection box on the status chart. For reference,\n        // see \'selection-box\' data series on the bar chart.\n        myStatusAccessors.data.cssClass = this.cssClassAccessor;\n\n        // Initializing the status chart\n        this.statusChart.update(getStatusData()\n            .map(d => ({\n                ...d,\n                accessors: myStatusAccessors,\n                renderer: this.renderer,\n                scales: statusScales,\n            })));\n    }\n\n    private configureBarGrid() {\n        const gridConfig = new BarGridConfig();\n\n        gridConfig.axis.left.visible = false;\n        gridConfig.axis.left.gridTicks = false;\n        // Disable \'axis.bottom.fit\' to set left and right margins manually\n        gridConfig.axis.bottom.fit = false;\n        gridConfig.borders.top = new BorderConfig();\n        gridConfig.cursor = "pointer";\n        gridConfig.dimension.padding.top = 0;\n        // Synchronize the left and right margins (left margin default is 30px)\n        gridConfig.dimension.margin.right = gridConfig.dimension.margin.left;\n\n        // Use these settings to make the bar chart the same height as the status chart\n        // gridConfig.dimension.autoHeight = false;\n        // gridConfig.dimension.height(30);\n\n        return new XYGrid(gridConfig);\n    }\n\n    private configureStatusGrid() {\n        const gridConfig = new BarStatusGridConfig();\n\n        gridConfig.axis.bottom.visible = false;\n        gridConfig.cursor = "pointer";\n        gridConfig.dimension.margin.bottom = 0;\n        // Synchronize the left and right margins (left margin default is 30px)\n        gridConfig.dimension.margin.right = gridConfig.dimension.margin.left;\n        gridConfig.borders.bottom.visible = false;\n\n        return new XYGrid(gridConfig);\n    }\n\n    private redrawCharts() {\n        this.barChart.update(this.barChart.getDataManager().chartSeriesSet);\n        this.statusChart.update(this.statusChart.getDataManager().chartSeriesSet);\n    }\n\n    private handleDataPointsInteraction = (event: IChartEvent) => {\n        const data: IInteractionDataPointsEvent = event.data;\n        // we\'re interested in data point click events here\n        if (data.interactionType === InteractionType.Click) {\n            // set the selected data points\n            this.selectedDataPoints = data.dataPoints;\n\n            if (this.renderer.config.stateStyles) {\n                // change the bar container opacity from 0.1 to 0.3\n                this.renderer.config.stateStyles.deemphasized = { opacity: 0.3 };\n            }\n\n            // redraw the charts to apply the selected data point style\n            this.redrawCharts();\n\n            // store the interaction label position for the selected data point\n            this.selectedLabelPosition = this.calculateInteractionLabelPosition(data);\n\n            // apply the label position based on the click\n            this.barChart.getEventBus().getStream(INTERACTION_VALUES_EVENT).next({\n                data: { interactionType: InteractionType.MouseMove, values: this.selectedLabelPosition },\n            });\n        }\n    }\n\n    private handleInteractionLabelUpdates = (event: IChartEvent) => {\n        const data: IInteractionValuesPayload = event.data;\n\n        // The condition checks whether the mouse has moved away from the chart and a selected label position is stored\n        if (data.interactionType === InteractionType.MouseMove && isEmpty(data.values) && this.selectedLabelPosition) {\n\n            // ensure label updates are enabled\n            this.labelPlugin.areLabelUpdatesEnabled = true;\n\n            // Update the label with the stored label position by manually emitting an \'INTERACTION_VALUES_EVENT\'.\n            // Note that \'broadcast\' is set to \'true\' to let the \'nuiChartCollection\' directive know that the event is\n            // coming from outside the chart and should not propagate to other charts in the collection.\n            this.barChart.getEventBus().getStream(INTERACTION_VALUES_EVENT).next({\n                data: { interactionType: InteractionType.MouseMove, values: this.selectedLabelPosition },\n                broadcast: true,\n            });\n\n            // disable further label updates\n            this.labelPlugin.areLabelUpdatesEnabled = false;\n\n        } else if (data.interactionType === InteractionType.MouseMove && !isEmpty(data.values)) {\n\n            // allow label updates while the mouse is hovering over the chart\n            this.labelPlugin.areLabelUpdatesEnabled = true;\n        }\n    }\n\n    private handleMouseActive = (event: IChartEvent) => {\n        if (this.renderer.config.stateStyles) {\n            if (!isEmpty(this.selectedDataPoints) && !event.data) {\n                // if there\'s a selected data point and the mouse has moved away\n                // from the chart, set the bar container opacity to 0.3\n                this.renderer.config.stateStyles.deemphasized = { opacity: 0.3 };\n            } else if (event.data) {\n                // if the mouse is over the chart set the bar container opacity to 0.3\n                this.renderer.config.stateStyles.deemphasized = { opacity: 0.1 };\n            }\n        }\n\n        if (this.barChart.getDataManager().chartSeriesSet.length > 0 && this.statusChart.getDataManager().chartSeriesSet.length > 0) {\n            // redraw the charts if we have data\n            this.redrawCharts();\n        }\n    }\n\n    /**\n     * Sets the width of the bars on the bar chart. (This is only necessary if you want the selection boxes\n     * to be wider than the standard bars).\n     */\n    private barThickness(scales: IXYScales): DataAccessor<any, any> {\n        return (d: any, i: number, series: any[], dataSeries: IDataSeries<IAccessors>) => {\n            let thickness: number;\n            const x1 = convert(scales.x, dataSeries.accessors.data?.["startX"]?.(d, i, dataSeries.data, dataSeries), 0);\n            const x2 = convert(scales.x, dataSeries.accessors.data?.["endX"]?.(d, i, dataSeries.data, dataSeries), 1);\n            thickness = Math.abs(x1 - x2);\n\n            // Allow the selection boxes to be a little wider than the data bars\n            thickness -= dataSeries.id === "selection-box" ? 2 : 6;\n            thickness = Math.max(thickness, BarRenderer.MIN_BAR_THICKNESS);\n            return thickness;\n        };\n    }\n\n    /**\n     * Allows the \'BarHighlightingStrategy\' to know which data point (or bar) on a series is selected, if any.\n     * Return \'DATA_POINT_NOT_FOUND\' if no data point is selected on the specified series.\n     */\n    private selectedDataPointIdxFn: SelectedDatPointIdxFn = (seriesId: string): number => this.selectedDataPoints?.[seriesId]?.index ?? DATA_POINT_NOT_FOUND;\n\n    /**\n     * Sets the stroke color of the selection box when a time interval is selected\n     *\n     * @returns The \'selected\' class (see less file) if a bar is selected, the series id matches the selection box series, and the\n     * selected data point index matches the current index; otherwise, returns an empty string.\n     */\n    private cssClassAccessor = (d: any, i: number, series: any, dataSeries: any): string =>\n        !isEmpty(this.selectedDataPoints) && dataSeries.id === "selection-box" && this.selectedDataPoints[dataSeries.id]?.index === i ? "selected" : ""\n\n    /**\n     * Calculates the desired position of the interaction label based on the position of the first data point in the event payload\n     */\n    private calculateInteractionLabelPosition(data: IInteractionDataPointsEvent): IInteractionValues {\n        const sampleDataPoint = data.dataPoints[Object.keys(data.dataPoints)[0]];\n        const xScales = [sampleDataPoint.dataSeries.scales.x];\n        const yScales = [sampleDataPoint.dataSeries.scales.y];\n\n        if (!sampleDataPoint.position || isUndefined(sampleDataPoint.position.width) || isUndefined(sampleDataPoint.position.height)) {\n            throw new Error("Can\'t calculate x and y values");\n        }\n\n        const xCoordinate = sampleDataPoint.position.x + sampleDataPoint.position.width / 2;\n        const yCoordinate = sampleDataPoint.position.y + sampleDataPoint.position.height / 2;\n\n        return UtilityService.getXYValues(xScales, yScales, xCoordinate, yCoordinate);\n    }\n}\n\n/* Chart data */\nfunction getData() {\n    return [\n        {\n            id: "series-1",\n            data: [\n                { category: moment(baseDate, format).toDate(), value: 66 },\n                { category: moment(baseDate, format).add(5, "minutes").toDate(), value: 14 },\n                { category: moment(baseDate, format).add(10, "minutes").toDate(), value: 25 },\n                { category: moment(baseDate, format).add(15, "minutes").toDate(), value: 55 },\n                { category: moment(baseDate, format).add(20, "minutes").toDate(), value: 33 },\n                { category: moment(baseDate, format).add(25, "minutes").toDate(), value: 5 },\n            ],\n        },\n\n        // The sole purpose of this series is to define the selection boxes that have a togglable selection\n        // outline. The \'fill\' of the boxes is set to transparent by the \'colorProvider\' in the component\n        // above. And, the blue outline of the selected time interval is toggled by the \'cssClassAccessor\'\n        // method in the above component.\n        {\n            id: "selection-box",\n            data: [\n                { category: moment(baseDate, format).toDate(), value: 100 },\n                { category: moment(baseDate, format).add(5, "minutes").toDate(), value: 100 },\n                { category: moment(baseDate, format).add(10, "minutes").toDate(), value: 100 },\n                { category: moment(baseDate, format).add(15, "minutes").toDate(), value: 100 },\n                { category: moment(baseDate, format).add(20, "minutes").toDate(), value: 100 },\n                { category: moment(baseDate, format).add(25, "minutes").toDate(), value: 100 },\n            ],\n        },\n    ];\n}\n\nfunction getStatusValueMap() {\n    return {\n        [Status.Up]: CHART_PALETTE_CS_S[4],\n        [Status.Warning]: CHART_PALETTE_CS_S[2],\n        [Status.Critical]: CHART_PALETTE_CS_S[1],\n    };\n}\n\nfunction getStatusData() {\n    return [{\n        id: "series-1",\n        name: "Series 1",\n        data: [\n            {\n                status: Status.Up,\n                start: moment(baseDate, format).toDate(),\n                end: moment(baseDate, format).toDate(),\n            },\n            {\n                status: Status.Warning,\n                start: moment(baseDate, format).add(5, "minutes").toDate(),\n                end: moment(baseDate, format).add(5, "minutes").toDate(),\n            },\n            {\n                status: Status.Critical,\n                start: moment(baseDate, format).add(10, "minutes").toDate(),\n                end: moment(baseDate, format).add(10, "minutes").toDate(),\n            },\n            {\n                status: Status.Up,\n                start: moment(baseDate, format).add(15, "minutes").toDate(),\n                end: moment(baseDate, format).add(15, "minutes").toDate(),\n            },\n            {\n                status: Status.Critical,\n                start: moment(baseDate, format).add(20, "minutes").toDate(),\n                end: moment(baseDate, format).add(20, "minutes").toDate(),\n            },\n            {\n                status: Status.Up,\n                start: moment(baseDate, format).add(25, "minutes").toDate(),\n                end: moment(baseDate, format).add(25, "minutes").toDate(),\n            },\n        ],\n    }];\n\n}\n'},IPrL:function(t,e,n){"use strict";n.r(e),e.default='<nui-example-wrapper filenamePrefix="data-point-selection-prototype" exampleTitle="Data Point Selection Prototype">\n    <nui-message type="critical" [allowDismiss]="false">\n        <strong>Note:</strong> This is only a prototype, so its implementation is unpolished. Please\n        use discretion when copying the code as there are likely solutions more concise and/or\n        elegant than those presented here.\n        <strong>For assistance, please contact Blake Simmon or Lukas Holcik.</strong>\n    </nui-message>\n    <hr>\n    <nui-chart class="d-flex chart" [chart]="statusChart" nuiChartCollectionId="collection"></nui-chart>\n    <nui-chart class="d-flex chart" [chart]="barChart" nuiChartCollectionId="collection"></nui-chart>\n    <hr>\n    <button type="button" nui-button (click)="onReset()">Reset</button>\n</nui-example-wrapper>\n'},Onqy:function(t,e,n){"use strict";n.r(e),e.default='import { NgModule } from "@angular/core";\nimport { RouterModule, Routes } from "@angular/router";\nimport { DEMO_PATH_TOKEN, NuiButtonModule, NuiDocsModule, NuiIconModule, NuiMessageModule } from "@nova-ui/bits";\nimport { NuiChartsModule } from "@nova-ui/charts";\n\nimport { DemoCommonModule } from "../../common/demo-common.module";\n\nimport { DataPointSelectionPrototypeComponent } from "./data-point-selection-prototype.component";\n\nconst routes: Routes = [\n    {\n        path: "",\n        component: DataPointSelectionPrototypeComponent,\n        data: {\n            "srlc": {\n                "hideIndicator": true,\n            },\n        },\n    },\n];\n\n@NgModule({\n    declarations: [\n        DataPointSelectionPrototypeComponent,\n    ],\n    imports: [\n        DemoCommonModule,\n        NuiButtonModule,\n        NuiDocsModule,\n        NuiMessageModule,\n        NuiChartsModule,\n        NuiIconModule,\n        RouterModule.forChild(routes),\n    ],\n    providers: [\n        { provide: DEMO_PATH_TOKEN, useFactory: () =>  (<any> require).context(`!!raw-loader!./`, true, /.*\\.(ts|html|less)$/)},\n    ],\n})\nexport class DataPointSelectionPrototypeModule {\n}\n'},YAGT:function(t,e,n){var a={"./data-point-selection-prototype.component.html":"IPrL","./data-point-selection-prototype.component.less":"emcV","./data-point-selection-prototype.component.ts":"E2It","./data-point-selection-prototype.module.ts":"Onqy"};function s(t){var e=i(t);return n(e)}function i(t){if(!n.o(a,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}return a[t]}s.keys=function(){return Object.keys(a)},s.resolve=i,t.exports=s,s.id="YAGT"},a1WQ:function(t,i,r){"use strict";r.r(i),r.d(i,"DataPointSelectionPrototypeModule",(function(){return w}));var o,c,l=r("tyNb"),d=r("Rr1A"),u=r("gKry"),h=r("s1Ul"),m=r("E+oP"),p=r.n(m),b=r("TP7S"),g=r.n(b),f=r("wd/R"),v=r.n(f),y=r("fXoL"),S=r("HHUD"),C=r("MArq"),D="YYYY-MM-DDTHH:mm:ssZ",P="2016-12-25T15:05:00Z",T=function(t){return t.Up="up",t.Warning="warning",t.Critical="critical",t}({}),I=[{path:"",component:(o=function(){function t(){var e=this;a(this,t),this.xScaleId="xScale",this.selectedDataPoints={},this.labelPlugin=new u.K,this.colorProvider={get:function(t){return"selection-box"===t?"transparent":u.m[0]},reset:function(){}},this.handleDataPointsInteraction=function(t){var n=t.data;n.interactionType===u.M.Click&&(e.selectedDataPoints=n.dataPoints,e.renderer.config.stateStyles&&(e.renderer.config.stateStyles.deemphasized={opacity:.3}),e.redrawCharts(),e.selectedLabelPosition=e.calculateInteractionLabelPosition(n),e.barChart.getEventBus().getStream(u.J).next({data:{interactionType:u.M.MouseMove,values:e.selectedLabelPosition}}))},this.handleInteractionLabelUpdates=function(t){var n=t.data;n.interactionType===u.M.MouseMove&&p()(n.values)&&e.selectedLabelPosition?(e.labelPlugin.areLabelUpdatesEnabled=!0,e.barChart.getEventBus().getStream(u.J).next({data:{interactionType:u.M.MouseMove,values:e.selectedLabelPosition},broadcast:!0}),e.labelPlugin.areLabelUpdatesEnabled=!1):n.interactionType!==u.M.MouseMove||p()(n.values)||(e.labelPlugin.areLabelUpdatesEnabled=!0)},this.handleMouseActive=function(t){e.renderer.config.stateStyles&&(p()(e.selectedDataPoints)||t.data?t.data&&(e.renderer.config.stateStyles.deemphasized={opacity:.1}):e.renderer.config.stateStyles.deemphasized={opacity:.3}),e.barChart.getDataManager().chartSeriesSet.length>0&&e.statusChart.getDataManager().chartSeriesSet.length>0&&e.redrawCharts()},this.selectedDataPointIdxFn=function(t){var n,a,s;return null!==(s=null===(a=null===(n=e.selectedDataPoints)||void 0===n?void 0:n[t])||void 0===a?void 0:a.index)&&void 0!==s?s:u.y},this.cssClassAccessor=function(t,n,a,s){var i;return p()(e.selectedDataPoints)||"selection-box"!==s.id||(null===(i=e.selectedDataPoints[s.id])||void 0===i?void 0:i.index)!==n?"":"selected"}}var i,r,o;return i=t,(r=[{key:"ngOnInit",value:function(){this.setUpBarChart(),this.setUpStatusChart()}},{key:"onReset",value:function(){this.selectedDataPoints={},this.selectedLabelPosition=void 0,this.redrawCharts(),this.labelPlugin.areLabelUpdatesEnabled=!0,this.barChart.getEventBus().getStream(u.J).next({data:{interactionType:u.M.MouseMove,values:{}}})}},{key:"setUpBarChart",value:function(){var t=this;this.barChart=new u.q(this.configureBarGrid()),this.barChart.addPlugin(new u.L),this.barChart.addPlugin(this.labelPlugin),this.barChart.getEventBus().getStream(u.G).subscribe(this.handleDataPointsInteraction),this.barChart.getEventBus().getStream(u.J).subscribe(this.handleInteractionLabelUpdates),this.barChart.getEventBus().getStream(u.R).subscribe(this.handleMouseActive);var n=Object(u.yb)({},this.colorProvider);n.data.cssClass=this.cssClassAccessor;var a=Object(u.Ab)();a.x=new u.qb(Object(f.duration)(5,"minutes"),this.xScaleId),n.data.thickness=this.barThickness(a);var s={highlightStrategy:new u.e("x",1,this.selectedDataPointIdxFn),cursor:"pointer"};this.renderer=new u.g(s),this.barChart.update([{id:"series-1",data:[{category:v()(P,D).toDate(),value:66},{category:v()(P,D).add(5,"minutes").toDate(),value:14},{category:v()(P,D).add(10,"minutes").toDate(),value:25},{category:v()(P,D).add(15,"minutes").toDate(),value:55},{category:v()(P,D).add(20,"minutes").toDate(),value:33},{category:v()(P,D).add(25,"minutes").toDate(),value:5}]},{id:"selection-box",data:[{category:v()(P,D).toDate(),value:100},{category:v()(P,D).add(5,"minutes").toDate(),value:100},{category:v()(P,D).add(10,"minutes").toDate(),value:100},{category:v()(P,D).add(15,"minutes").toDate(),value:100},{category:v()(P,D).add(20,"minutes").toDate(),value:100},{category:v()(P,D).add(25,"minutes").toDate(),value:100}]}].map((function(s){return e(e({},s),{},{accessors:n,renderer:t.renderer,scales:a})})))}},{key:"setUpStatusChart",value:function(){var t,a=this;this.statusChart=new u.q(this.configureStatusGrid()),this.statusChart.addPlugin(new u.L);var s=new u.c;s.fixDomain(u.mb.STATUS_DOMAIN);var i=new u.qb(Object(f.duration)(5,"minutes"),this.xScaleId);i.fixDomain([v()(P,D).toDate(),v()(P,D).add(25,"minutes").toDate()]);var r={x:i,y:s},o=Object(u.Qb)(new u.S((n(t={},T.Up,u.o[4]),n(t,T.Warning,u.o[2]),n(t,T.Critical,u.o[1]),t)));o.data.thickness=function(t){return t.status===T.Up?u.g.THIN:u.g.THICK},o.data.cssClass=this.cssClassAccessor,this.statusChart.update([{id:"series-1",name:"Series 1",data:[{status:T.Up,start:v()(P,D).toDate(),end:v()(P,D).toDate()},{status:T.Warning,start:v()(P,D).add(5,"minutes").toDate(),end:v()(P,D).add(5,"minutes").toDate()},{status:T.Critical,start:v()(P,D).add(10,"minutes").toDate(),end:v()(P,D).add(10,"minutes").toDate()},{status:T.Up,start:v()(P,D).add(15,"minutes").toDate(),end:v()(P,D).add(15,"minutes").toDate()},{status:T.Critical,start:v()(P,D).add(20,"minutes").toDate(),end:v()(P,D).add(20,"minutes").toDate()},{status:T.Up,start:v()(P,D).add(25,"minutes").toDate(),end:v()(P,D).add(25,"minutes").toDate()}]}].map((function(t){return e(e({},t),{},{accessors:o,renderer:a.renderer,scales:r})})))}},{key:"configureBarGrid",value:function(){var t=new u.d;return t.axis.left.visible=!1,t.axis.left.gridTicks=!1,t.axis.bottom.fit=!1,t.borders.top=new u.k,t.cursor="pointer",t.dimension.padding.top=0,t.dimension.margin.right=t.dimension.margin.left,new u.ub(t)}},{key:"configureStatusGrid",value:function(){var t=new u.i;return t.axis.bottom.visible=!1,t.cursor="pointer",t.dimension.margin.bottom=0,t.dimension.margin.right=t.dimension.margin.left,t.borders.bottom.visible=!1,new u.ub(t)}},{key:"redrawCharts",value:function(){this.barChart.update(this.barChart.getDataManager().chartSeriesSet),this.statusChart.update(this.statusChart.getDataManager().chartSeriesSet)}},{key:"barThickness",value:function(t){return function(e,n,a,s){var i,r,o,c,l,d=Object(u.Cb)(t.x,null===(r=null===(i=s.accessors.data)||void 0===i?void 0:i.startX)||void 0===r?void 0:r.call(i,e,n,s.data,s),0),h=Object(u.Cb)(t.x,null===(c=null===(o=s.accessors.data)||void 0===o?void 0:o.endX)||void 0===c?void 0:c.call(o,e,n,s.data,s),1);return l=Math.abs(d-h),l-="selection-box"===s.id?2:6,l=Math.max(l,u.g.MIN_BAR_THICKNESS)}}},{key:"calculateInteractionLabelPosition",value:function(t){var e=t.dataPoints[Object.keys(t.dataPoints)[0]],n=[e.dataSeries.scales.x],a=[e.dataSeries.scales.y];if(!e.position||g()(e.position.width)||g()(e.position.height))throw new Error("Can't calculate x and y values");return u.sb.getXYValues(n,a,e.position.x+e.position.width/2,e.position.y+e.position.height/2)}}])&&s(i.prototype,r),o&&s(i,o),t}(),o.\u0275fac=function(t){return new(t||o)},o.\u0275cmp=y.Hb({type:o,selectors:[["ng-component"]],decls:13,vars:3,consts:[["filenamePrefix","data-point-selection-prototype","exampleTitle","Data Point Selection Prototype"],["type","critical",3,"allowDismiss"],["nuiChartCollectionId","collection",1,"d-flex","chart",3,"chart"],["type","button","nui-button","",3,"click"]],template:function(t,e){1&t&&(y.Tb(0,"nui-example-wrapper",0),y.Tb(1,"nui-message",1),y.Tb(2,"strong"),y.Kc(3,"Note:"),y.Sb(),y.Kc(4," This is only a prototype, so its implementation is unpolished. Please use discretion when copying the code as there are likely solutions more concise and/or elegant than those presented here. "),y.Tb(5,"strong"),y.Kc(6,"For assistance, please contact Blake Simmon or Lukas Holcik."),y.Sb(),y.Sb(),y.Ob(7,"hr"),y.Ob(8,"nui-chart",2),y.Ob(9,"nui-chart",2),y.Ob(10,"hr"),y.Tb(11,"button",3),y.gc("click",(function(){return e.onReset()})),y.Kc(12,"Reset"),y.Sb(),y.Sb()),2&t&&(y.Bb(1),y.qc("allowDismiss",!1),y.Bb(7),y.qc("chart",e.statusChart),y.Bb(1),y.qc("chart",e.barChart))},directives:[d.h,d.o,S.a,C.a,d.b],styles:[".selected{stroke:#52d9e3!important}.chart{max-width:800px}"],encapsulation:2}),o),data:{srlc:{hideIndicator:!0}}}],w=((c=function t(){a(this,t)}).\u0275mod=y.Lb({type:c}),c.\u0275inj=y.Kb({factory:function(t){return new(t||c)},providers:[{provide:d.e,useFactory:function(){return r("YAGT")}}],imports:[[h.a,d.r,d.w,d.B,u.X,d.z,l.e.forChild(I)]]}),c)},emcV:function(t,e,n){"use strict";n.r(e),e.default=".selected {\n    stroke: #52d9e3 !important;\n}\n\n.chart {\n    max-width: 800px;\n}\n"}}])}();