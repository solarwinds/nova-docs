(self.webpackChunkexamples=self.webpackChunkexamples||[]).push([[164],{24444:(f,p,a)=>{var g={"./data-point-selection-prototype.component.html":40334,"./data-point-selection-prototype.component.less":79334,"./data-point-selection-prototype.component.ts":38534,"./data-point-selection-prototype.module.ts":45937,"components/demo/development/data-point-selection/data-point-selection-prototype.component.html":40334,"components/demo/development/data-point-selection/data-point-selection-prototype.component.less":79334,"components/demo/development/data-point-selection/data-point-selection-prototype.component.ts":38534,"components/demo/development/data-point-selection/data-point-selection-prototype.module.ts":45937};function u(b){var S=e(b);return a(S)}function e(b){if(!a.o(g,b)){var S=new Error("Cannot find module '"+b+"'");throw S.code="MODULE_NOT_FOUND",S}return g[b]}u.keys=function(){return Object.keys(g)},u.resolve=e,f.exports=u,u.id=24444},35164:(f,p,a)=>{"use strict";a.r(p),a.d(p,{DataPointSelectionPrototypeModule:()=>B});var g=a(76697),u=a(75148),e=a(48620),b=a(57378),S=a(71973),D=a.n(S),N=a(34235),A=a.n(N),E=a(15439),s=a.n(E),r=a(5e3),x=a(42210),O=a(63629);const i="YYYY-MM-DDTHH:mm:ssZ",o="2016-12-25T15:05:00Z";var m=(()=>{return(d=m||(m={})).Up="up",d.Warning="warning",d.Critical="critical",m;var d})();const L=[{path:"",component:(()=>{class d{constructor(){this.xScaleId="xScale",this.selectedDataPoints={},this.labelPlugin=new e.$fK,this.colorProvider={get:t=>"selection-box"===t?"transparent":e.cpE[0],reset:()=>{}},this.handleDataPointsInteraction=t=>{const n=t.data;n.interactionType===e.s_5.Click&&(this.selectedDataPoints=n.dataPoints,this.renderer.config.stateStyles&&(this.renderer.config.stateStyles.deemphasized={opacity:.3}),this.redrawCharts(),this.selectedLabelPosition=this.calculateInteractionLabelPosition(n),this.barChart.getEventBus().getStream(e.hkV).next({data:{interactionType:e.s_5.MouseMove,values:this.selectedLabelPosition}}))},this.handleInteractionLabelUpdates=t=>{const n=t.data;n.interactionType===e.s_5.MouseMove&&D()(n.values)&&this.selectedLabelPosition?(this.labelPlugin.areLabelUpdatesEnabled=!0,this.barChart.getEventBus().getStream(e.hkV).next({data:{interactionType:e.s_5.MouseMove,values:this.selectedLabelPosition},broadcast:!0}),this.labelPlugin.areLabelUpdatesEnabled=!1):n.interactionType===e.s_5.MouseMove&&!D()(n.values)&&(this.labelPlugin.areLabelUpdatesEnabled=!0)},this.handleMouseActive=t=>{this.renderer.config.stateStyles&&(D()(this.selectedDataPoints)||t.data?t.data&&(this.renderer.config.stateStyles.deemphasized={opacity:.1}):this.renderer.config.stateStyles.deemphasized={opacity:.3}),this.barChart.getDataManager().chartSeriesSet.length>0&&this.statusChart.getDataManager().chartSeriesSet.length>0&&this.redrawCharts()},this.selectedDataPointIdxFn=t=>{var n,h,c;return null!==(c=null===(h=null===(n=this.selectedDataPoints)||void 0===n?void 0:n[t])||void 0===h?void 0:h.index)&&void 0!==c?c:e.hZk},this.cssClassAccessor=(t,n,h,c)=>{var l;return D()(this.selectedDataPoints)||"selection-box"!==c.id||(null===(l=this.selectedDataPoints[c.id])||void 0===l?void 0:l.index)!==n?"":"selected"}}ngOnInit(){this.setUpBarChart(),this.setUpStatusChart()}onReset(){this.selectedDataPoints={},this.selectedLabelPosition=void 0,this.redrawCharts(),this.labelPlugin.areLabelUpdatesEnabled=!0,this.barChart.getEventBus().getStream(e.hkV).next({data:{interactionType:e.s_5.MouseMove,values:{}}})}setUpBarChart(){this.barChart=new e.kL2(this.configureBarGrid()),this.barChart.addPlugin(new e.koE),this.barChart.addPlugin(this.labelPlugin),this.barChart.getEventBus().getStream(e.C1c).subscribe(this.handleDataPointsInteraction),this.barChart.getEventBus().getStream(e.hkV).subscribe(this.handleInteractionLabelUpdates),this.barChart.getEventBus().getStream(e.CCM).subscribe(this.handleMouseActive);const t=(0,e.Q6e)({},this.colorProvider);t.data.cssClass=this.cssClassAccessor;const n=(0,e.CQI)();n.x=new e.lTH((0,E.duration)(5,"minutes"),this.xScaleId),t.data.thickness=this.barThickness(n);const h={highlightStrategy:new e.Pkp("x",1,this.selectedDataPointIdxFn),cursor:"pointer"};this.renderer=new e.Z7w(h),this.barChart.update(function w(){return[{id:"series-1",data:[{category:s()(o,i).toDate(),value:66},{category:s()(o,i).add(5,"minutes").toDate(),value:14},{category:s()(o,i).add(10,"minutes").toDate(),value:25},{category:s()(o,i).add(15,"minutes").toDate(),value:55},{category:s()(o,i).add(20,"minutes").toDate(),value:33},{category:s()(o,i).add(25,"minutes").toDate(),value:5}]},{id:"selection-box",data:[{category:s()(o,i).toDate(),value:100},{category:s()(o,i).add(5,"minutes").toDate(),value:100},{category:s()(o,i).add(10,"minutes").toDate(),value:100},{category:s()(o,i).add(15,"minutes").toDate(),value:100},{category:s()(o,i).add(20,"minutes").toDate(),value:100},{category:s()(o,i).add(25,"minutes").toDate(),value:100}]}]}().map(c=>Object.assign(Object.assign({},c),{accessors:t,renderer:this.renderer,scales:n})))}setUpStatusChart(){this.statusChart=new e.kL2(this.configureStatusGrid()),this.statusChart.addPlugin(new e.koE);const t=new e.jS7;t.fixDomain(e.s1E.STATUS_DOMAIN);const n=new e.lTH((0,E.duration)(5,"minutes"),this.xScaleId);n.fixDomain([s()(o,i).toDate(),s()(o,i).add(25,"minutes").toDate()]);const h={x:n,y:t},c=(0,e.s_I)(new e.oki(function M(){return{[m.Up]:e.Sj$[8],[m.Warning]:e.Sj$[4],[m.Critical]:e.Sj$[2]}}()));c.data.thickness=l=>l.status===m.Up?e.Z7w.THIN:e.Z7w.THICK,c.data.cssClass=this.cssClassAccessor,this.statusChart.update(function U(){return[{id:"series-1",name:"Series 1",data:[{status:m.Up,start:s()(o,i).toDate(),end:s()(o,i).toDate()},{status:m.Warning,start:s()(o,i).add(5,"minutes").toDate(),end:s()(o,i).add(5,"minutes").toDate()},{status:m.Critical,start:s()(o,i).add(10,"minutes").toDate(),end:s()(o,i).add(10,"minutes").toDate()},{status:m.Up,start:s()(o,i).add(15,"minutes").toDate(),end:s()(o,i).add(15,"minutes").toDate()},{status:m.Critical,start:s()(o,i).add(20,"minutes").toDate(),end:s()(o,i).add(20,"minutes").toDate()},{status:m.Up,start:s()(o,i).add(25,"minutes").toDate(),end:s()(o,i).add(25,"minutes").toDate()}]}]}().map(l=>Object.assign(Object.assign({},l),{accessors:c,renderer:this.renderer,scales:h})))}configureBarGrid(){const t=new e.TVc;return t.axis.left.visible=!1,t.axis.left.gridTicks=!1,t.axis.bottom.fit=!1,t.borders.top=new e.gyj,t.cursor="pointer",t.dimension.padding.top=0,t.dimension.margin.right=t.dimension.margin.left,new e.Be5(t)}configureStatusGrid(){const t=new e.mEc;return t.axis.bottom.visible=!1,t.cursor="pointer",t.dimension.margin.bottom=0,t.dimension.margin.right=t.dimension.margin.left,t.borders.bottom.visible=!1,new e.Be5(t)}redrawCharts(){this.barChart.update(this.barChart.getDataManager().chartSeriesSet),this.statusChart.update(this.statusChart.getDataManager().chartSeriesSet)}barThickness(t){return(n,h,c,l)=>{var C,I,y,P;let T;const H=(0,e.OQi)(t.x,null===(I=null===(C=l.accessors.data)||void 0===C?void 0:C.startX)||void 0===I?void 0:I.call(C,n,h,l.data,l),0),k=(0,e.OQi)(t.x,null===(P=null===(y=l.accessors.data)||void 0===y?void 0:y.endX)||void 0===P?void 0:P.call(y,n,h,l.data,l),1);return T=Math.abs(H-k),T-="selection-box"===l.id?2:6,T=Math.max(T,e.Z7w.MIN_BAR_THICKNESS),T}}calculateInteractionLabelPosition(t){const n=t.dataPoints[Object.keys(t.dataPoints)[0]],h=[n.dataSeries.scales.x],c=[n.dataSeries.scales.y];if(!n.position||A()(n.position.width)||A()(n.position.height))throw new Error("Can't calculate x and y values");return e.tIi.getXYValues(h,c,n.position.x+n.position.width/2,n.position.y+n.position.height/2)}}return d.\u0275fac=function(t){return new(t||d)},d.\u0275cmp=r.Xpm({type:d,selectors:[["ng-component"]],decls:13,vars:3,consts:[["filenamePrefix","data-point-selection-prototype","exampleTitle","Data Point Selection Prototype"],["type","critical",3,"allowDismiss"],["nuiChartCollectionId","collection",1,"d-flex","chart",3,"chart"],["type","button","nui-button","",3,"click"]],template:function(t,n){1&t&&(r.TgZ(0,"nui-example-wrapper",0)(1,"nui-message",1)(2,"strong"),r._uU(3,"Note:"),r.qZA(),r._uU(4," This is only a prototype, so its implementation is unpolished. Please use discretion when copying the code as there are likely solutions more concise and/or elegant than those presented here. "),r.TgZ(5,"strong"),r._uU(6,"For assistance, please contact Blake Simmon or Lukas Holcik."),r.qZA()(),r._UZ(7,"hr")(8,"nui-chart",2)(9,"nui-chart",2)(10,"hr"),r.TgZ(11,"button",3),r.NdJ("click",function(){return n.onReset()}),r._uU(12,"Reset"),r.qZA()()),2&t&&(r.xp6(1),r.Q6J("allowDismiss",!1),r.xp6(7),r.Q6J("chart",n.statusChart),r.xp6(1),r.Q6J("chart",n.barChart))},directives:[u.hD2,u.qqZ,x.x,O.V,u.r0F],styles:[".selected{stroke:#52d9e3!important}.chart{max-width:800px}\n"],encapsulation:2}),d})(),data:{srlc:{hideIndicator:!0}}}];let B=(()=>{class d{}return d.\u0275fac=function(t){return new(t||d)},d.\u0275mod=r.oAB({type:d}),d.\u0275inj=r.cJS({providers:[{provide:u.V3$,useFactory:()=>a(24444)}],imports:[[b.l,u.Az_,u.vvu,u.gkT,e.$y4,u.Ts3,g.Bz.forChild(L)]]}),d})()},40334:(f,p,a)=>{"use strict";a.r(p),a.d(p,{default:()=>g});const g='<nui-example-wrapper\n    filenamePrefix="data-point-selection-prototype"\n    exampleTitle="Data Point Selection Prototype"\n>\n    <nui-message type="critical" [allowDismiss]="false">\n        <strong>Note:</strong> This is only a prototype, so its implementation\n        is unpolished. Please use discretion when copying the code as there are\n        likely solutions more concise and/or elegant than those presented here.\n        <strong\n            >For assistance, please contact Blake Simmon or Lukas\n            Holcik.</strong\n        >\n    </nui-message>\n    <hr />\n    <nui-chart\n        class="d-flex chart"\n        [chart]="statusChart"\n        nuiChartCollectionId="collection"\n    ></nui-chart>\n    <nui-chart\n        class="d-flex chart"\n        [chart]="barChart"\n        nuiChartCollectionId="collection"\n    ></nui-chart>\n    <hr />\n    <button type="button" nui-button (click)="onReset()">Reset</button>\n</nui-example-wrapper>\n'},38534:(f,p,a)=>{"use strict";a.r(p),a.d(p,{default:()=>g});const g='// \xa9 2022 SolarWinds Worldwide, LLC. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n//  of this software and associated documentation files (the "Software"), to\n//  deal in the Software without restriction, including without limitation the\n//  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n//  sell copies of the Software, and to permit persons to whom the Software is\n//  furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n//  all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n//  THE SOFTWARE.\n\nimport { Component, OnInit, ViewEncapsulation } from "@angular/core";\nimport isEmpty from "lodash/isEmpty";\nimport isUndefined from "lodash/isUndefined";\nimport moment, { duration } from "moment/moment";\n\nimport {\n    BandScale,\n    barAccessors,\n    BarGridConfig,\n    BarHighlightStrategy,\n    BarRenderer,\n    barScales,\n    BarStatusGridConfig,\n    BorderConfig,\n    Chart,\n    CHART_PALETTE_CS1,\n    CHART_PALETTE_CS_S_EXTENDED,\n    convert,\n    DataAccessor,\n    DATA_POINT_NOT_FOUND,\n    IAccessors,\n    IBarRendererConfig,\n    IChartEvent,\n    IDataPoint,\n    IDataSeries,\n    IInteractionDataPointsEvent,\n    IInteractionValues,\n    IInteractionValuesPayload,\n    InteractionLabelPlugin,\n    InteractionLinePlugin,\n    InteractionType,\n    INTERACTION_DATA_POINTS_EVENT,\n    INTERACTION_VALUES_EVENT,\n    IXYScales,\n    MappedValueProvider,\n    MOUSE_ACTIVE_EVENT,\n    SelectedDatPointIdxFn,\n    StatusAccessors,\n    statusAccessors,\n    TimeIntervalScale,\n    UtilityService,\n    XYGrid,\n} from "@nova-ui/charts";\n\nconst format = "YYYY-MM-DDTHH:mm:ssZ";\nconst baseDate = "2016-12-25T15:05:00Z";\n\nenum Status {\n    Up = "up",\n    Warning = "warning",\n    Critical = "critical",\n}\n\n@Component({\n    templateUrl: "./data-point-selection-prototype.component.html",\n    styleUrls: ["./data-point-selection-prototype.component.less"],\n    encapsulation: ViewEncapsulation.None,\n})\nexport class DataPointSelectionPrototypeComponent implements OnInit {\n    public barChart: Chart;\n    public statusChart: Chart;\n\n    // Use the same \'x\' scale id for both charts to ensure that interaction events such as hover are shared between the charts\n    private xScaleId = "xScale";\n\n    private selectedDataPoints: Record<string, IDataPoint> = {};\n    private labelPlugin = new InteractionLabelPlugin();\n    private renderer: BarRenderer;\n    private selectedLabelPosition?: IInteractionValues;\n\n    private colorProvider = {\n        // sets the bars used to visualize the selection box to \'transparent\'. All other bars just use the first color in the CS1 palette.\n        get: (seriesId: string) =>\n            seriesId === "selection-box" ? "transparent" : CHART_PALETTE_CS1[0],\n        reset: () => {},\n    };\n\n    public ngOnInit(): void {\n        this.setUpBarChart();\n        this.setUpStatusChart();\n    }\n\n    public onReset(): void {\n        // Reset the stored selection\n        this.selectedDataPoints = {};\n        this.selectedLabelPosition = undefined;\n\n        // Redraw the charts\n        this.redrawCharts();\n\n        // Re-enable interaction label updates and hide the label by emitting a mouse move \'INTERACTION_VALUES_EVENT\' with empty values.\n        this.labelPlugin.areLabelUpdatesEnabled = true;\n        this.barChart\n            .getEventBus()\n            .getStream(INTERACTION_VALUES_EVENT)\n            .next({\n                data: {\n                    interactionType: InteractionType.MouseMove,\n                    values: {},\n                },\n            });\n    }\n\n    private setUpBarChart() {\n        this.barChart = new Chart(this.configureBarGrid());\n        this.barChart.addPlugin(new InteractionLinePlugin());\n        this.barChart.addPlugin(this.labelPlugin);\n\n        // Setting up data point click handling\n        this.barChart\n            .getEventBus()\n            .getStream(INTERACTION_DATA_POINTS_EVENT)\n            .subscribe(this.handleDataPointsInteraction);\n        // Setting up interaction label update handling\n        this.barChart\n            .getEventBus()\n            .getStream(INTERACTION_VALUES_EVENT)\n            .subscribe(this.handleInteractionLabelUpdates);\n        // Setting up what happens on chart mouseenter and mouseleave\n        this.barChart\n            .getEventBus()\n            .getStream(MOUSE_ACTIVE_EVENT)\n            .subscribe(this.handleMouseActive);\n\n        // The color provider sets the selection boxes to \'transparent\'\n        const accessors = barAccessors({}, this.colorProvider);\n        // The \'cssClassAccessor\' updates the stroke color of the selection box when a time interval is selected\n        accessors.data.cssClass = this.cssClassAccessor;\n\n        const scales = barScales();\n        // Use the same \'x\' scale id as the status chart to ensure that interaction events such as hover are shared between the charts\n        scales.x = new TimeIntervalScale(duration(5, "minutes"), this.xScaleId);\n\n        // The \'barThickness\' method sets the selection box width to be larger than the standard bars\n        accessors.data.thickness = this.barThickness(scales);\n\n        const rendererConfig: IBarRendererConfig = {\n            // Supply a \'selectedDataPointIdxFn\' to the \'BarHighlightStrategy\' to prevent the selected bar\n            // from being deemphasized/grayed out as the chart is hovered.\n            highlightStrategy: new BarHighlightStrategy(\n                "x",\n                1,\n                this.selectedDataPointIdxFn\n            ),\n            cursor: "pointer",\n        };\n        this.renderer = new BarRenderer(rendererConfig);\n\n        // Initialize the bar chart\n        this.barChart.update(\n            getData().map((s) => ({\n                ...s,\n                accessors,\n                renderer: this.renderer,\n                scales,\n            }))\n        );\n    }\n\n    private setUpStatusChart() {\n        this.statusChart = new Chart(this.configureStatusGrid());\n        this.statusChart.addPlugin(new InteractionLinePlugin());\n\n        // Setting up the status chart scales\n        const statusYScale = new BandScale();\n        statusYScale.fixDomain(StatusAccessors.STATUS_DOMAIN);\n        // Use the same \'x\' scale id as the bar chart to ensure that interaction events such as hover are shared between the charts\n        const statusXScale = new TimeIntervalScale(\n            duration(5, "minutes"),\n            this.xScaleId\n        );\n        statusXScale.fixDomain([\n            moment(baseDate, format).toDate(),\n            moment(baseDate, format).add(25, "minutes").toDate(),\n        ]);\n        const statusScales = {\n            x: statusXScale,\n            y: statusYScale,\n        };\n\n        // Setting up the status chart accessors\n        const myStatusAccessors = statusAccessors(\n            new MappedValueProvider<string>(getStatusValueMap())\n        );\n        myStatusAccessors.data.thickness = (data: any) =>\n            data.status === Status.Up ? BarRenderer.THIN : BarRenderer.THICK;\n\n        // The \'cssClassAccessor\' updates the stroke color of the selection box when a time interval is selected\n        // TODO: Implement \'selection-box\' series for displaying the selection box on the status chart. For reference,\n        // see \'selection-box\' data series on the bar chart.\n        myStatusAccessors.data.cssClass = this.cssClassAccessor;\n\n        // Initializing the status chart\n        this.statusChart.update(\n            getStatusData().map((d) => ({\n                ...d,\n                accessors: myStatusAccessors,\n                renderer: this.renderer,\n                scales: statusScales,\n            }))\n        );\n    }\n\n    private configureBarGrid() {\n        const gridConfig = new BarGridConfig();\n\n        gridConfig.axis.left.visible = false;\n        gridConfig.axis.left.gridTicks = false;\n        // Disable \'axis.bottom.fit\' to set left and right margins manually\n        gridConfig.axis.bottom.fit = false;\n        gridConfig.borders.top = new BorderConfig();\n        gridConfig.cursor = "pointer";\n        gridConfig.dimension.padding.top = 0;\n        // Synchronize the left and right margins (left margin default is 30px)\n        gridConfig.dimension.margin.right = gridConfig.dimension.margin.left;\n\n        // Use these settings to make the bar chart the same height as the status chart\n        // gridConfig.dimension.autoHeight = false;\n        // gridConfig.dimension.height(30);\n\n        return new XYGrid(gridConfig);\n    }\n\n    private configureStatusGrid() {\n        const gridConfig = new BarStatusGridConfig();\n\n        gridConfig.axis.bottom.visible = false;\n        gridConfig.cursor = "pointer";\n        gridConfig.dimension.margin.bottom = 0;\n        // Synchronize the left and right margins (left margin default is 30px)\n        gridConfig.dimension.margin.right = gridConfig.dimension.margin.left;\n        gridConfig.borders.bottom.visible = false;\n\n        return new XYGrid(gridConfig);\n    }\n\n    private redrawCharts() {\n        this.barChart.update(this.barChart.getDataManager().chartSeriesSet);\n        this.statusChart.update(\n            this.statusChart.getDataManager().chartSeriesSet\n        );\n    }\n\n    private handleDataPointsInteraction = (event: IChartEvent) => {\n        const data: IInteractionDataPointsEvent = event.data;\n        // we\'re interested in data point click events here\n        if (data.interactionType === InteractionType.Click) {\n            // set the selected data points\n            this.selectedDataPoints = data.dataPoints;\n\n            if (this.renderer.config.stateStyles) {\n                // change the bar container opacity from 0.1 to 0.3\n                this.renderer.config.stateStyles.deemphasized = {\n                    opacity: 0.3,\n                };\n            }\n\n            // redraw the charts to apply the selected data point style\n            this.redrawCharts();\n\n            // store the interaction label position for the selected data point\n            this.selectedLabelPosition =\n                this.calculateInteractionLabelPosition(data);\n\n            // apply the label position based on the click\n            this.barChart\n                .getEventBus()\n                .getStream(INTERACTION_VALUES_EVENT)\n                .next({\n                    data: {\n                        interactionType: InteractionType.MouseMove,\n                        values: this.selectedLabelPosition,\n                    },\n                });\n        }\n    };\n\n    private handleInteractionLabelUpdates = (event: IChartEvent) => {\n        const data: IInteractionValuesPayload = event.data;\n\n        // The condition checks whether the mouse has moved away from the chart and a selected label position is stored\n        if (\n            data.interactionType === InteractionType.MouseMove &&\n            isEmpty(data.values) &&\n            this.selectedLabelPosition\n        ) {\n            // ensure label updates are enabled\n            this.labelPlugin.areLabelUpdatesEnabled = true;\n\n            // Update the label with the stored label position by manually emitting an \'INTERACTION_VALUES_EVENT\'.\n            // Note that \'broadcast\' is set to \'true\' to let the \'nuiChartCollection\' directive know that the event is\n            // coming from outside the chart and should not propagate to other charts in the collection.\n            this.barChart\n                .getEventBus()\n                .getStream(INTERACTION_VALUES_EVENT)\n                .next({\n                    data: {\n                        interactionType: InteractionType.MouseMove,\n                        values: this.selectedLabelPosition,\n                    },\n                    broadcast: true,\n                });\n\n            // disable further label updates\n            this.labelPlugin.areLabelUpdatesEnabled = false;\n        } else if (\n            data.interactionType === InteractionType.MouseMove &&\n            !isEmpty(data.values)\n        ) {\n            // allow label updates while the mouse is hovering over the chart\n            this.labelPlugin.areLabelUpdatesEnabled = true;\n        }\n    };\n\n    private handleMouseActive = (event: IChartEvent) => {\n        if (this.renderer.config.stateStyles) {\n            if (!isEmpty(this.selectedDataPoints) && !event.data) {\n                // if there\'s a selected data point and the mouse has moved away\n                // from the chart, set the bar container opacity to 0.3\n                this.renderer.config.stateStyles.deemphasized = {\n                    opacity: 0.3,\n                };\n            } else if (event.data) {\n                // if the mouse is over the chart set the bar container opacity to 0.3\n                this.renderer.config.stateStyles.deemphasized = {\n                    opacity: 0.1,\n                };\n            }\n        }\n\n        if (\n            this.barChart.getDataManager().chartSeriesSet.length > 0 &&\n            this.statusChart.getDataManager().chartSeriesSet.length > 0\n        ) {\n            // redraw the charts if we have data\n            this.redrawCharts();\n        }\n    };\n\n    /**\n     * Sets the width of the bars on the bar chart. (This is only necessary if you want the selection boxes\n     * to be wider than the standard bars).\n     */\n    private barThickness(scales: IXYScales): DataAccessor<any, any> {\n        return (\n            d: any,\n            i: number,\n            series: any[],\n            dataSeries: IDataSeries<IAccessors>\n        ) => {\n            let thickness: number;\n            const x1 = convert(\n                scales.x,\n                dataSeries.accessors.data?.["startX"]?.(\n                    d,\n                    i,\n                    dataSeries.data,\n                    dataSeries\n                ),\n                0\n            );\n            const x2 = convert(\n                scales.x,\n                dataSeries.accessors.data?.["endX"]?.(\n                    d,\n                    i,\n                    dataSeries.data,\n                    dataSeries\n                ),\n                1\n            );\n            thickness = Math.abs(x1 - x2);\n\n            // Allow the selection boxes to be a little wider than the data bars\n            thickness -= dataSeries.id === "selection-box" ? 2 : 6;\n            thickness = Math.max(thickness, BarRenderer.MIN_BAR_THICKNESS);\n            return thickness;\n        };\n    }\n\n    /**\n     * Allows the \'BarHighlightingStrategy\' to know which data point (or bar) on a series is selected, if any.\n     * Return \'DATA_POINT_NOT_FOUND\' if no data point is selected on the specified series.\n     */\n    private selectedDataPointIdxFn: SelectedDatPointIdxFn = (\n        seriesId: string\n    ): number =>\n        this.selectedDataPoints?.[seriesId]?.index ?? DATA_POINT_NOT_FOUND;\n\n    /**\n     * Sets the stroke color of the selection box when a time interval is selected\n     *\n     * @returns The \'selected\' class (see less file) if a bar is selected, the series id matches the selection box series, and the\n     * selected data point index matches the current index; otherwise, returns an empty string.\n     */\n    private cssClassAccessor = (\n        d: any,\n        i: number,\n        series: any,\n        dataSeries: any\n    ): string =>\n        !isEmpty(this.selectedDataPoints) &&\n        dataSeries.id === "selection-box" &&\n        this.selectedDataPoints[dataSeries.id]?.index === i\n            ? "selected"\n            : "";\n\n    /**\n     * Calculates the desired position of the interaction label based on the position of the first data point in the event payload\n     */\n    private calculateInteractionLabelPosition(\n        data: IInteractionDataPointsEvent\n    ): IInteractionValues {\n        const sampleDataPoint =\n            data.dataPoints[Object.keys(data.dataPoints)[0]];\n        const xScales = [sampleDataPoint.dataSeries.scales.x];\n        const yScales = [sampleDataPoint.dataSeries.scales.y];\n\n        if (\n            !sampleDataPoint.position ||\n            isUndefined(sampleDataPoint.position.width) ||\n            isUndefined(sampleDataPoint.position.height)\n        ) {\n            throw new Error("Can\'t calculate x and y values");\n        }\n\n        const xCoordinate =\n            sampleDataPoint.position.x + sampleDataPoint.position.width / 2;\n        const yCoordinate =\n            sampleDataPoint.position.y + sampleDataPoint.position.height / 2;\n\n        return UtilityService.getXYValues(\n            xScales,\n            yScales,\n            xCoordinate,\n            yCoordinate\n        );\n    }\n}\n\n/* Chart data */\nfunction getData() {\n    return [\n        {\n            id: "series-1",\n            data: [\n                { category: moment(baseDate, format).toDate(), value: 66 },\n                {\n                    category: moment(baseDate, format)\n                        .add(5, "minutes")\n                        .toDate(),\n                    value: 14,\n                },\n                {\n                    category: moment(baseDate, format)\n                        .add(10, "minutes")\n                        .toDate(),\n                    value: 25,\n                },\n                {\n                    category: moment(baseDate, format)\n                        .add(15, "minutes")\n                        .toDate(),\n                    value: 55,\n                },\n                {\n                    category: moment(baseDate, format)\n                        .add(20, "minutes")\n                        .toDate(),\n                    value: 33,\n                },\n                {\n                    category: moment(baseDate, format)\n                        .add(25, "minutes")\n                        .toDate(),\n                    value: 5,\n                },\n            ],\n        },\n\n        // The sole purpose of this series is to define the selection boxes that have a togglable selection\n        // outline. The \'fill\' of the boxes is set to transparent by the \'colorProvider\' in the component\n        // above. And, the blue outline of the selected time interval is toggled by the \'cssClassAccessor\'\n        // method in the above component.\n        {\n            id: "selection-box",\n            data: [\n                { category: moment(baseDate, format).toDate(), value: 100 },\n                {\n                    category: moment(baseDate, format)\n                        .add(5, "minutes")\n                        .toDate(),\n                    value: 100,\n                },\n                {\n                    category: moment(baseDate, format)\n                        .add(10, "minutes")\n                        .toDate(),\n                    value: 100,\n                },\n                {\n                    category: moment(baseDate, format)\n                        .add(15, "minutes")\n                        .toDate(),\n                    value: 100,\n                },\n                {\n                    category: moment(baseDate, format)\n                        .add(20, "minutes")\n                        .toDate(),\n                    value: 100,\n                },\n                {\n                    category: moment(baseDate, format)\n                        .add(25, "minutes")\n                        .toDate(),\n                    value: 100,\n                },\n            ],\n        },\n    ];\n}\n\nfunction getStatusValueMap() {\n    return {\n        [Status.Up]: CHART_PALETTE_CS_S_EXTENDED[8],\n        [Status.Warning]: CHART_PALETTE_CS_S_EXTENDED[4],\n        [Status.Critical]: CHART_PALETTE_CS_S_EXTENDED[2],\n    };\n}\n\nfunction getStatusData() {\n    return [\n        {\n            id: "series-1",\n            name: "Series 1",\n            data: [\n                {\n                    status: Status.Up,\n                    start: moment(baseDate, format).toDate(),\n                    end: moment(baseDate, format).toDate(),\n                },\n                {\n                    status: Status.Warning,\n                    start: moment(baseDate, format).add(5, "minutes").toDate(),\n                    end: moment(baseDate, format).add(5, "minutes").toDate(),\n                },\n                {\n                    status: Status.Critical,\n                    start: moment(baseDate, format).add(10, "minutes").toDate(),\n                    end: moment(baseDate, format).add(10, "minutes").toDate(),\n                },\n                {\n                    status: Status.Up,\n                    start: moment(baseDate, format).add(15, "minutes").toDate(),\n                    end: moment(baseDate, format).add(15, "minutes").toDate(),\n                },\n                {\n                    status: Status.Critical,\n                    start: moment(baseDate, format).add(20, "minutes").toDate(),\n                    end: moment(baseDate, format).add(20, "minutes").toDate(),\n                },\n                {\n                    status: Status.Up,\n                    start: moment(baseDate, format).add(25, "minutes").toDate(),\n                    end: moment(baseDate, format).add(25, "minutes").toDate(),\n                },\n            ],\n        },\n    ];\n}\n'},45937:(f,p,a)=>{"use strict";a.r(p),a.d(p,{default:()=>g});const g='// \xa9 2022 SolarWinds Worldwide, LLC. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n//  of this software and associated documentation files (the "Software"), to\n//  deal in the Software without restriction, including without limitation the\n//  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n//  sell copies of the Software, and to permit persons to whom the Software is\n//  furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n//  all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n//  THE SOFTWARE.\n\nimport { NgModule } from "@angular/core";\nimport { RouterModule, Routes } from "@angular/router";\n\nimport {\n    DEMO_PATH_TOKEN,\n    NuiButtonModule,\n    NuiDocsModule,\n    NuiIconModule,\n    NuiMessageModule,\n} from "@nova-ui/bits";\nimport { NuiChartsModule } from "@nova-ui/charts";\n\nimport { DemoCommonModule } from "../../common/demo-common.module";\nimport { DataPointSelectionPrototypeComponent } from "./data-point-selection-prototype.component";\n\nconst routes: Routes = [\n    {\n        path: "",\n        component: DataPointSelectionPrototypeComponent,\n        data: {\n            srlc: {\n                hideIndicator: true,\n            },\n        },\n    },\n];\n\n@NgModule({\n    declarations: [DataPointSelectionPrototypeComponent],\n    imports: [\n        DemoCommonModule,\n        NuiButtonModule,\n        NuiDocsModule,\n        NuiMessageModule,\n        NuiChartsModule,\n        NuiIconModule,\n        RouterModule.forChild(routes),\n    ],\n    providers: [\n        {\n            provide: DEMO_PATH_TOKEN,\n            useFactory: () =>\n                (<any>require).context(\n                    `!!raw-loader!./`,\n                    true,\n                    /.*\\.(ts|html|less)$/\n                ),\n        },\n    ],\n})\nexport class DataPointSelectionPrototypeModule {}\n'},79334:f=>{"use strict";f.exports='export default ".selected {\\n    stroke: #52d9e3 !important;\\n}\\n\\n.chart {\\n    max-width: 800px;\\n}\\n";'}}]);